
Praktikum6.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000368e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000056  00802000  0000368e  00003722  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000283  00802056  00802056  00003778  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00003778  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000044  00000000  00000000  000037d4  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000620  00000000  00000000  00003818  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00012bea  00000000  00000000  00003e38  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00005744  00000000  00000000  00016a22  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005756  00000000  00000000  0001c166  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000013b4  00000000  00000000  000218bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000056f1  00000000  00000000  00022c70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009dda  00000000  00000000  00028361  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000007f0  00000000  00000000  0003213b  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	50 c2       	rjmp	.+1184   	; 0x4a2 <__ctors_end>
       2:	00 00       	nop
       4:	6f c2       	rjmp	.+1246   	; 0x4e4 <__bad_interrupt>
       6:	00 00       	nop
       8:	6d c2       	rjmp	.+1242   	; 0x4e4 <__bad_interrupt>
       a:	00 00       	nop
       c:	6b c2       	rjmp	.+1238   	; 0x4e4 <__bad_interrupt>
       e:	00 00       	nop
      10:	69 c2       	rjmp	.+1234   	; 0x4e4 <__bad_interrupt>
      12:	00 00       	nop
      14:	67 c2       	rjmp	.+1230   	; 0x4e4 <__bad_interrupt>
      16:	00 00       	nop
      18:	65 c2       	rjmp	.+1226   	; 0x4e4 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	63 c2       	rjmp	.+1222   	; 0x4e4 <__bad_interrupt>
      1e:	00 00       	nop
      20:	61 c2       	rjmp	.+1218   	; 0x4e4 <__bad_interrupt>
      22:	00 00       	nop
      24:	5f c2       	rjmp	.+1214   	; 0x4e4 <__bad_interrupt>
      26:	00 00       	nop
      28:	5d c2       	rjmp	.+1210   	; 0x4e4 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	5b c2       	rjmp	.+1206   	; 0x4e4 <__bad_interrupt>
      2e:	00 00       	nop
      30:	59 c2       	rjmp	.+1202   	; 0x4e4 <__bad_interrupt>
      32:	00 00       	nop
      34:	57 c2       	rjmp	.+1198   	; 0x4e4 <__bad_interrupt>
      36:	00 00       	nop
      38:	0c 94 5b 09 	jmp	0x12b6	; 0x12b6 <__vector_14>
      3c:	53 c2       	rjmp	.+1190   	; 0x4e4 <__bad_interrupt>
      3e:	00 00       	nop
      40:	51 c2       	rjmp	.+1186   	; 0x4e4 <__bad_interrupt>
      42:	00 00       	nop
      44:	4f c2       	rjmp	.+1182   	; 0x4e4 <__bad_interrupt>
      46:	00 00       	nop
      48:	4d c2       	rjmp	.+1178   	; 0x4e4 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	4b c2       	rjmp	.+1174   	; 0x4e4 <__bad_interrupt>
      4e:	00 00       	nop
      50:	49 c2       	rjmp	.+1170   	; 0x4e4 <__bad_interrupt>
      52:	00 00       	nop
      54:	47 c2       	rjmp	.+1166   	; 0x4e4 <__bad_interrupt>
      56:	00 00       	nop
      58:	45 c2       	rjmp	.+1162   	; 0x4e4 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	43 c2       	rjmp	.+1158   	; 0x4e4 <__bad_interrupt>
      5e:	00 00       	nop
      60:	41 c2       	rjmp	.+1154   	; 0x4e4 <__bad_interrupt>
      62:	00 00       	nop
      64:	3f c2       	rjmp	.+1150   	; 0x4e4 <__bad_interrupt>
      66:	00 00       	nop
      68:	3d c2       	rjmp	.+1146   	; 0x4e4 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	3b c2       	rjmp	.+1142   	; 0x4e4 <__bad_interrupt>
      6e:	00 00       	nop
      70:	39 c2       	rjmp	.+1138   	; 0x4e4 <__bad_interrupt>
      72:	00 00       	nop
      74:	37 c2       	rjmp	.+1134   	; 0x4e4 <__bad_interrupt>
      76:	00 00       	nop
      78:	35 c2       	rjmp	.+1130   	; 0x4e4 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	33 c2       	rjmp	.+1126   	; 0x4e4 <__bad_interrupt>
      7e:	00 00       	nop
      80:	31 c2       	rjmp	.+1122   	; 0x4e4 <__bad_interrupt>
      82:	00 00       	nop
      84:	2f c2       	rjmp	.+1118   	; 0x4e4 <__bad_interrupt>
      86:	00 00       	nop
      88:	2d c2       	rjmp	.+1114   	; 0x4e4 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	2b c2       	rjmp	.+1110   	; 0x4e4 <__bad_interrupt>
      8e:	00 00       	nop
      90:	29 c2       	rjmp	.+1106   	; 0x4e4 <__bad_interrupt>
      92:	00 00       	nop
      94:	27 c2       	rjmp	.+1102   	; 0x4e4 <__bad_interrupt>
      96:	00 00       	nop
      98:	25 c2       	rjmp	.+1098   	; 0x4e4 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	23 c2       	rjmp	.+1094   	; 0x4e4 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	21 c2       	rjmp	.+1090   	; 0x4e4 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	1f c2       	rjmp	.+1086   	; 0x4e4 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	1d c2       	rjmp	.+1082   	; 0x4e4 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	1b c2       	rjmp	.+1078   	; 0x4e4 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	19 c2       	rjmp	.+1074   	; 0x4e4 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	17 c2       	rjmp	.+1070   	; 0x4e4 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	15 c2       	rjmp	.+1066   	; 0x4e4 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	13 c2       	rjmp	.+1062   	; 0x4e4 <__bad_interrupt>
      be:	00 00       	nop
      c0:	11 c2       	rjmp	.+1058   	; 0x4e4 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	0f c2       	rjmp	.+1054   	; 0x4e4 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	0d c2       	rjmp	.+1050   	; 0x4e4 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0b c2       	rjmp	.+1046   	; 0x4e4 <__bad_interrupt>
      ce:	00 00       	nop
      d0:	09 c2       	rjmp	.+1042   	; 0x4e4 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	07 c2       	rjmp	.+1038   	; 0x4e4 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	05 c2       	rjmp	.+1034   	; 0x4e4 <__bad_interrupt>
      da:	00 00       	nop
      dc:	03 c2       	rjmp	.+1030   	; 0x4e4 <__bad_interrupt>
      de:	00 00       	nop
      e0:	01 c2       	rjmp	.+1026   	; 0x4e4 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	ff c1       	rjmp	.+1022   	; 0x4e4 <__bad_interrupt>
      e6:	00 00       	nop
      e8:	fd c1       	rjmp	.+1018   	; 0x4e4 <__bad_interrupt>
      ea:	00 00       	nop
      ec:	fb c1       	rjmp	.+1014   	; 0x4e4 <__bad_interrupt>
      ee:	00 00       	nop
      f0:	f9 c1       	rjmp	.+1010   	; 0x4e4 <__bad_interrupt>
      f2:	00 00       	nop
      f4:	f7 c1       	rjmp	.+1006   	; 0x4e4 <__bad_interrupt>
      f6:	00 00       	nop
      f8:	f5 c1       	rjmp	.+1002   	; 0x4e4 <__bad_interrupt>
      fa:	00 00       	nop
      fc:	f3 c1       	rjmp	.+998    	; 0x4e4 <__bad_interrupt>
      fe:	00 00       	nop
     100:	f1 c1       	rjmp	.+994    	; 0x4e4 <__bad_interrupt>
     102:	00 00       	nop
     104:	ef c1       	rjmp	.+990    	; 0x4e4 <__bad_interrupt>
     106:	00 00       	nop
     108:	ed c1       	rjmp	.+986    	; 0x4e4 <__bad_interrupt>
     10a:	00 00       	nop
     10c:	eb c1       	rjmp	.+982    	; 0x4e4 <__bad_interrupt>
     10e:	00 00       	nop
     110:	e9 c1       	rjmp	.+978    	; 0x4e4 <__bad_interrupt>
     112:	00 00       	nop
     114:	e7 c1       	rjmp	.+974    	; 0x4e4 <__bad_interrupt>
     116:	00 00       	nop
     118:	e5 c1       	rjmp	.+970    	; 0x4e4 <__bad_interrupt>
     11a:	00 00       	nop
     11c:	e3 c1       	rjmp	.+966    	; 0x4e4 <__bad_interrupt>
     11e:	00 00       	nop
     120:	e1 c1       	rjmp	.+962    	; 0x4e4 <__bad_interrupt>
     122:	00 00       	nop
     124:	df c1       	rjmp	.+958    	; 0x4e4 <__bad_interrupt>
     126:	00 00       	nop
     128:	dd c1       	rjmp	.+954    	; 0x4e4 <__bad_interrupt>
     12a:	00 00       	nop
     12c:	db c1       	rjmp	.+950    	; 0x4e4 <__bad_interrupt>
     12e:	00 00       	nop
     130:	d9 c1       	rjmp	.+946    	; 0x4e4 <__bad_interrupt>
     132:	00 00       	nop
     134:	d7 c1       	rjmp	.+942    	; 0x4e4 <__bad_interrupt>
     136:	00 00       	nop
     138:	d5 c1       	rjmp	.+938    	; 0x4e4 <__bad_interrupt>
     13a:	00 00       	nop
     13c:	d3 c1       	rjmp	.+934    	; 0x4e4 <__bad_interrupt>
     13e:	00 00       	nop
     140:	d1 c1       	rjmp	.+930    	; 0x4e4 <__bad_interrupt>
     142:	00 00       	nop
     144:	cf c1       	rjmp	.+926    	; 0x4e4 <__bad_interrupt>
     146:	00 00       	nop
     148:	cd c1       	rjmp	.+922    	; 0x4e4 <__bad_interrupt>
     14a:	00 00       	nop
     14c:	cb c1       	rjmp	.+918    	; 0x4e4 <__bad_interrupt>
     14e:	00 00       	nop
     150:	c9 c1       	rjmp	.+914    	; 0x4e4 <__bad_interrupt>
     152:	00 00       	nop
     154:	c7 c1       	rjmp	.+910    	; 0x4e4 <__bad_interrupt>
     156:	00 00       	nop
     158:	c5 c1       	rjmp	.+906    	; 0x4e4 <__bad_interrupt>
     15a:	00 00       	nop
     15c:	c3 c1       	rjmp	.+902    	; 0x4e4 <__bad_interrupt>
     15e:	00 00       	nop
     160:	c1 c1       	rjmp	.+898    	; 0x4e4 <__bad_interrupt>
     162:	00 00       	nop
     164:	bf c1       	rjmp	.+894    	; 0x4e4 <__bad_interrupt>
     166:	00 00       	nop
     168:	bd c1       	rjmp	.+890    	; 0x4e4 <__bad_interrupt>
     16a:	00 00       	nop
     16c:	bb c1       	rjmp	.+886    	; 0x4e4 <__bad_interrupt>
     16e:	00 00       	nop
     170:	b9 c1       	rjmp	.+882    	; 0x4e4 <__bad_interrupt>
     172:	00 00       	nop
     174:	b7 c1       	rjmp	.+878    	; 0x4e4 <__bad_interrupt>
     176:	00 00       	nop
     178:	b5 c1       	rjmp	.+874    	; 0x4e4 <__bad_interrupt>
     17a:	00 00       	nop
     17c:	b3 c1       	rjmp	.+870    	; 0x4e4 <__bad_interrupt>
     17e:	00 00       	nop
     180:	b1 c1       	rjmp	.+866    	; 0x4e4 <__bad_interrupt>
     182:	00 00       	nop
     184:	af c1       	rjmp	.+862    	; 0x4e4 <__bad_interrupt>
     186:	00 00       	nop
     188:	ad c1       	rjmp	.+858    	; 0x4e4 <__bad_interrupt>
     18a:	00 00       	nop
     18c:	ab c1       	rjmp	.+854    	; 0x4e4 <__bad_interrupt>
     18e:	00 00       	nop
     190:	a9 c1       	rjmp	.+850    	; 0x4e4 <__bad_interrupt>
     192:	00 00       	nop
     194:	a7 c1       	rjmp	.+846    	; 0x4e4 <__bad_interrupt>
     196:	00 00       	nop
     198:	a5 c1       	rjmp	.+842    	; 0x4e4 <__bad_interrupt>
     19a:	00 00       	nop
     19c:	a3 c1       	rjmp	.+838    	; 0x4e4 <__bad_interrupt>
     19e:	00 00       	nop
     1a0:	a1 c1       	rjmp	.+834    	; 0x4e4 <__bad_interrupt>
     1a2:	00 00       	nop
     1a4:	9f c1       	rjmp	.+830    	; 0x4e4 <__bad_interrupt>
     1a6:	00 00       	nop
     1a8:	9d c1       	rjmp	.+826    	; 0x4e4 <__bad_interrupt>
     1aa:	00 00       	nop
     1ac:	9b c1       	rjmp	.+822    	; 0x4e4 <__bad_interrupt>
     1ae:	00 00       	nop
     1b0:	99 c1       	rjmp	.+818    	; 0x4e4 <__bad_interrupt>
     1b2:	00 00       	nop
     1b4:	97 c1       	rjmp	.+814    	; 0x4e4 <__bad_interrupt>
     1b6:	00 00       	nop
     1b8:	95 c1       	rjmp	.+810    	; 0x4e4 <__bad_interrupt>
     1ba:	00 00       	nop
     1bc:	93 c1       	rjmp	.+806    	; 0x4e4 <__bad_interrupt>
     1be:	00 00       	nop
     1c0:	91 c1       	rjmp	.+802    	; 0x4e4 <__bad_interrupt>
     1c2:	00 00       	nop
     1c4:	8f c1       	rjmp	.+798    	; 0x4e4 <__bad_interrupt>
     1c6:	00 00       	nop
     1c8:	8d c1       	rjmp	.+794    	; 0x4e4 <__bad_interrupt>
     1ca:	00 00       	nop
     1cc:	8b c1       	rjmp	.+790    	; 0x4e4 <__bad_interrupt>
     1ce:	00 00       	nop
     1d0:	89 c1       	rjmp	.+786    	; 0x4e4 <__bad_interrupt>
     1d2:	00 00       	nop
     1d4:	87 c1       	rjmp	.+782    	; 0x4e4 <__bad_interrupt>
     1d6:	00 00       	nop
     1d8:	85 c1       	rjmp	.+778    	; 0x4e4 <__bad_interrupt>
     1da:	00 00       	nop
     1dc:	83 c1       	rjmp	.+774    	; 0x4e4 <__bad_interrupt>
     1de:	00 00       	nop
     1e0:	81 c1       	rjmp	.+770    	; 0x4e4 <__bad_interrupt>
     1e2:	00 00       	nop
     1e4:	7f c1       	rjmp	.+766    	; 0x4e4 <__bad_interrupt>
     1e6:	00 00       	nop
     1e8:	7d c1       	rjmp	.+762    	; 0x4e4 <__bad_interrupt>
     1ea:	00 00       	nop
     1ec:	7b c1       	rjmp	.+758    	; 0x4e4 <__bad_interrupt>
     1ee:	00 00       	nop
     1f0:	79 c1       	rjmp	.+754    	; 0x4e4 <__bad_interrupt>
     1f2:	00 00       	nop
     1f4:	77 c1       	rjmp	.+750    	; 0x4e4 <__bad_interrupt>
     1f6:	00 00       	nop
     1f8:	75 c1       	rjmp	.+746    	; 0x4e4 <__bad_interrupt>
     1fa:	00 00       	nop
     1fc:	7b 12       	cpse	r7, r27
     1fe:	7b 12       	cpse	r7, r27
     200:	7b 12       	cpse	r7, r27
     202:	a8 12       	cpse	r10, r24
     204:	b0 12       	cpse	r11, r16
     206:	be 12       	cpse	r11, r30
     208:	7b 12       	cpse	r7, r27
     20a:	7b 12       	cpse	r7, r27
     20c:	a8 12       	cpse	r10, r24
     20e:	b0 12       	cpse	r11, r16

00000210 <__trampolines_end>:
     210:	00 00       	nop
     212:	00 00       	nop
     214:	00 00       	nop
     216:	00 20       	and	r0, r0
     218:	20 20       	and	r2, r0
     21a:	20 20       	and	r2, r0
     21c:	00 20       	and	r0, r0
     21e:	50 50       	subi	r21, 0x00	; 0
     220:	50 00       	.word	0x0050	; ????
     222:	00 00       	nop
     224:	00 50       	subi	r16, 0x00	; 0
     226:	50 f8       	bld	r5, 0
     228:	50 f8       	bld	r5, 0
     22a:	50 50       	subi	r21, 0x00	; 0
     22c:	20 78       	andi	r18, 0x80	; 128
     22e:	a0 70       	andi	r26, 0x00	; 0
     230:	28 f0       	brcs	.+10     	; 0x23c <__trampolines_end+0x2c>
     232:	20 c0       	rjmp	.+64     	; 0x274 <__trampolines_end+0x64>
     234:	c8 10       	cpse	r12, r8
     236:	20 40       	sbci	r18, 0x00	; 0
     238:	98 18       	sub	r9, r8
     23a:	60 90 a0 40 	lds	r6, 0x40A0	; 0x8040a0 <__bss_end+0x1dc7>
     23e:	a8 90       	.word	0x90a8	; ????
     240:	68 60       	ori	r22, 0x08	; 8
     242:	20 40       	sbci	r18, 0x00	; 0
     244:	00 00       	nop
     246:	00 00       	nop
     248:	10 20       	and	r1, r0
     24a:	40 40       	sbci	r20, 0x00	; 0
     24c:	40 20       	and	r4, r0
     24e:	10 40       	sbci	r17, 0x00	; 0
     250:	20 10       	cpse	r2, r0
     252:	10 10       	cpse	r1, r0
     254:	20 40       	sbci	r18, 0x00	; 0
     256:	00 50       	subi	r16, 0x00	; 0
     258:	20 f8       	bld	r2, 0
     25a:	20 50       	subi	r18, 0x00	; 0
     25c:	00 00       	nop
     25e:	20 20       	and	r2, r0
     260:	f8 20       	and	r15, r8
     262:	20 00       	.word	0x0020	; ????
     264:	00 00       	nop
     266:	00 00       	nop
     268:	60 20       	and	r6, r0
     26a:	40 00       	.word	0x0040	; ????
     26c:	00 00       	nop
     26e:	f8 00       	.word	0x00f8	; ????
     270:	00 00       	nop
     272:	00 00       	nop
     274:	00 00       	nop
     276:	00 60       	ori	r16, 0x00	; 0
     278:	60 00       	.word	0x0060	; ????
     27a:	08 10       	cpse	r0, r8
     27c:	20 40       	sbci	r18, 0x00	; 0
     27e:	80 00       	.word	0x0080	; ????
     280:	70 88       	ldd	r7, Z+16	; 0x10
     282:	98 a8       	ldd	r9, Y+48	; 0x30
     284:	c8 88       	ldd	r12, Y+16	; 0x10
     286:	70 20       	and	r7, r0
     288:	60 20       	and	r6, r0
     28a:	20 20       	and	r2, r0
     28c:	20 70       	andi	r18, 0x00	; 0
     28e:	70 88       	ldd	r7, Z+16	; 0x10
     290:	08 10       	cpse	r0, r8
     292:	20 40       	sbci	r18, 0x00	; 0
     294:	f8 f8       	.word	0xf8f8	; ????
     296:	10 20       	and	r1, r0
     298:	10 08       	sbc	r1, r0
     29a:	88 70       	andi	r24, 0x08	; 8
     29c:	10 30       	cpi	r17, 0x00	; 0
     29e:	50 90 f8 10 	lds	r5, 0x10F8	; 0x8010f8 <__TEXT_REGION_LENGTH__+0x7010f8>
     2a2:	10 f8       	bld	r1, 0
     2a4:	80 f0       	brcs	.+32     	; 0x2c6 <__trampolines_end+0xb6>
     2a6:	08 08       	sbc	r0, r8
     2a8:	88 70       	andi	r24, 0x08	; 8
     2aa:	30 40       	sbci	r19, 0x00	; 0
     2ac:	80 f0       	brcs	.+32     	; 0x2ce <__trampolines_end+0xbe>
     2ae:	88 88       	ldd	r8, Y+16	; 0x10
     2b0:	70 f8       	bld	r7, 0
     2b2:	08 10       	cpse	r0, r8
     2b4:	20 40       	sbci	r18, 0x00	; 0
     2b6:	40 40       	sbci	r20, 0x00	; 0
     2b8:	70 88       	ldd	r7, Z+16	; 0x10
     2ba:	88 70       	andi	r24, 0x08	; 8
     2bc:	88 88       	ldd	r8, Y+16	; 0x10
     2be:	70 70       	andi	r23, 0x00	; 0
     2c0:	88 88       	ldd	r8, Y+16	; 0x10
     2c2:	78 08       	sbc	r7, r8
     2c4:	10 60       	ori	r17, 0x00	; 0
     2c6:	00 60       	ori	r16, 0x00	; 0
     2c8:	60 00       	.word	0x0060	; ????
     2ca:	60 60       	ori	r22, 0x00	; 0
     2cc:	00 00       	nop
     2ce:	60 60       	ori	r22, 0x00	; 0
     2d0:	00 60       	ori	r16, 0x00	; 0
     2d2:	20 40       	sbci	r18, 0x00	; 0
     2d4:	08 10       	cpse	r0, r8
     2d6:	20 40       	sbci	r18, 0x00	; 0
     2d8:	20 10       	cpse	r2, r0
     2da:	08 00       	.word	0x0008	; ????
     2dc:	00 f8       	bld	r0, 0
     2de:	00 f8       	bld	r0, 0
     2e0:	00 00       	nop
     2e2:	80 40       	sbci	r24, 0x00	; 0
     2e4:	20 10       	cpse	r2, r0
     2e6:	20 40       	sbci	r18, 0x00	; 0
     2e8:	80 70       	andi	r24, 0x00	; 0
     2ea:	88 08       	sbc	r8, r8
     2ec:	10 20       	and	r1, r0
     2ee:	00 20       	and	r0, r0
     2f0:	70 88       	ldd	r7, Z+16	; 0x10
     2f2:	08 68       	ori	r16, 0x88	; 136
     2f4:	a8 a8       	ldd	r10, Y+48	; 0x30
     2f6:	70 70       	andi	r23, 0x00	; 0
     2f8:	88 88       	ldd	r8, Y+16	; 0x10
     2fa:	88 f8       	.word	0xf888	; ????
     2fc:	88 88       	ldd	r8, Y+16	; 0x10
     2fe:	f0 88       	ldd	r15, Z+16	; 0x10
     300:	88 f0       	brcs	.+34     	; 0x324 <__trampolines_end+0x114>
     302:	88 88       	ldd	r8, Y+16	; 0x10
     304:	f0 70       	andi	r31, 0x00	; 0
     306:	88 80       	ld	r8, Y
     308:	80 80       	ld	r8, Z
     30a:	88 70       	andi	r24, 0x08	; 8
     30c:	e0 90 88 88 	lds	r14, 0x8888	; 0x808888 <__bss_end+0x65af>
     310:	88 90       	.word	0x9088	; ????
     312:	e0 f8       	bld	r14, 0
     314:	80 80       	ld	r8, Z
     316:	f0 80       	ld	r15, Z
     318:	80 f8       	bld	r8, 0
     31a:	f8 80       	ld	r15, Y
     31c:	80 e0       	ldi	r24, 0x00	; 0
     31e:	80 80       	ld	r8, Z
     320:	80 70       	andi	r24, 0x00	; 0
     322:	88 80       	ld	r8, Y
     324:	80 98       	cbi	0x10, 0	; 16
     326:	88 70       	andi	r24, 0x08	; 8
     328:	88 88       	ldd	r8, Y+16	; 0x10
     32a:	88 f8       	.word	0xf888	; ????
     32c:	88 88       	ldd	r8, Y+16	; 0x10
     32e:	88 70       	andi	r24, 0x08	; 8
     330:	20 20       	and	r2, r0
     332:	20 20       	and	r2, r0
     334:	20 70       	andi	r18, 0x00	; 0
     336:	38 10       	cpse	r3, r8
     338:	10 10       	cpse	r1, r0
     33a:	10 90 60 88 	lds	r1, 0x8860	; 0x808860 <__bss_end+0x6587>
     33e:	90 a0       	ldd	r9, Z+32	; 0x20
     340:	c0 a0       	ldd	r12, Z+32	; 0x20
     342:	90 88       	ldd	r9, Z+16	; 0x10
     344:	80 80       	ld	r8, Z
     346:	80 80       	ld	r8, Z
     348:	80 80       	ld	r8, Z
     34a:	f8 88       	ldd	r15, Y+16	; 0x10
     34c:	d8 a8       	ldd	r13, Y+48	; 0x30
     34e:	88 88       	ldd	r8, Y+16	; 0x10
     350:	88 88       	ldd	r8, Y+16	; 0x10
     352:	88 88       	ldd	r8, Y+16	; 0x10
     354:	c8 a8       	ldd	r12, Y+48	; 0x30
     356:	98 88       	ldd	r9, Y+16	; 0x10
     358:	88 70       	andi	r24, 0x08	; 8
     35a:	88 88       	ldd	r8, Y+16	; 0x10
     35c:	88 88       	ldd	r8, Y+16	; 0x10
     35e:	88 70       	andi	r24, 0x08	; 8
     360:	f0 88       	ldd	r15, Z+16	; 0x10
     362:	88 f0       	brcs	.+34     	; 0x386 <__trampolines_end+0x176>
     364:	80 80       	ld	r8, Z
     366:	80 70       	andi	r24, 0x00	; 0
     368:	88 88       	ldd	r8, Y+16	; 0x10
     36a:	88 a8       	ldd	r8, Y+48	; 0x30
     36c:	90 68       	ori	r25, 0x80	; 128
     36e:	f0 88       	ldd	r15, Z+16	; 0x10
     370:	88 f0       	brcs	.+34     	; 0x394 <__trampolines_end+0x184>
     372:	a0 90 88 78 	lds	r10, 0x7888	; 0x807888 <__bss_end+0x55af>
     376:	80 80       	ld	r8, Z
     378:	70 08       	sbc	r7, r0
     37a:	08 f0       	brcs	.+2      	; 0x37e <__trampolines_end+0x16e>
     37c:	f8 20       	and	r15, r8
     37e:	20 20       	and	r2, r0
     380:	20 20       	and	r2, r0
     382:	20 88       	ldd	r2, Z+16	; 0x10
     384:	88 88       	ldd	r8, Y+16	; 0x10
     386:	88 88       	ldd	r8, Y+16	; 0x10
     388:	88 70       	andi	r24, 0x08	; 8
     38a:	88 88       	ldd	r8, Y+16	; 0x10
     38c:	88 88       	ldd	r8, Y+16	; 0x10
     38e:	88 50       	subi	r24, 0x08	; 8
     390:	20 88       	ldd	r2, Z+16	; 0x10
     392:	88 88       	ldd	r8, Y+16	; 0x10
     394:	a8 a8       	ldd	r10, Y+48	; 0x30
     396:	d8 88       	ldd	r13, Y+16	; 0x10
     398:	88 88       	ldd	r8, Y+16	; 0x10
     39a:	50 20       	and	r5, r0
     39c:	50 88       	ldd	r5, Z+16	; 0x10
     39e:	88 88       	ldd	r8, Y+16	; 0x10
     3a0:	88 50       	subi	r24, 0x08	; 8
     3a2:	20 20       	and	r2, r0
     3a4:	20 20       	and	r2, r0
     3a6:	f8 08       	sbc	r15, r8
     3a8:	10 20       	and	r1, r0
     3aa:	40 80       	ld	r4, Z
     3ac:	f8 38       	cpi	r31, 0x88	; 136
     3ae:	20 20       	and	r2, r0
     3b0:	20 20       	and	r2, r0
     3b2:	20 38       	cpi	r18, 0x80	; 128
     3b4:	00 80       	ld	r0, Z
     3b6:	40 20       	and	r4, r0
     3b8:	10 08       	sbc	r1, r0
     3ba:	00 e0       	ldi	r16, 0x00	; 0
     3bc:	20 20       	and	r2, r0
     3be:	20 20       	and	r2, r0
     3c0:	20 e0       	ldi	r18, 0x00	; 0
     3c2:	20 50       	subi	r18, 0x00	; 0
     3c4:	88 00       	.word	0x0088	; ????
	...
     3ce:	00 f8       	bld	r0, 0
     3d0:	40 20       	and	r4, r0
     3d2:	10 00       	.word	0x0010	; ????
     3d4:	00 00       	nop
     3d6:	00 00       	nop
     3d8:	00 70       	andi	r16, 0x00	; 0
     3da:	08 78       	andi	r16, 0x88	; 136
     3dc:	88 78       	andi	r24, 0x88	; 136
     3de:	80 80       	ld	r8, Z
     3e0:	b0 c8       	rjmp	.-3744   	; 0xfffff542 <__eeprom_end+0xff7ef542>
     3e2:	88 88       	ldd	r8, Y+16	; 0x10
     3e4:	f0 00       	.word	0x00f0	; ????
     3e6:	00 70       	andi	r16, 0x00	; 0
     3e8:	80 80       	ld	r8, Z
     3ea:	88 70       	andi	r24, 0x08	; 8
     3ec:	08 08       	sbc	r0, r8
     3ee:	68 98       	cbi	0x0d, 0	; 13
     3f0:	88 88       	ldd	r8, Y+16	; 0x10
     3f2:	78 00       	.word	0x0078	; ????
     3f4:	00 70       	andi	r16, 0x00	; 0
     3f6:	88 f8       	.word	0xf888	; ????
     3f8:	80 70       	andi	r24, 0x00	; 0
     3fa:	30 48       	sbci	r19, 0x80	; 128
     3fc:	40 e0       	ldi	r20, 0x00	; 0
     3fe:	40 40       	sbci	r20, 0x00	; 0
     400:	40 00       	.word	0x0040	; ????
     402:	00 78       	andi	r16, 0x80	; 128
     404:	88 78       	andi	r24, 0x88	; 136
     406:	08 30       	cpi	r16, 0x08	; 8
     408:	80 80       	ld	r8, Z
     40a:	b0 c8       	rjmp	.-3744   	; 0xfffff56c <__eeprom_end+0xff7ef56c>
     40c:	88 88       	ldd	r8, Y+16	; 0x10
     40e:	88 20       	and	r8, r8
     410:	00 60       	ori	r16, 0x00	; 0
     412:	20 20       	and	r2, r0
     414:	20 70       	andi	r18, 0x00	; 0
     416:	10 00       	.word	0x0010	; ????
     418:	30 10       	cpse	r3, r0
     41a:	10 90 60 40 	lds	r1, 0x4060	; 0x804060 <__bss_end+0x1d87>
     41e:	40 48       	sbci	r20, 0x80	; 128
     420:	50 60       	ori	r21, 0x00	; 0
     422:	50 48       	sbci	r21, 0x80	; 128
     424:	60 20       	and	r6, r0
     426:	20 20       	and	r2, r0
     428:	20 20       	and	r2, r0
     42a:	70 00       	.word	0x0070	; ????
     42c:	00 d0       	rcall	.+0      	; 0x42e <__LOCK_REGION_LENGTH__+0x2e>
     42e:	a8 a8       	ldd	r10, Y+48	; 0x30
     430:	88 88       	ldd	r8, Y+16	; 0x10
     432:	00 00       	nop
     434:	b0 c8       	rjmp	.-3744   	; 0xfffff596 <__eeprom_end+0xff7ef596>
     436:	88 88       	ldd	r8, Y+16	; 0x10
     438:	88 00       	.word	0x0088	; ????
     43a:	00 70       	andi	r16, 0x00	; 0
     43c:	88 88       	ldd	r8, Y+16	; 0x10
     43e:	88 70       	andi	r24, 0x08	; 8
     440:	00 00       	nop
     442:	f0 88       	ldd	r15, Z+16	; 0x10
     444:	f0 80       	ld	r15, Z
     446:	80 00       	.word	0x0080	; ????
     448:	00 68       	ori	r16, 0x80	; 128
     44a:	98 78       	andi	r25, 0x88	; 136
     44c:	08 08       	sbc	r0, r8
     44e:	00 00       	nop
     450:	b0 c8       	rjmp	.-3744   	; 0xfffff5b2 <__eeprom_end+0xff7ef5b2>
     452:	80 80       	ld	r8, Z
     454:	80 00       	.word	0x0080	; ????
     456:	00 70       	andi	r16, 0x00	; 0
     458:	80 70       	andi	r24, 0x00	; 0
     45a:	08 f0       	brcs	.+2      	; 0x45e <__LOCK_REGION_LENGTH__+0x5e>
     45c:	40 40       	sbci	r20, 0x00	; 0
     45e:	e0 40       	sbci	r30, 0x00	; 0
     460:	40 48       	sbci	r20, 0x80	; 128
     462:	30 00       	.word	0x0030	; ????
     464:	00 88       	ldd	r0, Z+16	; 0x10
     466:	88 88       	ldd	r8, Y+16	; 0x10
     468:	98 68       	ori	r25, 0x88	; 136
     46a:	00 00       	nop
     46c:	88 88       	ldd	r8, Y+16	; 0x10
     46e:	88 50       	subi	r24, 0x08	; 8
     470:	20 00       	.word	0x0020	; ????
     472:	00 88       	ldd	r0, Z+16	; 0x10
     474:	88 a8       	ldd	r8, Y+48	; 0x30
     476:	a8 50       	subi	r26, 0x08	; 8
     478:	00 00       	nop
     47a:	88 50       	subi	r24, 0x08	; 8
     47c:	20 50       	subi	r18, 0x00	; 0
     47e:	88 00       	.word	0x0088	; ????
     480:	00 88       	ldd	r0, Z+16	; 0x10
     482:	88 78       	andi	r24, 0x88	; 136
     484:	08 70       	andi	r16, 0x08	; 8
     486:	00 00       	nop
     488:	f8 10       	cpse	r15, r8
     48a:	20 40       	sbci	r18, 0x00	; 0
     48c:	f8 10       	cpse	r15, r8
     48e:	20 20       	and	r2, r0
     490:	40 20       	and	r4, r0
     492:	20 10       	cpse	r2, r0
     494:	20 20       	and	r2, r0
     496:	20 20       	and	r2, r0
     498:	20 20       	and	r2, r0
     49a:	20 40       	sbci	r18, 0x00	; 0
     49c:	20 20       	and	r2, r0
     49e:	10 20       	and	r1, r0
     4a0:	20 40       	sbci	r18, 0x00	; 0

000004a2 <__ctors_end>:
     4a2:	11 24       	eor	r1, r1
     4a4:	1f be       	out	0x3f, r1	; 63
     4a6:	cf ef       	ldi	r28, 0xFF	; 255
     4a8:	cd bf       	out	0x3d, r28	; 61
     4aa:	df e5       	ldi	r29, 0x5F	; 95
     4ac:	de bf       	out	0x3e, r29	; 62
     4ae:	00 e0       	ldi	r16, 0x00	; 0
     4b0:	0c bf       	out	0x3c, r16	; 60

000004b2 <__do_copy_data>:
     4b2:	10 e2       	ldi	r17, 0x20	; 32
     4b4:	a0 e0       	ldi	r26, 0x00	; 0
     4b6:	b0 e2       	ldi	r27, 0x20	; 32
     4b8:	ee e8       	ldi	r30, 0x8E	; 142
     4ba:	f6 e3       	ldi	r31, 0x36	; 54
     4bc:	00 e0       	ldi	r16, 0x00	; 0
     4be:	0b bf       	out	0x3b, r16	; 59
     4c0:	02 c0       	rjmp	.+4      	; 0x4c6 <__do_copy_data+0x14>
     4c2:	07 90       	elpm	r0, Z+
     4c4:	0d 92       	st	X+, r0
     4c6:	a6 35       	cpi	r26, 0x56	; 86
     4c8:	b1 07       	cpc	r27, r17
     4ca:	d9 f7       	brne	.-10     	; 0x4c2 <__do_copy_data+0x10>

000004cc <__do_clear_bss>:
     4cc:	22 e2       	ldi	r18, 0x22	; 34
     4ce:	a6 e5       	ldi	r26, 0x56	; 86
     4d0:	b0 e2       	ldi	r27, 0x20	; 32
     4d2:	01 c0       	rjmp	.+2      	; 0x4d6 <.do_clear_bss_start>

000004d4 <.do_clear_bss_loop>:
     4d4:	1d 92       	st	X+, r1

000004d6 <.do_clear_bss_start>:
     4d6:	a9 3d       	cpi	r26, 0xD9	; 217
     4d8:	b2 07       	cpc	r27, r18
     4da:	e1 f7       	brne	.-8      	; 0x4d4 <.do_clear_bss_loop>
     4dc:	0e 94 bd 16 	call	0x2d7a	; 0x2d7a <main>
     4e0:	0c 94 45 1b 	jmp	0x368a	; 0x368a <_exit>

000004e4 <__bad_interrupt>:
     4e4:	8d cd       	rjmp	.-1254   	; 0x0 <__vectors>

000004e6 <__portable_avr_delay_cycles>:
 *
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
     4e6:	04 c0       	rjmp	.+8      	; 0x4f0 <__portable_avr_delay_cycles+0xa>
	while (n) {
		barrier();
		n--;
     4e8:	61 50       	subi	r22, 0x01	; 1
     4ea:	71 09       	sbc	r23, r1
     4ec:	81 09       	sbc	r24, r1
     4ee:	91 09       	sbc	r25, r1
 * @{
 */
__always_optimize
static inline void __portable_avr_delay_cycles(unsigned long n)
{
	while (n) {
     4f0:	61 15       	cp	r22, r1
     4f2:	71 05       	cpc	r23, r1
     4f4:	81 05       	cpc	r24, r1
     4f6:	91 05       	cpc	r25, r1
     4f8:	b9 f7       	brne	.-18     	; 0x4e8 <__portable_avr_delay_cycles+0x2>
     4fa:	08 95       	ret

000004fc <st7565r_init>:
 * Call this function to initialize the hardware interface and the LCD
 * controller. When initialization is done the display is turned on and ready
 * to receive data.
 */
void st7565r_init(void)
{
     4fc:	bf 92       	push	r11
     4fe:	cf 92       	push	r12
     500:	df 92       	push	r13
     502:	ef 92       	push	r14
     504:	ff 92       	push	r15
     506:	0f 93       	push	r16
     508:	1f 93       	push	r17
     50a:	cf 93       	push	r28
     50c:	df 93       	push	r29
     50e:	1f 92       	push	r1
     510:	cd b7       	in	r28, 0x3d	; 61
     512:	de b7       	in	r29, 0x3e	; 62
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     514:	00 e0       	ldi	r16, 0x00	; 0
     516:	16 e0       	ldi	r17, 0x06	; 6
     518:	68 94       	set
     51a:	ff 24       	eor	r15, r15
     51c:	f3 f8       	bld	r15, 3
     51e:	f8 01       	movw	r30, r16
     520:	f6 82       	std	Z+6, r15	; 0x06
 * function, this command will control the RST pin.
 */
static inline void st7565r_hard_reset(void)
{
	ioport_set_pin_low(ST7565R_RESET_PIN);
	delay_us(10);
     522:	64 e0       	ldi	r22, 0x04	; 4
     524:	70 e0       	ldi	r23, 0x00	; 0
     526:	80 e0       	ldi	r24, 0x00	; 0
     528:	90 e0       	ldi	r25, 0x00	; 0
     52a:	dd df       	rcall	.-70     	; 0x4e6 <__portable_avr_delay_cycles>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     52c:	f8 01       	movw	r30, r16
     52e:	f5 82       	std	Z+5, r15	; 0x05
	ioport_set_pin_high(ST7565R_RESET_PIN);
	delay_us(10);
     530:	64 e0       	ldi	r22, 0x04	; 4
     532:	70 e0       	ldi	r23, 0x00	; 0
     534:	80 e0       	ldi	r24, 0x00	; 0
     536:	90 e0       	ldi	r25, 0x00	; 0
     538:	d6 df       	rcall	.-84     	; 0x4e6 <__portable_avr_delay_cycles>
	spi_flags_t spi_flags = SPI_MODE_3;
	board_spi_select_id_t spi_select_id = 0;
#endif

#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {
     53a:	0f 2e       	mov	r0, r31
     53c:	fb e2       	ldi	r31, 0x2B	; 43
     53e:	bf 2e       	mov	r11, r31
     540:	f0 2d       	mov	r31, r0
     542:	b9 82       	std	Y+1, r11	; 0x01
		.id = ST7565R_CS_PIN,
	};
	usart_spi_init(ST7565R_USART_SPI);
     544:	80 ea       	ldi	r24, 0xA0	; 160
     546:	99 e0       	ldi	r25, 0x09	; 9
     548:	0e 94 e8 12 	call	0x25d0	; 0x25d0 <usart_spi_init>
	usart_spi_setup_device(ST7565R_USART_SPI, &device, spi_flags,
     54c:	c1 2c       	mov	r12, r1
     54e:	d1 2c       	mov	r13, r1
     550:	76 01       	movw	r14, r12
     552:	00 e4       	ldi	r16, 0x40	; 64
     554:	12 e4       	ldi	r17, 0x42	; 66
     556:	2f e0       	ldi	r18, 0x0F	; 15
     558:	30 e0       	ldi	r19, 0x00	; 0
     55a:	43 e0       	ldi	r20, 0x03	; 3
     55c:	be 01       	movw	r22, r28
     55e:	6f 5f       	subi	r22, 0xFF	; 255
     560:	7f 4f       	sbci	r23, 0xFF	; 255
     562:	80 ea       	ldi	r24, 0xA0	; 160
     564:	99 e0       	ldi	r25, 0x09	; 9
     566:	0e 94 17 13 	call	0x262e	; 0x262e <usart_spi_setup_device>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     56a:	00 e6       	ldi	r16, 0x60	; 96
     56c:	16 e0       	ldi	r17, 0x06	; 6
     56e:	ff 24       	eor	r15, r15
     570:	f3 94       	inc	r15
     572:	f8 01       	movw	r30, r16
     574:	f6 82       	std	Z+6, r15	; 0x06
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     576:	b9 82       	std	Y+1, r11	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     578:	be 01       	movw	r22, r28
     57a:	6f 5f       	subi	r22, 0xFF	; 255
     57c:	7f 4f       	sbci	r23, 0xFF	; 255
     57e:	80 ea       	ldi	r24, 0xA0	; 160
     580:	99 e0       	ldi	r25, 0x09	; 9
     582:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     586:	f8 01       	movw	r30, r16
     588:	f6 82       	std	Z+6, r15	; 0x06
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     58a:	e0 ea       	ldi	r30, 0xA0	; 160
     58c:	f9 e0       	ldi	r31, 0x09	; 9
     58e:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     590:	85 ff       	sbrs	r24, 5
     592:	fd cf       	rjmp	.-6      	; 0x58e <st7565r_init+0x92>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     594:	80 ea       	ldi	r24, 0xA0	; 160
     596:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     59a:	e0 ea       	ldi	r30, 0xA0	; 160
     59c:	f9 e0       	ldi	r31, 0x09	; 9
     59e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5a0:	86 ff       	sbrs	r24, 6
     5a2:	fd cf       	rjmp	.-6      	; 0x59e <st7565r_init+0xa2>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5a4:	e0 ea       	ldi	r30, 0xA0	; 160
     5a6:	f9 e0       	ldi	r31, 0x09	; 9
     5a8:	80 e4       	ldi	r24, 0x40	; 64
     5aa:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5ac:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5ae:	be 01       	movw	r22, r28
     5b0:	6f 5f       	subi	r22, 0xFF	; 255
     5b2:	7f 4f       	sbci	r23, 0xFF	; 255
     5b4:	80 ea       	ldi	r24, 0xA0	; 160
     5b6:	99 e0       	ldi	r25, 0x09	; 9
     5b8:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     5bc:	8b e2       	ldi	r24, 0x2B	; 43
     5be:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     5c0:	be 01       	movw	r22, r28
     5c2:	6f 5f       	subi	r22, 0xFF	; 255
     5c4:	7f 4f       	sbci	r23, 0xFF	; 255
     5c6:	80 ea       	ldi	r24, 0xA0	; 160
     5c8:	99 e0       	ldi	r25, 0x09	; 9
     5ca:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     5ce:	81 e0       	ldi	r24, 0x01	; 1
     5d0:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     5d4:	e0 ea       	ldi	r30, 0xA0	; 160
     5d6:	f9 e0       	ldi	r31, 0x09	; 9
     5d8:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     5da:	85 ff       	sbrs	r24, 5
     5dc:	fd cf       	rjmp	.-6      	; 0x5d8 <st7565r_init+0xdc>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     5de:	86 ea       	ldi	r24, 0xA6	; 166
     5e0:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     5e4:	e0 ea       	ldi	r30, 0xA0	; 160
     5e6:	f9 e0       	ldi	r31, 0x09	; 9
     5e8:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     5ea:	86 ff       	sbrs	r24, 6
     5ec:	fd cf       	rjmp	.-6      	; 0x5e8 <st7565r_init+0xec>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     5ee:	e0 ea       	ldi	r30, 0xA0	; 160
     5f0:	f9 e0       	ldi	r31, 0x09	; 9
     5f2:	80 e4       	ldi	r24, 0x40	; 64
     5f4:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     5f6:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     5f8:	be 01       	movw	r22, r28
     5fa:	6f 5f       	subi	r22, 0xFF	; 255
     5fc:	7f 4f       	sbci	r23, 0xFF	; 255
     5fe:	80 ea       	ldi	r24, 0xA0	; 160
     600:	99 e0       	ldi	r25, 0x09	; 9
     602:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     606:	8b e2       	ldi	r24, 0x2B	; 43
     608:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     60a:	be 01       	movw	r22, r28
     60c:	6f 5f       	subi	r22, 0xFF	; 255
     60e:	7f 4f       	sbci	r23, 0xFF	; 255
     610:	80 ea       	ldi	r24, 0xA0	; 160
     612:	99 e0       	ldi	r25, 0x09	; 9
     614:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     618:	81 e0       	ldi	r24, 0x01	; 1
     61a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     61e:	e0 ea       	ldi	r30, 0xA0	; 160
     620:	f9 e0       	ldi	r31, 0x09	; 9
     622:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     624:	85 ff       	sbrs	r24, 5
     626:	fd cf       	rjmp	.-6      	; 0x622 <st7565r_init+0x126>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     628:	88 ec       	ldi	r24, 0xC8	; 200
     62a:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     62e:	e0 ea       	ldi	r30, 0xA0	; 160
     630:	f9 e0       	ldi	r31, 0x09	; 9
     632:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     634:	86 ff       	sbrs	r24, 6
     636:	fd cf       	rjmp	.-6      	; 0x632 <st7565r_init+0x136>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     638:	e0 ea       	ldi	r30, 0xA0	; 160
     63a:	f9 e0       	ldi	r31, 0x09	; 9
     63c:	80 e4       	ldi	r24, 0x40	; 64
     63e:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     640:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     642:	be 01       	movw	r22, r28
     644:	6f 5f       	subi	r22, 0xFF	; 255
     646:	7f 4f       	sbci	r23, 0xFF	; 255
     648:	80 ea       	ldi	r24, 0xA0	; 160
     64a:	99 e0       	ldi	r25, 0x09	; 9
     64c:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     650:	8b e2       	ldi	r24, 0x2B	; 43
     652:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     654:	be 01       	movw	r22, r28
     656:	6f 5f       	subi	r22, 0xFF	; 255
     658:	7f 4f       	sbci	r23, 0xFF	; 255
     65a:	80 ea       	ldi	r24, 0xA0	; 160
     65c:	99 e0       	ldi	r25, 0x09	; 9
     65e:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     662:	81 e0       	ldi	r24, 0x01	; 1
     664:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     668:	e0 ea       	ldi	r30, 0xA0	; 160
     66a:	f9 e0       	ldi	r31, 0x09	; 9
     66c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     66e:	85 ff       	sbrs	r24, 5
     670:	fd cf       	rjmp	.-6      	; 0x66c <st7565r_init+0x170>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     672:	82 ea       	ldi	r24, 0xA2	; 162
     674:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     678:	e0 ea       	ldi	r30, 0xA0	; 160
     67a:	f9 e0       	ldi	r31, 0x09	; 9
     67c:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     67e:	86 ff       	sbrs	r24, 6
     680:	fd cf       	rjmp	.-6      	; 0x67c <st7565r_init+0x180>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     682:	e0 ea       	ldi	r30, 0xA0	; 160
     684:	f9 e0       	ldi	r31, 0x09	; 9
     686:	80 e4       	ldi	r24, 0x40	; 64
     688:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     68a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     68c:	be 01       	movw	r22, r28
     68e:	6f 5f       	subi	r22, 0xFF	; 255
     690:	7f 4f       	sbci	r23, 0xFF	; 255
     692:	80 ea       	ldi	r24, 0xA0	; 160
     694:	99 e0       	ldi	r25, 0x09	; 9
     696:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     69a:	8b e2       	ldi	r24, 0x2B	; 43
     69c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     69e:	be 01       	movw	r22, r28
     6a0:	6f 5f       	subi	r22, 0xFF	; 255
     6a2:	7f 4f       	sbci	r23, 0xFF	; 255
     6a4:	80 ea       	ldi	r24, 0xA0	; 160
     6a6:	99 e0       	ldi	r25, 0x09	; 9
     6a8:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     6ac:	81 e0       	ldi	r24, 0x01	; 1
     6ae:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6b2:	e0 ea       	ldi	r30, 0xA0	; 160
     6b4:	f9 e0       	ldi	r31, 0x09	; 9
     6b6:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     6b8:	85 ff       	sbrs	r24, 5
     6ba:	fd cf       	rjmp	.-6      	; 0x6b6 <st7565r_init+0x1ba>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     6bc:	8f e2       	ldi	r24, 0x2F	; 47
     6be:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     6c2:	e0 ea       	ldi	r30, 0xA0	; 160
     6c4:	f9 e0       	ldi	r31, 0x09	; 9
     6c6:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     6c8:	86 ff       	sbrs	r24, 6
     6ca:	fd cf       	rjmp	.-6      	; 0x6c6 <st7565r_init+0x1ca>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     6cc:	e0 ea       	ldi	r30, 0xA0	; 160
     6ce:	f9 e0       	ldi	r31, 0x09	; 9
     6d0:	80 e4       	ldi	r24, 0x40	; 64
     6d2:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     6d4:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     6d6:	be 01       	movw	r22, r28
     6d8:	6f 5f       	subi	r22, 0xFF	; 255
     6da:	7f 4f       	sbci	r23, 0xFF	; 255
     6dc:	80 ea       	ldi	r24, 0xA0	; 160
     6de:	99 e0       	ldi	r25, 0x09	; 9
     6e0:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     6e4:	8b e2       	ldi	r24, 0x2B	; 43
     6e6:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     6e8:	be 01       	movw	r22, r28
     6ea:	6f 5f       	subi	r22, 0xFF	; 255
     6ec:	7f 4f       	sbci	r23, 0xFF	; 255
     6ee:	80 ea       	ldi	r24, 0xA0	; 160
     6f0:	99 e0       	ldi	r25, 0x09	; 9
     6f2:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     6f6:	81 e0       	ldi	r24, 0x01	; 1
     6f8:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     6fc:	e0 ea       	ldi	r30, 0xA0	; 160
     6fe:	f9 e0       	ldi	r31, 0x09	; 9
     700:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     702:	85 ff       	sbrs	r24, 5
     704:	fd cf       	rjmp	.-6      	; 0x700 <st7565r_init+0x204>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     706:	88 ef       	ldi	r24, 0xF8	; 248
     708:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     70c:	e0 ea       	ldi	r30, 0xA0	; 160
     70e:	f9 e0       	ldi	r31, 0x09	; 9
     710:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     712:	86 ff       	sbrs	r24, 6
     714:	fd cf       	rjmp	.-6      	; 0x710 <st7565r_init+0x214>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     716:	e0 ea       	ldi	r30, 0xA0	; 160
     718:	f9 e0       	ldi	r31, 0x09	; 9
     71a:	80 e4       	ldi	r24, 0x40	; 64
     71c:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     71e:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     720:	be 01       	movw	r22, r28
     722:	6f 5f       	subi	r22, 0xFF	; 255
     724:	7f 4f       	sbci	r23, 0xFF	; 255
     726:	80 ea       	ldi	r24, 0xA0	; 160
     728:	99 e0       	ldi	r25, 0x09	; 9
     72a:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     72e:	8b e2       	ldi	r24, 0x2B	; 43
     730:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     732:	be 01       	movw	r22, r28
     734:	6f 5f       	subi	r22, 0xFF	; 255
     736:	7f 4f       	sbci	r23, 0xFF	; 255
     738:	80 ea       	ldi	r24, 0xA0	; 160
     73a:	99 e0       	ldi	r25, 0x09	; 9
     73c:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     740:	81 e0       	ldi	r24, 0x01	; 1
     742:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     746:	e0 ea       	ldi	r30, 0xA0	; 160
     748:	f9 e0       	ldi	r31, 0x09	; 9
     74a:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     74c:	85 ff       	sbrs	r24, 5
     74e:	fd cf       	rjmp	.-6      	; 0x74a <st7565r_init+0x24e>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     750:	10 92 a0 09 	sts	0x09A0, r1	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     754:	e0 ea       	ldi	r30, 0xA0	; 160
     756:	f9 e0       	ldi	r31, 0x09	; 9
     758:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     75a:	86 ff       	sbrs	r24, 6
     75c:	fd cf       	rjmp	.-6      	; 0x758 <st7565r_init+0x25c>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     75e:	e0 ea       	ldi	r30, 0xA0	; 160
     760:	f9 e0       	ldi	r31, 0x09	; 9
     762:	80 e4       	ldi	r24, 0x40	; 64
     764:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     766:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     768:	be 01       	movw	r22, r28
     76a:	6f 5f       	subi	r22, 0xFF	; 255
     76c:	7f 4f       	sbci	r23, 0xFF	; 255
     76e:	80 ea       	ldi	r24, 0xA0	; 160
     770:	99 e0       	ldi	r25, 0x09	; 9
     772:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     776:	8b e2       	ldi	r24, 0x2B	; 43
     778:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     77a:	be 01       	movw	r22, r28
     77c:	6f 5f       	subi	r22, 0xFF	; 255
     77e:	7f 4f       	sbci	r23, 0xFF	; 255
     780:	80 ea       	ldi	r24, 0xA0	; 160
     782:	99 e0       	ldi	r25, 0x09	; 9
     784:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     788:	81 e0       	ldi	r24, 0x01	; 1
     78a:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     78e:	e0 ea       	ldi	r30, 0xA0	; 160
     790:	f9 e0       	ldi	r31, 0x09	; 9
     792:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     794:	85 ff       	sbrs	r24, 5
     796:	fd cf       	rjmp	.-6      	; 0x792 <st7565r_init+0x296>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     798:	81 e2       	ldi	r24, 0x21	; 33
     79a:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     79e:	e0 ea       	ldi	r30, 0xA0	; 160
     7a0:	f9 e0       	ldi	r31, 0x09	; 9
     7a2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7a4:	86 ff       	sbrs	r24, 6
     7a6:	fd cf       	rjmp	.-6      	; 0x7a2 <st7565r_init+0x2a6>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7a8:	e0 ea       	ldi	r30, 0xA0	; 160
     7aa:	f9 e0       	ldi	r31, 0x09	; 9
     7ac:	80 e4       	ldi	r24, 0x40	; 64
     7ae:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7b0:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7b2:	be 01       	movw	r22, r28
     7b4:	6f 5f       	subi	r22, 0xFF	; 255
     7b6:	7f 4f       	sbci	r23, 0xFF	; 255
     7b8:	80 ea       	ldi	r24, 0xA0	; 160
     7ba:	99 e0       	ldi	r25, 0x09	; 9
     7bc:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     7c0:	8b e2       	ldi	r24, 0x2B	; 43
     7c2:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     7c4:	be 01       	movw	r22, r28
     7c6:	6f 5f       	subi	r22, 0xFF	; 255
     7c8:	7f 4f       	sbci	r23, 0xFF	; 255
     7ca:	80 ea       	ldi	r24, 0xA0	; 160
     7cc:	99 e0       	ldi	r25, 0x09	; 9
     7ce:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     7d2:	81 e0       	ldi	r24, 0x01	; 1
     7d4:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     7d8:	e0 ea       	ldi	r30, 0xA0	; 160
     7da:	f9 e0       	ldi	r31, 0x09	; 9
     7dc:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     7de:	85 ff       	sbrs	r24, 5
     7e0:	fd cf       	rjmp	.-6      	; 0x7dc <st7565r_init+0x2e0>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     7e2:	81 e8       	ldi	r24, 0x81	; 129
     7e4:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     7e8:	e0 ea       	ldi	r30, 0xA0	; 160
     7ea:	f9 e0       	ldi	r31, 0x09	; 9
     7ec:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     7ee:	86 ff       	sbrs	r24, 6
     7f0:	fd cf       	rjmp	.-6      	; 0x7ec <st7565r_init+0x2f0>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     7f2:	e0 ea       	ldi	r30, 0xA0	; 160
     7f4:	f9 e0       	ldi	r31, 0x09	; 9
     7f6:	80 e4       	ldi	r24, 0x40	; 64
     7f8:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     7fa:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     7fc:	be 01       	movw	r22, r28
     7fe:	6f 5f       	subi	r22, 0xFF	; 255
     800:	7f 4f       	sbci	r23, 0xFF	; 255
     802:	80 ea       	ldi	r24, 0xA0	; 160
     804:	99 e0       	ldi	r25, 0x09	; 9
     806:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     80a:	8b e2       	ldi	r24, 0x2B	; 43
     80c:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     80e:	be 01       	movw	r22, r28
     810:	6f 5f       	subi	r22, 0xFF	; 255
     812:	7f 4f       	sbci	r23, 0xFF	; 255
     814:	80 ea       	ldi	r24, 0xA0	; 160
     816:	99 e0       	ldi	r25, 0x09	; 9
     818:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     81c:	81 e0       	ldi	r24, 0x01	; 1
     81e:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     822:	e0 ea       	ldi	r30, 0xA0	; 160
     824:	f9 e0       	ldi	r31, 0x09	; 9
     826:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     828:	85 ff       	sbrs	r24, 5
     82a:	fd cf       	rjmp	.-6      	; 0x826 <st7565r_init+0x32a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     82c:	81 e2       	ldi	r24, 0x21	; 33
     82e:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     832:	e0 ea       	ldi	r30, 0xA0	; 160
     834:	f9 e0       	ldi	r31, 0x09	; 9
     836:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     838:	86 ff       	sbrs	r24, 6
     83a:	fd cf       	rjmp	.-6      	; 0x836 <st7565r_init+0x33a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     83c:	e0 ea       	ldi	r30, 0xA0	; 160
     83e:	f9 e0       	ldi	r31, 0x09	; 9
     840:	80 e4       	ldi	r24, 0x40	; 64
     842:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     844:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     846:	be 01       	movw	r22, r28
     848:	6f 5f       	subi	r22, 0xFF	; 255
     84a:	7f 4f       	sbci	r23, 0xFF	; 255
     84c:	80 ea       	ldi	r24, 0xA0	; 160
     84e:	99 e0       	ldi	r25, 0x09	; 9
     850:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     854:	8b e2       	ldi	r24, 0x2B	; 43
     856:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     858:	be 01       	movw	r22, r28
     85a:	6f 5f       	subi	r22, 0xFF	; 255
     85c:	7f 4f       	sbci	r23, 0xFF	; 255
     85e:	80 ea       	ldi	r24, 0xA0	; 160
     860:	99 e0       	ldi	r25, 0x09	; 9
     862:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     866:	81 e0       	ldi	r24, 0x01	; 1
     868:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     86c:	e0 ea       	ldi	r30, 0xA0	; 160
     86e:	f9 e0       	ldi	r31, 0x09	; 9
     870:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     872:	85 ff       	sbrs	r24, 5
     874:	fd cf       	rjmp	.-6      	; 0x870 <st7565r_init+0x374>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     876:	8f ea       	ldi	r24, 0xAF	; 175
     878:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     87c:	e0 ea       	ldi	r30, 0xA0	; 160
     87e:	f9 e0       	ldi	r31, 0x09	; 9
     880:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     882:	86 ff       	sbrs	r24, 6
     884:	fd cf       	rjmp	.-6      	; 0x880 <st7565r_init+0x384>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     886:	e0 ea       	ldi	r30, 0xA0	; 160
     888:	f9 e0       	ldi	r31, 0x09	; 9
     88a:	80 e4       	ldi	r24, 0x40	; 64
     88c:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     88e:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     890:	be 01       	movw	r22, r28
     892:	6f 5f       	subi	r22, 0xFF	; 255
     894:	7f 4f       	sbci	r23, 0xFF	; 255
     896:	80 ea       	ldi	r24, 0xA0	; 160
     898:	99 e0       	ldi	r25, 0x09	; 9
     89a:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>
	is set to the defined min*/
	st7565r_set_contrast(ST7565R_DISPLAY_CONTRAST_MIN);

	// Turn on the display
	st7565r_display_on();
}
     89e:	0f 90       	pop	r0
     8a0:	df 91       	pop	r29
     8a2:	cf 91       	pop	r28
     8a4:	1f 91       	pop	r17
     8a6:	0f 91       	pop	r16
     8a8:	ff 90       	pop	r15
     8aa:	ef 90       	pop	r14
     8ac:	df 90       	pop	r13
     8ae:	cf 90       	pop	r12
     8b0:	bf 90       	pop	r11
     8b2:	08 95       	ret

000008b4 <gfx_mono_st7565r_put_byte>:
	gfx_mono_st7565r_put_byte(0, 0, 0xFF);
\endcode
 */
void gfx_mono_st7565r_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
     8b4:	ff 92       	push	r15
     8b6:	0f 93       	push	r16
     8b8:	1f 93       	push	r17
     8ba:	cf 93       	push	r28
     8bc:	df 93       	push	r29
     8be:	1f 92       	push	r1
     8c0:	cd b7       	in	r28, 0x3d	; 61
     8c2:	de b7       	in	r29, 0x3e	; 62
     8c4:	08 2f       	mov	r16, r24
     8c6:	f6 2e       	mov	r15, r22
     8c8:	14 2f       	mov	r17, r20
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_framebuffer_put_byte(page, column, data);
     8ca:	0e 94 63 13 	call	0x26c6	; 0x26c6 <gfx_mono_framebuffer_put_byte>
 */
static inline void st7565r_set_page_address(uint8_t address)
{
	// Make sure that the address is 4 bits (only 8 pages)
	address &= 0x0F;
	st7565r_write_command(ST7565R_CMD_PAGE_ADDRESS_SET(address));
     8ce:	0f 70       	andi	r16, 0x0F	; 15
     8d0:	00 6b       	ori	r16, 0xB0	; 176
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     8d2:	8b e2       	ldi	r24, 0x2B	; 43
     8d4:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     8d6:	be 01       	movw	r22, r28
     8d8:	6f 5f       	subi	r22, 0xFF	; 255
     8da:	7f 4f       	sbci	r23, 0xFF	; 255
     8dc:	80 ea       	ldi	r24, 0xA0	; 160
     8de:	99 e0       	ldi	r25, 0x09	; 9
     8e0:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     8e4:	81 e0       	ldi	r24, 0x01	; 1
     8e6:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     8ea:	e0 ea       	ldi	r30, 0xA0	; 160
     8ec:	f9 e0       	ldi	r31, 0x09	; 9
     8ee:	91 81       	ldd	r25, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     8f0:	95 ff       	sbrs	r25, 5
     8f2:	fd cf       	rjmp	.-6      	; 0x8ee <gfx_mono_st7565r_put_byte+0x3a>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     8f4:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     8f8:	e0 ea       	ldi	r30, 0xA0	; 160
     8fa:	f9 e0       	ldi	r31, 0x09	; 9
     8fc:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     8fe:	86 ff       	sbrs	r24, 6
     900:	fd cf       	rjmp	.-6      	; 0x8fc <gfx_mono_st7565r_put_byte+0x48>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     902:	e0 ea       	ldi	r30, 0xA0	; 160
     904:	f9 e0       	ldi	r31, 0x09	; 9
     906:	80 e4       	ldi	r24, 0x40	; 64
     908:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     90a:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     90c:	be 01       	movw	r22, r28
     90e:	6f 5f       	subi	r22, 0xFF	; 255
     910:	7f 4f       	sbci	r23, 0xFF	; 255
     912:	80 ea       	ldi	r24, 0xA0	; 160
     914:	99 e0       	ldi	r25, 0x09	; 9
     916:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>
 */
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
     91a:	0f 2d       	mov	r16, r15
     91c:	0f 77       	andi	r16, 0x7F	; 127
     91e:	02 95       	swap	r16
     920:	0f 70       	andi	r16, 0x0F	; 15
     922:	00 61       	ori	r16, 0x10	; 16
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     924:	8b e2       	ldi	r24, 0x2B	; 43
     926:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     928:	be 01       	movw	r22, r28
     92a:	6f 5f       	subi	r22, 0xFF	; 255
     92c:	7f 4f       	sbci	r23, 0xFF	; 255
     92e:	80 ea       	ldi	r24, 0xA0	; 160
     930:	99 e0       	ldi	r25, 0x09	; 9
     932:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     936:	81 e0       	ldi	r24, 0x01	; 1
     938:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     93c:	e0 ea       	ldi	r30, 0xA0	; 160
     93e:	f9 e0       	ldi	r31, 0x09	; 9
     940:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     942:	85 ff       	sbrs	r24, 5
     944:	fd cf       	rjmp	.-6      	; 0x940 <gfx_mono_st7565r_put_byte+0x8c>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     946:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     94a:	e0 ea       	ldi	r30, 0xA0	; 160
     94c:	f9 e0       	ldi	r31, 0x09	; 9
     94e:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     950:	86 ff       	sbrs	r24, 6
     952:	fd cf       	rjmp	.-6      	; 0x94e <gfx_mono_st7565r_put_byte+0x9a>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     954:	e0 ea       	ldi	r30, 0xA0	; 160
     956:	f9 e0       	ldi	r31, 0x09	; 9
     958:	80 e4       	ldi	r24, 0x40	; 64
     95a:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     95c:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     95e:	be 01       	movw	r22, r28
     960:	6f 5f       	subi	r22, 0xFF	; 255
     962:	7f 4f       	sbci	r23, 0xFF	; 255
     964:	80 ea       	ldi	r24, 0xA0	; 160
     966:	99 e0       	ldi	r25, 0x09	; 9
     968:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>
static inline void st7565r_set_column_address(uint8_t address)
{
	// Make sure the address is 7 bits
	address &= 0x7F;
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_MSB(address >> 4));
	st7565r_write_command(ST7565R_CMD_COLUMN_ADDRESS_SET_LSB(address & 0x0F));
     96c:	0f 2d       	mov	r16, r15
     96e:	0f 70       	andi	r16, 0x0F	; 15
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     970:	8b e2       	ldi	r24, 0x2B	; 43
     972:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     974:	be 01       	movw	r22, r28
     976:	6f 5f       	subi	r22, 0xFF	; 255
     978:	7f 4f       	sbci	r23, 0xFF	; 255
     97a:	80 ea       	ldi	r24, 0xA0	; 160
     97c:	99 e0       	ldi	r25, 0x09	; 9
     97e:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     982:	81 e0       	ldi	r24, 0x01	; 1
     984:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     988:	e0 ea       	ldi	r30, 0xA0	; 160
     98a:	f9 e0       	ldi	r31, 0x09	; 9
     98c:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     98e:	85 ff       	sbrs	r24, 5
     990:	fd cf       	rjmp	.-6      	; 0x98c <gfx_mono_st7565r_put_byte+0xd8>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     992:	00 93 a0 09 	sts	0x09A0, r16	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     996:	e0 ea       	ldi	r30, 0xA0	; 160
     998:	f9 e0       	ldi	r31, 0x09	; 9
     99a:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     99c:	86 ff       	sbrs	r24, 6
     99e:	fd cf       	rjmp	.-6      	; 0x99a <gfx_mono_st7565r_put_byte+0xe6>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9a0:	e0 ea       	ldi	r30, 0xA0	; 160
     9a2:	f9 e0       	ldi	r31, 0x09	; 9
     9a4:	80 e4       	ldi	r24, 0x40	; 64
     9a6:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9a8:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9aa:	be 01       	movw	r22, r28
     9ac:	6f 5f       	subi	r22, 0xFF	; 255
     9ae:	7f 4f       	sbci	r23, 0xFF	; 255
     9b0:	80 ea       	ldi	r24, 0xA0	; 160
     9b2:	99 e0       	ldi	r25, 0x09	; 9
     9b4:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>
 * \param data the data to write
 */
static inline void st7565r_write_data(uint8_t data)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     9b8:	8b e2       	ldi	r24, 0x2B	; 43
     9ba:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     9bc:	be 01       	movw	r22, r28
     9be:	6f 5f       	subi	r22, 0xFF	; 255
     9c0:	7f 4f       	sbci	r23, 0xFF	; 255
     9c2:	80 ea       	ldi	r24, 0xA0	; 160
     9c4:	99 e0       	ldi	r25, 0x09	; 9
     9c6:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     9ca:	81 e0       	ldi	r24, 0x01	; 1
     9cc:	80 93 65 06 	sts	0x0665, r24	; 0x800665 <__TEXT_REGION_LENGTH__+0x700665>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     9d0:	e0 ea       	ldi	r30, 0xA0	; 160
     9d2:	f9 e0       	ldi	r31, 0x09	; 9
     9d4:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     9d6:	85 ff       	sbrs	r24, 5
     9d8:	fd cf       	rjmp	.-6      	; 0x9d4 <gfx_mono_st7565r_put_byte+0x120>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     9da:	10 93 a0 09 	sts	0x09A0, r17	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     9de:	e0 ea       	ldi	r30, 0xA0	; 160
     9e0:	f9 e0       	ldi	r31, 0x09	; 9
     9e2:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     9e4:	86 ff       	sbrs	r24, 6
     9e6:	fd cf       	rjmp	.-6      	; 0x9e2 <gfx_mono_st7565r_put_byte+0x12e>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     9e8:	e0 ea       	ldi	r30, 0xA0	; 160
     9ea:	f9 e0       	ldi	r31, 0x09	; 9
     9ec:	80 e4       	ldi	r24, 0x40	; 64
     9ee:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     9f0:	80 81       	ld	r24, Z
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
     9f2:	81 e0       	ldi	r24, 0x01	; 1
     9f4:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
	ioport_set_pin_high(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, data);
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     9f8:	be 01       	movw	r22, r28
     9fa:	6f 5f       	subi	r22, 0xFF	; 255
     9fc:	7f 4f       	sbci	r23, 0xFF	; 255
     9fe:	80 ea       	ldi	r24, 0xA0	; 160
     a00:	99 e0       	ldi	r25, 0x09	; 9
     a02:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>

	st7565r_set_page_address(page);
	st7565r_set_column_address(column);

	st7565r_write_data(data);
}
     a06:	0f 90       	pop	r0
     a08:	df 91       	pop	r29
     a0a:	cf 91       	pop	r28
     a0c:	1f 91       	pop	r17
     a0e:	0f 91       	pop	r16
     a10:	ff 90       	pop	r15
     a12:	08 95       	ret

00000a14 <gfx_mono_st7565r_init>:
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a14:	0f 93       	push	r16
     a16:	1f 93       	push	r17
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
     a1c:	1f 92       	push	r1
     a1e:	cd b7       	in	r28, 0x3d	; 61
     a20:	de b7       	in	r29, 0x3e	; 62
	uint8_t page;
	uint8_t column;

#ifdef CONFIG_ST7565R_FRAMEBUFFER
	gfx_mono_set_framebuffer(framebuffer);
     a22:	86 e5       	ldi	r24, 0x56	; 86
     a24:	90 e2       	ldi	r25, 0x20	; 32
     a26:	0e 94 5e 13 	call	0x26bc	; 0x26bc <gfx_mono_set_framebuffer>
#endif

	/* Initialize the low-level display controller. */
	st7565r_init();
     a2a:	68 dd       	rcall	.-1328   	; 0x4fc <st7565r_init>
 * \param command the command to write
 */
static inline void st7565r_write_command(uint8_t command)
{
#if defined(ST7565R_USART_SPI_INTERFACE)
	struct usart_spi_device device = {.id = ST7565R_CS_PIN};
     a2c:	8b e2       	ldi	r24, 0x2B	; 43
     a2e:	89 83       	std	Y+1, r24	; 0x01
	usart_spi_select_device(ST7565R_USART_SPI, &device);
     a30:	be 01       	movw	r22, r28
     a32:	6f 5f       	subi	r22, 0xFF	; 255
     a34:	7f 4f       	sbci	r23, 0xFF	; 255
     a36:	80 ea       	ldi	r24, 0xA0	; 160
     a38:	99 e0       	ldi	r25, 0x09	; 9
     a3a:	0e 94 32 13 	call	0x2664	; 0x2664 <usart_spi_select_device>
     a3e:	81 e0       	ldi	r24, 0x01	; 1
     a40:	80 93 66 06 	sts	0x0666, r24	; 0x800666 <__TEXT_REGION_LENGTH__+0x700666>
 *
 * \param usart The USART module.
 */
static inline bool usart_data_register_is_empty(USART_t * usart)
{
	return (usart)->STATUS & USART_DREIF_bm;
     a44:	e0 ea       	ldi	r30, 0xA0	; 160
     a46:	f9 e0       	ldi	r31, 0x09	; 9
     a48:	81 81       	ldd	r24, Z+1	; 0x01
 * \return The received data
 */
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
     a4a:	85 ff       	sbrs	r24, 5
     a4c:	fd cf       	rjmp	.-6      	; 0xa48 <gfx_mono_st7565r_init+0x34>
 * \param usart The USART module.
 * \param txdata The data to be transmitted.
 */
static inline void usart_put(USART_t * usart, uint8_t txdata)
{
	(usart)->DATA = txdata;
     a4e:	80 e4       	ldi	r24, 0x40	; 64
     a50:	80 93 a0 09 	sts	0x09A0, r24	; 0x8009a0 <__TEXT_REGION_LENGTH__+0x7009a0>
 *
 * \param usart The USART module.
 */
static inline bool usart_tx_is_complete(USART_t * usart)
{
	return (usart)->STATUS & USART_TXCIF_bm;
     a54:	e0 ea       	ldi	r30, 0xA0	; 160
     a56:	f9 e0       	ldi	r31, 0x09	; 9
     a58:	81 81       	ldd	r24, Z+1	; 0x01
static inline uint8_t usart_spi_transmit(USART_t * usart,
		uint8_t txdata)
{
	while (usart_data_register_is_empty(usart) == false);
	usart_put(usart, txdata);
	while (!usart_tx_is_complete(usart));
     a5a:	86 ff       	sbrs	r24, 6
     a5c:	fd cf       	rjmp	.-6      	; 0xa58 <gfx_mono_st7565r_init+0x44>
 *
 * \param usart The USART module.
 */
static inline void usart_clear_tx_complete(USART_t * usart)
{
	(usart)->STATUS = USART_TXCIF_bm;
     a5e:	e0 ea       	ldi	r30, 0xA0	; 160
     a60:	f9 e0       	ldi	r31, 0x09	; 9
     a62:	80 e4       	ldi	r24, 0x40	; 64
     a64:	81 83       	std	Z+1, r24	; 0x01
 *
 * \return The received data
 */
static inline uint8_t usart_get(USART_t * usart)
{
	return (usart)->DATA;
     a66:	80 81       	ld	r24, Z
	ioport_set_pin_low(ST7565R_A0_PIN);
	usart_spi_transmit(ST7565R_USART_SPI, command);
	usart_spi_deselect_device(ST7565R_USART_SPI, &device);
     a68:	be 01       	movw	r22, r28
     a6a:	6f 5f       	subi	r22, 0xFF	; 255
     a6c:	7f 4f       	sbci	r23, 0xFF	; 255
     a6e:	80 ea       	ldi	r24, 0xA0	; 160
     a70:	99 e0       	ldi	r25, 0x09	; 9
     a72:	0e 94 48 13 	call	0x2690	; 0x2690 <usart_spi_deselect_device>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a76:	00 e0       	ldi	r16, 0x00	; 0
     a78:	0a c0       	rjmp	.+20     	; 0xa8e <gfx_mono_st7565r_init+0x7a>
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
     a7a:	40 e0       	ldi	r20, 0x00	; 0
     a7c:	61 2f       	mov	r22, r17
     a7e:	80 2f       	mov	r24, r16
     a80:	19 df       	rcall	.-462    	; 0x8b4 <gfx_mono_st7565r_put_byte>
	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
     a82:	1f 5f       	subi	r17, 0xFF	; 255
     a84:	10 38       	cpi	r17, 0x80	; 128
     a86:	c9 f7       	brne	.-14     	; 0xa7a <gfx_mono_st7565r_init+0x66>

	/* Clear the contents of the display.
	 * If using a framebuffer (SPI interface) it will both clear the
	 * controller memory and the framebuffer.
	 */
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
     a88:	0f 5f       	subi	r16, 0xFF	; 255
     a8a:	04 30       	cpi	r16, 0x04	; 4
     a8c:	11 f0       	breq	.+4      	; 0xa92 <gfx_mono_st7565r_init+0x7e>
 * It will also write the graphic controller RAM to all zeroes.
 *
 * \note This function will clear the contents of the display.
 */
void gfx_mono_st7565r_init(void)
{
     a8e:	10 e0       	ldi	r17, 0x00	; 0
     a90:	f4 cf       	rjmp	.-24     	; 0xa7a <gfx_mono_st7565r_init+0x66>
	for (page = 0; page < GFX_MONO_LCD_PAGES; page++) {
		for (column = 0; column < GFX_MONO_LCD_WIDTH; column++) {
			gfx_mono_put_byte(page, column, 0x00);
		}
	}
}
     a92:	0f 90       	pop	r0
     a94:	df 91       	pop	r29
     a96:	cf 91       	pop	r28
     a98:	1f 91       	pop	r17
     a9a:	0f 91       	pop	r16
     a9c:	08 95       	ret

00000a9e <gfx_mono_st7565r_draw_pixel>:
	gfx_mono_st7565r_draw_pixel(10, 10, GFX_PIXEL_XOR);
\endcode
 */
void gfx_mono_st7565r_draw_pixel(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t color)
{
     a9e:	ff 92       	push	r15
     aa0:	0f 93       	push	r16
     aa2:	1f 93       	push	r17
     aa4:	cf 93       	push	r28
     aa6:	df 93       	push	r29
	uint8_t page;
	uint8_t pixel_mask;
	uint8_t pixel_value;

	/* Discard pixels drawn outside the screen */
	if ((x > GFX_MONO_LCD_WIDTH - 1) || (y > GFX_MONO_LCD_HEIGHT - 1)) {
     aa8:	88 23       	and	r24, r24
     aaa:	54 f1       	brlt	.+84     	; 0xb00 <gfx_mono_st7565r_draw_pixel+0x62>
     aac:	60 32       	cpi	r22, 0x20	; 32
     aae:	40 f5       	brcc	.+80     	; 0xb00 <gfx_mono_st7565r_draw_pixel+0x62>
     ab0:	d4 2f       	mov	r29, r20
     ab2:	c8 2f       	mov	r28, r24
		return;
	}

	page = y / GFX_MONO_LCD_PIXELS_PER_BYTE;
     ab4:	f6 2e       	mov	r15, r22
     ab6:	f6 94       	lsr	r15
     ab8:	f6 94       	lsr	r15
     aba:	f6 94       	lsr	r15
	pixel_mask = (1 << (y - (page * 8)));
     abc:	70 e0       	ldi	r23, 0x00	; 0
     abe:	88 e0       	ldi	r24, 0x08	; 8
     ac0:	f8 9e       	mul	r15, r24
     ac2:	60 19       	sub	r22, r0
     ac4:	71 09       	sbc	r23, r1
     ac6:	11 24       	eor	r1, r1
     ac8:	81 e0       	ldi	r24, 0x01	; 1
     aca:	90 e0       	ldi	r25, 0x00	; 0
     acc:	8c 01       	movw	r16, r24
     ace:	02 c0       	rjmp	.+4      	; 0xad4 <gfx_mono_st7565r_draw_pixel+0x36>
     ad0:	00 0f       	add	r16, r16
     ad2:	11 1f       	adc	r17, r17
     ad4:	6a 95       	dec	r22
     ad6:	e2 f7       	brpl	.-8      	; 0xad0 <gfx_mono_st7565r_draw_pixel+0x32>
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     ad8:	6c 2f       	mov	r22, r28
     ada:	8f 2d       	mov	r24, r15
     adc:	0e 94 71 13 	call	0x26e2	; 0x26e2 <gfx_mono_framebuffer_get_byte>
	 * requested action on this pixel before writing the page back to the
	 * display.
	 */
	pixel_value = gfx_mono_get_byte(page, x);

	switch (color) {
     ae0:	d1 30       	cpi	r29, 0x01	; 1
     ae2:	21 f0       	breq	.+8      	; 0xaec <gfx_mono_st7565r_draw_pixel+0x4e>
     ae4:	28 f0       	brcs	.+10     	; 0xaf0 <gfx_mono_st7565r_draw_pixel+0x52>
     ae6:	d2 30       	cpi	r29, 0x02	; 2
     ae8:	31 f0       	breq	.+12     	; 0xaf6 <gfx_mono_st7565r_draw_pixel+0x58>
     aea:	06 c0       	rjmp	.+12     	; 0xaf8 <gfx_mono_st7565r_draw_pixel+0x5a>
	case GFX_PIXEL_SET:
		pixel_value |= pixel_mask;
     aec:	80 2b       	or	r24, r16
		break;
     aee:	04 c0       	rjmp	.+8      	; 0xaf8 <gfx_mono_st7565r_draw_pixel+0x5a>

	case GFX_PIXEL_CLR:
		pixel_value &= ~pixel_mask;
     af0:	00 95       	com	r16
     af2:	80 23       	and	r24, r16
		break;
     af4:	01 c0       	rjmp	.+2      	; 0xaf8 <gfx_mono_st7565r_draw_pixel+0x5a>

	case GFX_PIXEL_XOR:
		pixel_value ^= pixel_mask;
     af6:	80 27       	eor	r24, r16

	default:
		break;
	}

	gfx_mono_put_byte(page, x, pixel_value);
     af8:	48 2f       	mov	r20, r24
     afa:	6c 2f       	mov	r22, r28
     afc:	8f 2d       	mov	r24, r15
     afe:	da de       	rcall	.-588    	; 0x8b4 <gfx_mono_st7565r_put_byte>
}
     b00:	df 91       	pop	r29
     b02:	cf 91       	pop	r28
     b04:	1f 91       	pop	r17
     b06:	0f 91       	pop	r16
     b08:	ff 90       	pop	r15
     b0a:	08 95       	ret

00000b0c <gfx_mono_st7565r_get_byte>:
\endcode
 */
uint8_t gfx_mono_st7565r_get_byte(gfx_coord_t page, gfx_coord_t column)
{
#ifdef CONFIG_ST7565R_FRAMEBUFFER
	return gfx_mono_framebuffer_get_byte(page, column);
     b0c:	0c 94 71 13 	jmp	0x26e2	; 0x26e2 <gfx_mono_framebuffer_get_byte>
	st7565r_set_column_address(column);

	return st7565r_read_data();

#endif
}
     b10:	08 95       	ret

00000b12 <usart_spi_set_baudrate>:
 * \param usart The USART(SPI) module.
 * \param baud The baudrate.
 * \param cpu_hz The CPU frequency.
 */
void usart_spi_set_baudrate(USART_t *usart, uint32_t baud, uint32_t cpu_hz)
{
     b12:	cf 92       	push	r12
     b14:	df 92       	push	r13
     b16:	ef 92       	push	r14
     b18:	ff 92       	push	r15
     b1a:	0f 93       	push	r16
     b1c:	1f 93       	push	r17
     b1e:	cf 93       	push	r28
     b20:	df 93       	push	r29
     b22:	ec 01       	movw	r28, r24
	uint16_t bsel_value;

	/* Check if baudrate is less than the maximim limit specified in
	 * datasheet */
	if (baud < (cpu_hz / 2)) {
     b24:	d9 01       	movw	r26, r18
     b26:	c8 01       	movw	r24, r16
     b28:	b6 95       	lsr	r27
     b2a:	a7 95       	ror	r26
     b2c:	97 95       	ror	r25
     b2e:	87 95       	ror	r24
     b30:	48 17       	cp	r20, r24
     b32:	59 07       	cpc	r21, r25
     b34:	6a 07       	cpc	r22, r26
     b36:	7b 07       	cpc	r23, r27
     b38:	78 f4       	brcc	.+30     	; 0xb58 <usart_spi_set_baudrate+0x46>
		bsel_value = (cpu_hz / (baud * 2)) - 1;
     b3a:	6a 01       	movw	r12, r20
     b3c:	7b 01       	movw	r14, r22
     b3e:	cc 0c       	add	r12, r12
     b40:	dd 1c       	adc	r13, r13
     b42:	ee 1c       	adc	r14, r14
     b44:	ff 1c       	adc	r15, r15
     b46:	c9 01       	movw	r24, r18
     b48:	b8 01       	movw	r22, r16
     b4a:	a7 01       	movw	r20, r14
     b4c:	96 01       	movw	r18, r12
     b4e:	0e 94 14 17 	call	0x2e28	; 0x2e28 <__udivmodsi4>
     b52:	21 50       	subi	r18, 0x01	; 1
     b54:	31 09       	sbc	r19, r1
     b56:	02 c0       	rjmp	.+4      	; 0xb5c <usart_spi_set_baudrate+0x4a>
	} else {
		/* If baudrate is not within the specfication in datasheet,
		 * assign maximum baudrate possible for the current CPU frequency */
		bsel_value = 0;
     b58:	20 e0       	ldi	r18, 0x00	; 0
     b5a:	30 e0       	ldi	r19, 0x00	; 0
	}

	(usart)->BAUDCTRLB = (uint8_t)((~USART_BSCALE_gm) & (bsel_value >> 8));
     b5c:	83 2f       	mov	r24, r19
     b5e:	8f 70       	andi	r24, 0x0F	; 15
     b60:	8f 83       	std	Y+7, r24	; 0x07
	(usart)->BAUDCTRLA = (uint8_t)(bsel_value);
     b62:	2e 83       	std	Y+6, r18	; 0x06
}
     b64:	df 91       	pop	r29
     b66:	cf 91       	pop	r28
     b68:	1f 91       	pop	r17
     b6a:	0f 91       	pop	r16
     b6c:	ff 90       	pop	r15
     b6e:	ef 90       	pop	r14
     b70:	df 90       	pop	r13
     b72:	cf 90       	pop	r12
     b74:	08 95       	ret

00000b76 <usart_init_spi>:
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
     b76:	df 92       	push	r13
     b78:	ef 92       	push	r14
     b7a:	ff 92       	push	r15
     b7c:	0f 93       	push	r16
     b7e:	1f 93       	push	r17
     b80:	cf 93       	push	r28
     b82:	df 93       	push	r29
     b84:	1f 92       	push	r1
     b86:	cd b7       	in	r28, 0x3d	; 61
     b88:	de b7       	in	r29, 0x3e	; 62
     b8a:	7c 01       	movw	r14, r24
     b8c:	8b 01       	movw	r16, r22
 *
 * \param module Pointer to the module's base address.
 */
static inline void sysclk_enable_peripheral_clock(const volatile void *module)
{
	if (module == NULL) {
     b8e:	00 97       	sbiw	r24, 0x00	; 0
     b90:	09 f4       	brne	.+2      	; 0xb94 <usart_init_spi+0x1e>
     b92:	cf c1       	rjmp	.+926    	; 0xf32 <usart_init_spi+0x3bc>
		Assert(false);
	}
#ifdef AES
	else if (module == &AES) {
     b94:	80 3c       	cpi	r24, 0xC0	; 192
     b96:	91 05       	cpc	r25, r1
     b98:	29 f4       	brne	.+10     	; 0xba4 <usart_init_spi+0x2e>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_AES);
     b9a:	60 e1       	ldi	r22, 0x10	; 16
     b9c:	80 e0       	ldi	r24, 0x00	; 0
     b9e:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     ba2:	c7 c1       	rjmp	.+910    	; 0xf32 <usart_init_spi+0x3bc>
	else if (module == &RTC) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_RTC);
	}
#endif
#ifdef EVSYS
	else if (module == &EVSYS) {
     ba4:	80 e8       	ldi	r24, 0x80	; 128
     ba6:	e8 16       	cp	r14, r24
     ba8:	81 e0       	ldi	r24, 0x01	; 1
     baa:	f8 06       	cpc	r15, r24
     bac:	29 f4       	brne	.+10     	; 0xbb8 <usart_init_spi+0x42>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EVSYS);
     bae:	62 e0       	ldi	r22, 0x02	; 2
     bb0:	80 e0       	ldi	r24, 0x00	; 0
     bb2:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     bb6:	bd c1       	rjmp	.+890    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef DMA
	else if (module == &DMA) {
     bb8:	e1 14       	cp	r14, r1
     bba:	e1 e0       	ldi	r30, 0x01	; 1
     bbc:	fe 06       	cpc	r15, r30
     bbe:	29 f4       	brne	.+10     	; 0xbca <usart_init_spi+0x54>
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_DMA);
     bc0:	61 e0       	ldi	r22, 0x01	; 1
     bc2:	80 e0       	ldi	r24, 0x00	; 0
     bc4:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     bc8:	b4 c1       	rjmp	.+872    	; 0xf32 <usart_init_spi+0x3bc>
	else if (module == &EDMA) {
		sysclk_enable_module(SYSCLK_PORT_GEN, SYSCLK_EDMA);
	}
#endif
#ifdef ACA
	else if (module == &ACA) {
     bca:	f0 e8       	ldi	r31, 0x80	; 128
     bcc:	ef 16       	cp	r14, r31
     bce:	f3 e0       	ldi	r31, 0x03	; 3
     bd0:	ff 06       	cpc	r15, r31
     bd2:	29 f4       	brne	.+10     	; 0xbde <usart_init_spi+0x68>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_AC);
     bd4:	61 e0       	ldi	r22, 0x01	; 1
     bd6:	81 e0       	ldi	r24, 0x01	; 1
     bd8:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     bdc:	aa c1       	rjmp	.+852    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef ACB
	else if (module == &ACB) {
     bde:	30 e9       	ldi	r19, 0x90	; 144
     be0:	e3 16       	cp	r14, r19
     be2:	33 e0       	ldi	r19, 0x03	; 3
     be4:	f3 06       	cpc	r15, r19
     be6:	29 f4       	brne	.+10     	; 0xbf2 <usart_init_spi+0x7c>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_AC);
     be8:	61 e0       	ldi	r22, 0x01	; 1
     bea:	82 e0       	ldi	r24, 0x02	; 2
     bec:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     bf0:	a0 c1       	rjmp	.+832    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef ADCA
	else if (module == &ADCA) {
     bf2:	e1 14       	cp	r14, r1
     bf4:	82 e0       	ldi	r24, 0x02	; 2
     bf6:	f8 06       	cpc	r15, r24
     bf8:	29 f4       	brne	.+10     	; 0xc04 <usart_init_spi+0x8e>
		sysclk_enable_module(SYSCLK_PORT_A, SYSCLK_ADC);
     bfa:	62 e0       	ldi	r22, 0x02	; 2
     bfc:	81 e0       	ldi	r24, 0x01	; 1
     bfe:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     c02:	97 c1       	rjmp	.+814    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef ADCB
	else if (module == &ADCB) {
     c04:	e0 e4       	ldi	r30, 0x40	; 64
     c06:	ee 16       	cp	r14, r30
     c08:	e2 e0       	ldi	r30, 0x02	; 2
     c0a:	fe 06       	cpc	r15, r30
     c0c:	29 f4       	brne	.+10     	; 0xc18 <usart_init_spi+0xa2>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_ADC);
     c0e:	62 e0       	ldi	r22, 0x02	; 2
     c10:	82 e0       	ldi	r24, 0x02	; 2
     c12:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     c16:	8d c1       	rjmp	.+794    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
// Workaround for bad XMEGA D header file
#if !XMEGA_D
#ifdef DACB
	else if (module == &DACB) {
     c18:	f0 e2       	ldi	r31, 0x20	; 32
     c1a:	ef 16       	cp	r14, r31
     c1c:	f3 e0       	ldi	r31, 0x03	; 3
     c1e:	ff 06       	cpc	r15, r31
     c20:	29 f4       	brne	.+10     	; 0xc2c <usart_init_spi+0xb6>
		sysclk_enable_module(SYSCLK_PORT_B, SYSCLK_DAC);
     c22:	64 e0       	ldi	r22, 0x04	; 4
     c24:	82 e0       	ldi	r24, 0x02	; 2
     c26:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     c2a:	83 c1       	rjmp	.+774    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#endif // Workaround end
#ifdef TCC0
	else if (module == &TCC0) {
     c2c:	e1 14       	cp	r14, r1
     c2e:	38 e0       	ldi	r19, 0x08	; 8
     c30:	f3 06       	cpc	r15, r19
     c32:	29 f4       	brne	.+10     	; 0xc3e <usart_init_spi+0xc8>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC0);
     c34:	61 e0       	ldi	r22, 0x01	; 1
     c36:	83 e0       	ldi	r24, 0x03	; 3
     c38:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     c3c:	7a c1       	rjmp	.+756    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCD0
	else if (module == &TCD0) {
     c3e:	e1 14       	cp	r14, r1
     c40:	89 e0       	ldi	r24, 0x09	; 9
     c42:	f8 06       	cpc	r15, r24
     c44:	29 f4       	brne	.+10     	; 0xc50 <usart_init_spi+0xda>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC0);
     c46:	61 e0       	ldi	r22, 0x01	; 1
     c48:	84 e0       	ldi	r24, 0x04	; 4
     c4a:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     c4e:	71 c1       	rjmp	.+738    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCE0
	else if (module == &TCE0) {
     c50:	e1 14       	cp	r14, r1
     c52:	ea e0       	ldi	r30, 0x0A	; 10
     c54:	fe 06       	cpc	r15, r30
     c56:	29 f4       	brne	.+10     	; 0xc62 <usart_init_spi+0xec>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC0);
     c58:	61 e0       	ldi	r22, 0x01	; 1
     c5a:	85 e0       	ldi	r24, 0x05	; 5
     c5c:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     c60:	68 c1       	rjmp	.+720    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCF0
	else if (module == &TCF0) {
     c62:	e1 14       	cp	r14, r1
     c64:	fb e0       	ldi	r31, 0x0B	; 11
     c66:	ff 06       	cpc	r15, r31
     c68:	29 f4       	brne	.+10     	; 0xc74 <usart_init_spi+0xfe>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_TC0);
     c6a:	61 e0       	ldi	r22, 0x01	; 1
     c6c:	86 e0       	ldi	r24, 0x06	; 6
     c6e:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     c72:	5f c1       	rjmp	.+702    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCC1
	else if (module == &TCC1) {
     c74:	30 e4       	ldi	r19, 0x40	; 64
     c76:	e3 16       	cp	r14, r19
     c78:	38 e0       	ldi	r19, 0x08	; 8
     c7a:	f3 06       	cpc	r15, r19
     c7c:	29 f4       	brne	.+10     	; 0xc88 <usart_init_spi+0x112>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TC1);
     c7e:	62 e0       	ldi	r22, 0x02	; 2
     c80:	83 e0       	ldi	r24, 0x03	; 3
     c82:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     c86:	55 c1       	rjmp	.+682    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCD1
	else if (module == &TCD1) {
     c88:	80 e4       	ldi	r24, 0x40	; 64
     c8a:	e8 16       	cp	r14, r24
     c8c:	89 e0       	ldi	r24, 0x09	; 9
     c8e:	f8 06       	cpc	r15, r24
     c90:	29 f4       	brne	.+10     	; 0xc9c <usart_init_spi+0x126>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC1);
     c92:	62 e0       	ldi	r22, 0x02	; 2
     c94:	84 e0       	ldi	r24, 0x04	; 4
     c96:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     c9a:	4b c1       	rjmp	.+662    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef TCE1
	else if (module == &TCE1) {
     c9c:	e0 e4       	ldi	r30, 0x40	; 64
     c9e:	ee 16       	cp	r14, r30
     ca0:	ea e0       	ldi	r30, 0x0A	; 10
     ca2:	fe 06       	cpc	r15, r30
     ca4:	29 f4       	brne	.+10     	; 0xcb0 <usart_init_spi+0x13a>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TC1);
     ca6:	62 e0       	ldi	r22, 0x02	; 2
     ca8:	85 e0       	ldi	r24, 0x05	; 5
     caa:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     cae:	41 c1       	rjmp	.+642    	; 0xf32 <usart_init_spi+0x3bc>
	else if (module == &TCD5) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TC5);
	}
#endif
#ifdef HIRESC
	else if (module == &HIRESC) {
     cb0:	f0 e9       	ldi	r31, 0x90	; 144
     cb2:	ef 16       	cp	r14, r31
     cb4:	f8 e0       	ldi	r31, 0x08	; 8
     cb6:	ff 06       	cpc	r15, r31
     cb8:	29 f4       	brne	.+10     	; 0xcc4 <usart_init_spi+0x14e>
			sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_HIRES);
     cba:	64 e0       	ldi	r22, 0x04	; 4
     cbc:	83 e0       	ldi	r24, 0x03	; 3
     cbe:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     cc2:	37 c1       	rjmp	.+622    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESD
	else if (module == &HIRESD) {
     cc4:	30 e9       	ldi	r19, 0x90	; 144
     cc6:	e3 16       	cp	r14, r19
     cc8:	39 e0       	ldi	r19, 0x09	; 9
     cca:	f3 06       	cpc	r15, r19
     ccc:	29 f4       	brne	.+10     	; 0xcd8 <usart_init_spi+0x162>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_HIRES);
     cce:	64 e0       	ldi	r22, 0x04	; 4
     cd0:	84 e0       	ldi	r24, 0x04	; 4
     cd2:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     cd6:	2d c1       	rjmp	.+602    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESE
	else if (module == &HIRESE) {
     cd8:	80 e9       	ldi	r24, 0x90	; 144
     cda:	e8 16       	cp	r14, r24
     cdc:	8a e0       	ldi	r24, 0x0A	; 10
     cde:	f8 06       	cpc	r15, r24
     ce0:	29 f4       	brne	.+10     	; 0xcec <usart_init_spi+0x176>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_HIRES);
     ce2:	64 e0       	ldi	r22, 0x04	; 4
     ce4:	85 e0       	ldi	r24, 0x05	; 5
     ce6:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     cea:	23 c1       	rjmp	.+582    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef HIRESF
	else if (module == &HIRESF) {
     cec:	e0 e9       	ldi	r30, 0x90	; 144
     cee:	ee 16       	cp	r14, r30
     cf0:	eb e0       	ldi	r30, 0x0B	; 11
     cf2:	fe 06       	cpc	r15, r30
     cf4:	29 f4       	brne	.+10     	; 0xd00 <usart_init_spi+0x18a>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_HIRES);
     cf6:	64 e0       	ldi	r22, 0x04	; 4
     cf8:	86 e0       	ldi	r24, 0x06	; 6
     cfa:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     cfe:	19 c1       	rjmp	.+562    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef SPIC
	else if (module == &SPIC) {
     d00:	f0 ec       	ldi	r31, 0xC0	; 192
     d02:	ef 16       	cp	r14, r31
     d04:	f8 e0       	ldi	r31, 0x08	; 8
     d06:	ff 06       	cpc	r15, r31
     d08:	29 f4       	brne	.+10     	; 0xd14 <usart_init_spi+0x19e>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_SPI);
     d0a:	68 e0       	ldi	r22, 0x08	; 8
     d0c:	83 e0       	ldi	r24, 0x03	; 3
     d0e:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     d12:	0f c1       	rjmp	.+542    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef SPID
	else if (module == &SPID) {
     d14:	30 ec       	ldi	r19, 0xC0	; 192
     d16:	e3 16       	cp	r14, r19
     d18:	39 e0       	ldi	r19, 0x09	; 9
     d1a:	f3 06       	cpc	r15, r19
     d1c:	29 f4       	brne	.+10     	; 0xd28 <usart_init_spi+0x1b2>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_SPI);
     d1e:	68 e0       	ldi	r22, 0x08	; 8
     d20:	84 e0       	ldi	r24, 0x04	; 4
     d22:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     d26:	05 c1       	rjmp	.+522    	; 0xf32 <usart_init_spi+0x3bc>
	else if (module == &SPIF) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_SPI);
	}
#endif
#ifdef USARTC0
	else if (module == &USARTC0) {
     d28:	80 ea       	ldi	r24, 0xA0	; 160
     d2a:	e8 16       	cp	r14, r24
     d2c:	88 e0       	ldi	r24, 0x08	; 8
     d2e:	f8 06       	cpc	r15, r24
     d30:	69 f4       	brne	.+26     	; 0xd4c <usart_init_spi+0x1d6>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART0);
     d32:	60 e1       	ldi	r22, 0x10	; 16
     d34:	83 e0       	ldi	r24, 0x03	; 3
     d36:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
     d3a:	e0 ea       	ldi	r30, 0xA0	; 160
     d3c:	f8 e0       	ldi	r31, 0x08	; 8
     d3e:	84 81       	ldd	r24, Z+4	; 0x04
     d40:	8f 7e       	andi	r24, 0xEF	; 239
     d42:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
     d44:	f8 01       	movw	r30, r16
     d46:	24 81       	ldd	r18, Z+4	; 0x04
     d48:	22 50       	subi	r18, 0x02	; 2
     d4a:	53 c0       	rjmp	.+166    	; 0xdf2 <usart_init_spi+0x27c>
	}
#endif
#ifdef USARTD0
	else if (module == &USARTD0) {
     d4c:	f0 ea       	ldi	r31, 0xA0	; 160
     d4e:	ef 16       	cp	r14, r31
     d50:	f9 e0       	ldi	r31, 0x09	; 9
     d52:	ff 06       	cpc	r15, r31
     d54:	29 f4       	brne	.+10     	; 0xd60 <usart_init_spi+0x1ea>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART0);
     d56:	60 e1       	ldi	r22, 0x10	; 16
     d58:	84 e0       	ldi	r24, 0x04	; 4
     d5a:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     d5e:	e9 c0       	rjmp	.+466    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTE0
	else if (module == &USARTE0) {
     d60:	30 ea       	ldi	r19, 0xA0	; 160
     d62:	e3 16       	cp	r14, r19
     d64:	3a e0       	ldi	r19, 0x0A	; 10
     d66:	f3 06       	cpc	r15, r19
     d68:	29 f4       	brne	.+10     	; 0xd74 <usart_init_spi+0x1fe>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_USART0);
     d6a:	60 e1       	ldi	r22, 0x10	; 16
     d6c:	85 e0       	ldi	r24, 0x05	; 5
     d6e:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     d72:	df c0       	rjmp	.+446    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTF0
	else if (module == &USARTF0) {
     d74:	80 ea       	ldi	r24, 0xA0	; 160
     d76:	e8 16       	cp	r14, r24
     d78:	8b e0       	ldi	r24, 0x0B	; 11
     d7a:	f8 06       	cpc	r15, r24
     d7c:	29 f4       	brne	.+10     	; 0xd88 <usart_init_spi+0x212>
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART0);
     d7e:	60 e1       	ldi	r22, 0x10	; 16
     d80:	86 e0       	ldi	r24, 0x06	; 6
     d82:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     d86:	d5 c0       	rjmp	.+426    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTC1
	else if (module == &USARTC1) {
     d88:	e0 eb       	ldi	r30, 0xB0	; 176
     d8a:	ee 16       	cp	r14, r30
     d8c:	e8 e0       	ldi	r30, 0x08	; 8
     d8e:	fe 06       	cpc	r15, r30
     d90:	29 f4       	brne	.+10     	; 0xd9c <usart_init_spi+0x226>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_USART1);
     d92:	60 e2       	ldi	r22, 0x20	; 32
     d94:	83 e0       	ldi	r24, 0x03	; 3
     d96:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     d9a:	cb c0       	rjmp	.+406    	; 0xf32 <usart_init_spi+0x3bc>
	}
#endif
#ifdef USARTD1
	else if (module == &USARTD1) {
     d9c:	f0 eb       	ldi	r31, 0xB0	; 176
     d9e:	ef 16       	cp	r14, r31
     da0:	f9 e0       	ldi	r31, 0x09	; 9
     da2:	ff 06       	cpc	r15, r31
     da4:	29 f4       	brne	.+10     	; 0xdb0 <usart_init_spi+0x23a>
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_USART1);
     da6:	60 e2       	ldi	r22, 0x20	; 32
     da8:	84 e0       	ldi	r24, 0x04	; 4
     daa:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     dae:	c1 c0       	rjmp	.+386    	; 0xf32 <usart_init_spi+0x3bc>
	else if (module == &USARTF1) {
		sysclk_enable_module(SYSCLK_PORT_F, SYSCLK_USART1);
	}
#endif
#ifdef TWIC
	else if (module == &TWIC) {
     db0:	30 e8       	ldi	r19, 0x80	; 128
     db2:	e3 16       	cp	r14, r19
     db4:	34 e0       	ldi	r19, 0x04	; 4
     db6:	f3 06       	cpc	r15, r19
     db8:	29 f4       	brne	.+10     	; 0xdc4 <usart_init_spi+0x24e>
		sysclk_enable_module(SYSCLK_PORT_C, SYSCLK_TWI);
     dba:	60 e4       	ldi	r22, 0x40	; 64
     dbc:	83 e0       	ldi	r24, 0x03	; 3
     dbe:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     dc2:	b7 c0       	rjmp	.+366    	; 0xf32 <usart_init_spi+0x3bc>
	else if (module == &TWID) {
		sysclk_enable_module(SYSCLK_PORT_D, SYSCLK_TWI);
	}
#endif
#ifdef TWIE
	else if (module == &TWIE) {
     dc4:	80 ea       	ldi	r24, 0xA0	; 160
     dc6:	e8 16       	cp	r14, r24
     dc8:	84 e0       	ldi	r24, 0x04	; 4
     dca:	f8 06       	cpc	r15, r24
     dcc:	29 f4       	brne	.+10     	; 0xdd8 <usart_init_spi+0x262>
		sysclk_enable_module(SYSCLK_PORT_E, SYSCLK_TWI);
     dce:	60 e4       	ldi	r22, 0x40	; 64
     dd0:	85 e0       	ldi	r24, 0x05	; 5
     dd2:	0e 94 11 14 	call	0x2822	; 0x2822 <sysclk_enable_module>
     dd6:	ad c0       	rjmp	.+346    	; 0xf32 <usart_init_spi+0x3bc>
     dd8:	f7 01       	movw	r30, r14
     dda:	84 81       	ldd	r24, Z+4	; 0x04
     ddc:	8f 7e       	andi	r24, 0xEF	; 239
     dde:	84 83       	std	Z+4, r24	; 0x04
     de0:	fb 01       	movw	r30, r22
     de2:	24 81       	ldd	r18, Z+4	; 0x04
     de4:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
     de6:	c7 01       	movw	r24, r14
     de8:	f0 ea       	ldi	r31, 0xA0	; 160
     dea:	ef 16       	cp	r14, r31
     dec:	f8 e0       	ldi	r31, 0x08	; 8
     dee:	ff 06       	cpc	r15, r31
     df0:	49 f4       	brne	.+18     	; 0xe04 <usart_init_spi+0x28e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
     df2:	80 91 4e 06 	lds	r24, 0x064E	; 0x80064e <__TEXT_REGION_LENGTH__+0x70064e>
     df6:	84 fd       	sbrc	r24, 4
     df8:	a5 c0       	rjmp	.+330    	; 0xf44 <usart_init_spi+0x3ce>
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
     dfa:	0f 2e       	mov	r0, r31
     dfc:	f1 e1       	ldi	r31, 0x11	; 17
     dfe:	df 2e       	mov	r13, r31
     e00:	f0 2d       	mov	r31, r0
     e02:	a4 c0       	rjmp	.+328    	; 0xf4c <usart_init_spi+0x3d6>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 1);
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
     e04:	80 3b       	cpi	r24, 0xB0	; 176
     e06:	38 e0       	ldi	r19, 0x08	; 8
     e08:	93 07       	cpc	r25, r19
     e0a:	91 f0       	breq	.+36     	; 0xe30 <usart_init_spi+0x2ba>
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
	}
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
     e0c:	80 3a       	cpi	r24, 0xA0	; 160
     e0e:	e9 e0       	ldi	r30, 0x09	; 9
     e10:	9e 07       	cpc	r25, r30
     e12:	49 f4       	brne	.+18     	; 0xe26 <usart_init_spi+0x2b0>
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
     e14:	30 91 6e 06 	lds	r19, 0x066E	; 0x80066e <__TEXT_REGION_LENGTH__+0x70066e>
     e18:	34 fd       	sbrc	r19, 4
     e1a:	9b c0       	rjmp	.+310    	; 0xf52 <usart_init_spi+0x3dc>
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
     e1c:	0f 2e       	mov	r0, r31
     e1e:	f9 e1       	ldi	r31, 0x19	; 25
     e20:	df 2e       	mov	r13, r31
     e22:	f0 2d       	mov	r31, r0
     e24:	16 c0       	rjmp	.+44     	; 0xe52 <usart_init_spi+0x2dc>
		sck_pin = IOPORT_CREATE_PIN(PORTD, 1);
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
     e26:	80 3b       	cpi	r24, 0xB0	; 176
     e28:	f9 e0       	ldi	r31, 0x09	; 9
     e2a:	9f 07       	cpc	r25, r31
     e2c:	f1 f0       	breq	.+60     	; 0xe6a <usart_init_spi+0x2f4>
     e2e:	04 c0       	rjmp	.+8      	; 0xe38 <usart_init_spi+0x2c2>
#  endif
	}
#endif
#ifdef USARTC1
	if ((uint16_t)usart == (uint16_t)&USARTC1) {
		sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
     e30:	0f 2e       	mov	r0, r31
     e32:	f5 e1       	ldi	r31, 0x15	; 21
     e34:	df 2e       	mov	r13, r31
     e36:	f0 2d       	mov	r31, r0
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
	}
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
     e38:	80 3a       	cpi	r24, 0xA0	; 160
     e3a:	3a e0       	ldi	r19, 0x0A	; 10
     e3c:	93 07       	cpc	r25, r19
     e3e:	49 f4       	brne	.+18     	; 0xe52 <usart_init_spi+0x2dc>
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
     e40:	80 91 8e 06 	lds	r24, 0x068E	; 0x80068e <__TEXT_REGION_LENGTH__+0x70068e>
     e44:	84 fd       	sbrc	r24, 4
     e46:	8a c0       	rjmp	.+276    	; 0xf5c <usart_init_spi+0x3e6>
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 1);
     e48:	0f 2e       	mov	r0, r31
     e4a:	f1 e2       	ldi	r31, 0x21	; 33
     e4c:	df 2e       	mov	r13, r31
     e4e:	f0 2d       	mov	r31, r0
     e50:	15 c0       	rjmp	.+42     	; 0xe7c <usart_init_spi+0x306>
	if ((uint16_t)usart == (uint16_t)&USARTE1) {
		sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
	}
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
     e52:	80 3a       	cpi	r24, 0xA0	; 160
     e54:	9b 40       	sbci	r25, 0x0B	; 11
     e56:	91 f4       	brne	.+36     	; 0xe7c <usart_init_spi+0x306>
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
     e58:	80 91 ae 06 	lds	r24, 0x06AE	; 0x8006ae <__TEXT_REGION_LENGTH__+0x7006ae>
     e5c:	84 fd       	sbrc	r24, 4
     e5e:	0a c0       	rjmp	.+20     	; 0xe74 <usart_init_spi+0x2fe>
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
		} else {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 1);
     e60:	0f 2e       	mov	r0, r31
     e62:	f9 e2       	ldi	r31, 0x29	; 41
     e64:	df 2e       	mov	r13, r31
     e66:	f0 2d       	mov	r31, r0
     e68:	09 c0       	rjmp	.+18     	; 0xe7c <usart_init_spi+0x306>
#  endif
	}
#endif
#ifdef USARTD1
	if ((uint16_t)usart == (uint16_t)&USARTD1) {
		sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
     e6a:	0f 2e       	mov	r0, r31
     e6c:	fd e1       	ldi	r31, 0x1D	; 29
     e6e:	df 2e       	mov	r13, r31
     e70:	f0 2d       	mov	r31, r0
     e72:	04 c0       	rjmp	.+8      	; 0xe7c <usart_init_spi+0x306>
#endif
#ifdef USARTF0
	if ((uint16_t)usart == (uint16_t)&USARTF0) {
#  ifdef PORT_USART0_bm
		if(PORTF.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTF, 5);
     e74:	0f 2e       	mov	r0, r31
     e76:	fd e2       	ldi	r31, 0x2D	; 45
     e78:	df 2e       	mov	r13, r31
     e7a:	f0 2d       	mov	r31, r0
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
     e7c:	ed 2d       	mov	r30, r13
     e7e:	e6 95       	lsr	r30
     e80:	e6 95       	lsr	r30
     e82:	e6 95       	lsr	r30
     e84:	30 e2       	ldi	r19, 0x20	; 32
     e86:	e3 9f       	mul	r30, r19
     e88:	f0 01       	movw	r30, r0
     e8a:	11 24       	eor	r1, r1
     e8c:	fa 5f       	subi	r31, 0xFA	; 250
     e8e:	3d 2d       	mov	r19, r13
     e90:	37 70       	andi	r19, 0x07	; 7
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
     e92:	81 e0       	ldi	r24, 0x01	; 1
     e94:	90 e0       	ldi	r25, 0x00	; 0
     e96:	03 2e       	mov	r0, r19
     e98:	02 c0       	rjmp	.+4      	; 0xe9e <usart_init_spi+0x328>
     e9a:	88 0f       	add	r24, r24
     e9c:	99 1f       	adc	r25, r25
     e9e:	0a 94       	dec	r0
     ea0:	e2 f7       	brpl	.-8      	; 0xe9a <usart_init_spi+0x324>
		enum ioport_direction dir)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (dir == IOPORT_DIR_OUTPUT) {
		base->DIRSET = arch_ioport_pin_to_mask(pin);
     ea2:	81 83       	std	Z+1, r24	; 0x01
	}
#endif

	/* Configure the USART output pin */
	ioport_set_pin_dir(sck_pin, IOPORT_DIR_OUTPUT);
	ioport_set_pin_mode(sck_pin,
     ea4:	22 30       	cpi	r18, 0x02	; 2
     ea6:	10 f0       	brcs	.+4      	; 0xeac <usart_init_spi+0x336>
     ea8:	40 e0       	ldi	r20, 0x00	; 0
     eaa:	01 c0       	rjmp	.+2      	; 0xeae <usart_init_spi+0x338>
     eac:	40 e4       	ldi	r20, 0x40	; 64
__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));
     eae:	df 01       	movw	r26, r30
     eb0:	50 96       	adiw	r26, 0x10	; 16

__always_inline static void arch_ioport_set_pin_mode(ioport_pin_t pin,
		ioport_mode_t mode)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);
	volatile uint8_t *pin_ctrl
     eb2:	a3 0f       	add	r26, r19
     eb4:	b1 1d       	adc	r27, r1

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
     eb6:	9f b7       	in	r25, 0x3f	; 63
     eb8:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
     eba:	f8 94       	cli
	return flags;
     ebc:	39 81       	ldd	r19, Y+1	; 0x01
		= (&base->PIN0CTRL + arch_ioport_pin_to_index(pin));

	uint8_t flags = cpu_irq_save();

	*pin_ctrl &= PORT_ISC_gm;
     ebe:	2c 91       	ld	r18, X
     ec0:	27 70       	andi	r18, 0x07	; 7
     ec2:	2c 93       	st	X, r18
	*pin_ctrl |= mode;
     ec4:	9c 91       	ld	r25, X
     ec6:	94 2b       	or	r25, r20
     ec8:	9c 93       	st	X, r25
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
     eca:	3f bf       	out	0x3f, r19	; 63
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
     ecc:	85 83       	std	Z+5, r24	; 0x05
 * - 0x2        : IrDA mode.
 * - 0x3        : Master SPI mode.
 */
static inline void usart_set_mode(USART_t *usart, USART_CMODE_t usartmode)
{
	(usart)->CTRLC = ((usart)->CTRLC & (~USART_CMODE_gm)) | usartmode;
     ece:	f7 01       	movw	r30, r14
     ed0:	85 81       	ldd	r24, Z+5	; 0x05
     ed2:	80 6c       	ori	r24, 0xC0	; 192
     ed4:	85 83       	std	Z+5, r24	; 0x05
			IOPORT_MODE_TOTEM | (invert_sck? IOPORT_MODE_INVERT_PIN : 0));
	ioport_set_pin_level(sck_pin, IOPORT_PIN_LEVEL_HIGH);

	usart_set_mode(usart, USART_CMODE_MSPI_gc);

	if (opt->spimode == 1 || opt->spimode == 3) {
     ed6:	f8 01       	movw	r30, r16
     ed8:	84 81       	ldd	r24, Z+4	; 0x04
     eda:	8d 7f       	andi	r24, 0xFD	; 253
     edc:	81 30       	cpi	r24, 0x01	; 1
     ede:	29 f4       	brne	.+10     	; 0xeea <usart_init_spi+0x374>
		usart->CTRLC |= USART_UCPHA_bm;
     ee0:	f7 01       	movw	r30, r14
     ee2:	85 81       	ldd	r24, Z+5	; 0x05
     ee4:	82 60       	ori	r24, 0x02	; 2
     ee6:	85 83       	std	Z+5, r24	; 0x05
     ee8:	04 c0       	rjmp	.+8      	; 0xef2 <usart_init_spi+0x37c>
	} else {
		usart->CTRLC &= ~USART_UCPHA_bm;
     eea:	f7 01       	movw	r30, r14
     eec:	85 81       	ldd	r24, Z+5	; 0x05
     eee:	8d 7f       	andi	r24, 0xFD	; 253
     ef0:	85 83       	std	Z+5, r24	; 0x05
	}
	if (opt->data_order) {
     ef2:	f8 01       	movw	r30, r16
     ef4:	85 81       	ldd	r24, Z+5	; 0x05
     ef6:	88 23       	and	r24, r24
     ef8:	29 f0       	breq	.+10     	; 0xf04 <usart_init_spi+0x38e>
		(usart)->CTRLC |= USART_DORD_bm;
     efa:	f7 01       	movw	r30, r14
     efc:	85 81       	ldd	r24, Z+5	; 0x05
     efe:	84 60       	ori	r24, 0x04	; 4
     f00:	85 83       	std	Z+5, r24	; 0x05
     f02:	04 c0       	rjmp	.+8      	; 0xf0c <usart_init_spi+0x396>
	} else {
		(usart)->CTRLC &= ~USART_DORD_bm;
     f04:	f7 01       	movw	r30, r14
     f06:	85 81       	ldd	r24, Z+5	; 0x05
     f08:	8b 7f       	andi	r24, 0xFB	; 251
     f0a:	85 83       	std	Z+5, r24	; 0x05
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
     f0c:	f8 01       	movw	r30, r16
     f0e:	40 81       	ld	r20, Z
     f10:	51 81       	ldd	r21, Z+1	; 0x01
     f12:	62 81       	ldd	r22, Z+2	; 0x02
     f14:	73 81       	ldd	r23, Z+3	; 0x03
     f16:	00 e8       	ldi	r16, 0x80	; 128
     f18:	14 e8       	ldi	r17, 0x84	; 132
     f1a:	2e e1       	ldi	r18, 0x1E	; 30
     f1c:	30 e0       	ldi	r19, 0x00	; 0
     f1e:	c7 01       	movw	r24, r14
     f20:	f8 dd       	rcall	.-1040   	; 0xb12 <usart_spi_set_baudrate>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_tx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_TXEN_bm;
     f22:	f7 01       	movw	r30, r14
     f24:	84 81       	ldd	r24, Z+4	; 0x04
     f26:	88 60       	ori	r24, 0x08	; 8
     f28:	84 83       	std	Z+4, r24	; 0x04
 *
 * \param usart Pointer to the USART module
 */
static inline void usart_rx_enable(USART_t *usart)
{
	(usart)->CTRLB |= USART_RXEN_bm;
     f2a:	84 81       	ldd	r24, Z+4	; 0x04
     f2c:	80 61       	ori	r24, 0x10	; 16
     f2e:	84 83       	std	Z+4, r24	; 0x04
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
     f30:	1a c0       	rjmp	.+52     	; 0xf66 <usart_init_spi+0x3f0>
 *
 * \param usart Pointer to the USART module.
 */
static inline void usart_rx_disable(USART_t *usart)
{
	(usart)->CTRLB &= ~USART_RXEN_bm;
     f32:	f7 01       	movw	r30, r14
     f34:	84 81       	ldd	r24, Z+4	; 0x04
     f36:	8f 7e       	andi	r24, 0xEF	; 239
     f38:	84 83       	std	Z+4, r24	; 0x04
	sysclk_enable_peripheral_clock(usart);

	usart_rx_disable(usart);

	/* configure Clock polarity using INVEN bit of the correct SCK I/O port **/
	invert_sck = (opt->spimode == 2) || (opt->spimode == 3);
     f3a:	f8 01       	movw	r30, r16
     f3c:	24 81       	ldd	r18, Z+4	; 0x04
     f3e:	22 50       	subi	r18, 0x02	; 2
	UNUSED(invert_sck);

#ifdef USARTC0
	if ((uint16_t)usart == (uint16_t)&USARTC0) {
     f40:	c7 01       	movw	r24, r14
     f42:	60 cf       	rjmp	.-320    	; 0xe04 <usart_init_spi+0x28e>
#  ifdef PORT_USART0_bm
		if (PORTC.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTC, 5);
     f44:	0f 2e       	mov	r0, r31
     f46:	f5 e1       	ldi	r31, 0x15	; 21
     f48:	df 2e       	mov	r13, r31
     f4a:	f0 2d       	mov	r31, r0
 *
 * \param usart The USART module.
 * \param opt The RS232 configuration option.
 */
void usart_init_spi(USART_t *usart, const usart_spi_options_t *opt)
{
     f4c:	80 ea       	ldi	r24, 0xA0	; 160
     f4e:	98 e0       	ldi	r25, 0x08	; 8
     f50:	6a cf       	rjmp	.-300    	; 0xe26 <usart_init_spi+0x2b0>
#endif
#ifdef USARTD0
	if ((uint16_t)usart == (uint16_t)&USARTD0) {
#  ifdef PORT_USART0_bm
		if (PORTD.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTD, 5);
     f52:	0f 2e       	mov	r0, r31
     f54:	fd e1       	ldi	r31, 0x1D	; 29
     f56:	df 2e       	mov	r13, r31
     f58:	f0 2d       	mov	r31, r0
     f5a:	7b cf       	rjmp	.-266    	; 0xe52 <usart_init_spi+0x2dc>
#endif
#ifdef USARTE0
	if ((uint16_t)usart == (uint16_t)&USARTE0) {
#  ifdef PORT_USART0_bm
		if(PORTE.REMAP & PORT_USART0_bm) {
			sck_pin = IOPORT_CREATE_PIN(PORTE, 5);
     f5c:	0f 2e       	mov	r0, r31
     f5e:	f5 e2       	ldi	r31, 0x25	; 37
     f60:	df 2e       	mov	r13, r31
     f62:	f0 2d       	mov	r31, r0
     f64:	8b cf       	rjmp	.-234    	; 0xe7c <usart_init_spi+0x306>
	}

	usart_spi_set_baudrate(usart, opt->baudrate, sysclk_get_per_hz());
	usart_tx_enable(usart);
	usart_rx_enable(usart);
}
     f66:	0f 90       	pop	r0
     f68:	df 91       	pop	r29
     f6a:	cf 91       	pop	r28
     f6c:	1f 91       	pop	r17
     f6e:	0f 91       	pop	r16
     f70:	ff 90       	pop	r15
     f72:	ef 90       	pop	r14
     f74:	df 90       	pop	r13
     f76:	08 95       	ret

00000f78 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     f78:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     f7a:	03 96       	adiw	r24, 0x03	; 3
     f7c:	81 83       	std	Z+1, r24	; 0x01
     f7e:	92 83       	std	Z+2, r25	; 0x02

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     f80:	2f ef       	ldi	r18, 0xFF	; 255
     f82:	3f ef       	ldi	r19, 0xFF	; 255
     f84:	23 83       	std	Z+3, r18	; 0x03
     f86:	34 83       	std	Z+4, r19	; 0x04

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     f88:	85 83       	std	Z+5, r24	; 0x05
     f8a:	96 83       	std	Z+6, r25	; 0x06
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     f8c:	87 83       	std	Z+7, r24	; 0x07
     f8e:	90 87       	std	Z+8, r25	; 0x08

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     f90:	10 82       	st	Z, r1
     f92:	08 95       	ret

00000f94 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
     f94:	fc 01       	movw	r30, r24
     f96:	10 86       	std	Z+8, r1	; 0x08
     f98:	11 86       	std	Z+9, r1	; 0x09
     f9a:	08 95       	ret

00000f9c <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     f9c:	cf 93       	push	r28
     f9e:	df 93       	push	r29
     fa0:	9c 01       	movw	r18, r24
     fa2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     fa4:	dc 01       	movw	r26, r24
     fa6:	11 96       	adiw	r26, 0x01	; 1
     fa8:	cd 91       	ld	r28, X+
     faa:	dc 91       	ld	r29, X
     fac:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     fae:	c2 83       	std	Z+2, r28	; 0x02
     fb0:	d3 83       	std	Z+3, r29	; 0x03
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     fb2:	8c 81       	ldd	r24, Y+4	; 0x04
     fb4:	9d 81       	ldd	r25, Y+5	; 0x05
     fb6:	84 83       	std	Z+4, r24	; 0x04
     fb8:	95 83       	std	Z+5, r25	; 0x05

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     fba:	8c 81       	ldd	r24, Y+4	; 0x04
     fbc:	9d 81       	ldd	r25, Y+5	; 0x05
     fbe:	dc 01       	movw	r26, r24
     fc0:	12 96       	adiw	r26, 0x02	; 2
     fc2:	6d 93       	st	X+, r22
     fc4:	7c 93       	st	X, r23
     fc6:	13 97       	sbiw	r26, 0x03	; 3
	pxIndex->pxPrevious = pxNewListItem;
     fc8:	6c 83       	std	Y+4, r22	; 0x04
     fca:	7d 83       	std	Y+5, r23	; 0x05

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
     fcc:	20 87       	std	Z+8, r18	; 0x08
     fce:	31 87       	std	Z+9, r19	; 0x09

	( pxList->uxNumberOfItems )++;
     fd0:	f9 01       	movw	r30, r18
     fd2:	80 81       	ld	r24, Z
     fd4:	8f 5f       	subi	r24, 0xFF	; 255
     fd6:	80 83       	st	Z, r24
}
     fd8:	df 91       	pop	r29
     fda:	cf 91       	pop	r28
     fdc:	08 95       	ret

00000fde <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     fde:	cf 93       	push	r28
     fe0:	df 93       	push	r29
     fe2:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     fe4:	48 81       	ld	r20, Y
     fe6:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     fe8:	4f 3f       	cpi	r20, 0xFF	; 255
     fea:	2f ef       	ldi	r18, 0xFF	; 255
     fec:	52 07       	cpc	r21, r18
     fee:	21 f4       	brne	.+8      	; 0xff8 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     ff0:	fc 01       	movw	r30, r24
     ff2:	a7 81       	ldd	r26, Z+7	; 0x07
     ff4:	b0 85       	ldd	r27, Z+8	; 0x08
     ff6:	0d c0       	rjmp	.+26     	; 0x1012 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
     ff8:	dc 01       	movw	r26, r24
     ffa:	13 96       	adiw	r26, 0x03	; 3
     ffc:	01 c0       	rjmp	.+2      	; 0x1000 <vListInsert+0x22>
     ffe:	df 01       	movw	r26, r30
    1000:	12 96       	adiw	r26, 0x02	; 2
    1002:	ed 91       	ld	r30, X+
    1004:	fc 91       	ld	r31, X
    1006:	13 97       	sbiw	r26, 0x03	; 3
    1008:	20 81       	ld	r18, Z
    100a:	31 81       	ldd	r19, Z+1	; 0x01
    100c:	42 17       	cp	r20, r18
    100e:	53 07       	cpc	r21, r19
    1010:	b0 f7       	brcc	.-20     	; 0xffe <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1012:	12 96       	adiw	r26, 0x02	; 2
    1014:	ed 91       	ld	r30, X+
    1016:	fc 91       	ld	r31, X
    1018:	13 97       	sbiw	r26, 0x03	; 3
    101a:	ea 83       	std	Y+2, r30	; 0x02
    101c:	fb 83       	std	Y+3, r31	; 0x03
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    101e:	c4 83       	std	Z+4, r28	; 0x04
    1020:	d5 83       	std	Z+5, r29	; 0x05
	pxNewListItem->pxPrevious = pxIterator;
    1022:	ac 83       	std	Y+4, r26	; 0x04
    1024:	bd 83       	std	Y+5, r27	; 0x05
	pxIterator->pxNext = pxNewListItem;
    1026:	12 96       	adiw	r26, 0x02	; 2
    1028:	cd 93       	st	X+, r28
    102a:	dc 93       	st	X, r29
    102c:	13 97       	sbiw	r26, 0x03	; 3

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    102e:	88 87       	std	Y+8, r24	; 0x08
    1030:	99 87       	std	Y+9, r25	; 0x09

	( pxList->uxNumberOfItems )++;
    1032:	fc 01       	movw	r30, r24
    1034:	20 81       	ld	r18, Z
    1036:	2f 5f       	subi	r18, 0xFF	; 255
    1038:	20 83       	st	Z, r18
}
    103a:	df 91       	pop	r29
    103c:	cf 91       	pop	r28
    103e:	08 95       	ret

00001040 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1040:	cf 93       	push	r28
    1042:	df 93       	push	r29
    1044:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1046:	a0 85       	ldd	r26, Z+8	; 0x08
    1048:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    104a:	c2 81       	ldd	r28, Z+2	; 0x02
    104c:	d3 81       	ldd	r29, Z+3	; 0x03
    104e:	84 81       	ldd	r24, Z+4	; 0x04
    1050:	95 81       	ldd	r25, Z+5	; 0x05
    1052:	8c 83       	std	Y+4, r24	; 0x04
    1054:	9d 83       	std	Y+5, r25	; 0x05
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1056:	c4 81       	ldd	r28, Z+4	; 0x04
    1058:	d5 81       	ldd	r29, Z+5	; 0x05
    105a:	82 81       	ldd	r24, Z+2	; 0x02
    105c:	93 81       	ldd	r25, Z+3	; 0x03
    105e:	8a 83       	std	Y+2, r24	; 0x02
    1060:	9b 83       	std	Y+3, r25	; 0x03

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1062:	11 96       	adiw	r26, 0x01	; 1
    1064:	8d 91       	ld	r24, X+
    1066:	9c 91       	ld	r25, X
    1068:	12 97       	sbiw	r26, 0x02	; 2
    106a:	e8 17       	cp	r30, r24
    106c:	f9 07       	cpc	r31, r25
    106e:	31 f4       	brne	.+12     	; 0x107c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1070:	84 81       	ldd	r24, Z+4	; 0x04
    1072:	95 81       	ldd	r25, Z+5	; 0x05
    1074:	11 96       	adiw	r26, 0x01	; 1
    1076:	8d 93       	st	X+, r24
    1078:	9c 93       	st	X, r25
    107a:	12 97       	sbiw	r26, 0x02	; 2
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    107c:	10 86       	std	Z+8, r1	; 0x08
    107e:	11 86       	std	Z+9, r1	; 0x09
	( pxList->uxNumberOfItems )--;
    1080:	8c 91       	ld	r24, X
    1082:	81 50       	subi	r24, 0x01	; 1
    1084:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1086:	8c 91       	ld	r24, X
}
    1088:	df 91       	pop	r29
    108a:	cf 91       	pop	r28
    108c:	08 95       	ret

0000108e <pxPortInitialiseStack>:

/*
 * See header file for description.
 */
StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
{
    108e:	0f 93       	push	r16
    1090:	1f 93       	push	r17
    1092:	8b 01       	movw	r16, r22
uint16_t usAddress;

    /* Place a few bytes of known values on the bottom of the stack.
    This is just useful for debugging. */

    *pxTopOfStack = 0x11;
    1094:	71 e1       	ldi	r23, 0x11	; 17
    1096:	fc 01       	movw	r30, r24
    1098:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = 0x22;
    109a:	31 97       	sbiw	r30, 0x01	; 1
    109c:	62 e2       	ldi	r22, 0x22	; 34
    109e:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = 0x33;
    10a0:	31 97       	sbiw	r30, 0x01	; 1
    10a2:	23 e3       	ldi	r18, 0x33	; 51
    10a4:	20 83       	st	Z, r18

    /*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

    /* The start of the task code will be popped off the stack last, so place
    it on first. */
    ulAddress = ( uint32_t ) pxCode;
    10a6:	01 2e       	mov	r0, r17
    10a8:	00 0c       	add	r0, r0
    10aa:	22 0b       	sbc	r18, r18
    10ac:	33 0b       	sbc	r19, r19
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    10ae:	31 97       	sbiw	r30, 0x01	; 1
    10b0:	00 83       	st	Z, r16
    pxTopOfStack--;

    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    10b2:	31 97       	sbiw	r30, 0x01	; 1
    10b4:	10 83       	st	Z, r17
    pxTopOfStack--;

#ifdef __AVR_3_BYTE_PC__
    ulAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( ulAddress & ( uint32_t ) 0x000000ff );
    10b6:	31 97       	sbiw	r30, 0x01	; 1
    10b8:	20 83       	st	Z, r18

    /* Next simulate the stack as if after a call to portSAVE_CONTEXT().
    portSAVE_CONTEXT places the flags on the stack immediately after r0
    to ensure the interrupts get disabled as soon as possible, and so ensuring
    the stack use is minimal should a context switch interrupt occur. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R0 */
    10ba:	31 97       	sbiw	r30, 0x01	; 1
    10bc:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = portFLAGS_INT_ENABLED;
    10be:	31 97       	sbiw	r30, 0x01	; 1
    10c0:	20 e8       	ldi	r18, 0x80	; 128
    10c2:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Now the remaining registers.   The compiler expects R1 to be 0. */
    *pxTopOfStack = ( StackType_t ) 0x00;   /* R1 */
    10c4:	31 97       	sbiw	r30, 0x01	; 1
    10c6:	10 82       	st	Z, r1
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x02;   /* R2 */
    10c8:	31 97       	sbiw	r30, 0x01	; 1
    10ca:	22 e0       	ldi	r18, 0x02	; 2
    10cc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x03;   /* R3 */
    10ce:	31 97       	sbiw	r30, 0x01	; 1
    10d0:	23 e0       	ldi	r18, 0x03	; 3
    10d2:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x04;   /* R4 */
    10d4:	31 97       	sbiw	r30, 0x01	; 1
    10d6:	24 e0       	ldi	r18, 0x04	; 4
    10d8:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x05;   /* R5 */
    10da:	31 97       	sbiw	r30, 0x01	; 1
    10dc:	25 e0       	ldi	r18, 0x05	; 5
    10de:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x06;   /* R6 */
    10e0:	31 97       	sbiw	r30, 0x01	; 1
    10e2:	26 e0       	ldi	r18, 0x06	; 6
    10e4:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x07;   /* R7 */
    10e6:	31 97       	sbiw	r30, 0x01	; 1
    10e8:	27 e0       	ldi	r18, 0x07	; 7
    10ea:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x08;   /* R8 */
    10ec:	31 97       	sbiw	r30, 0x01	; 1
    10ee:	28 e0       	ldi	r18, 0x08	; 8
    10f0:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x09;   /* R9 */
    10f2:	31 97       	sbiw	r30, 0x01	; 1
    10f4:	29 e0       	ldi	r18, 0x09	; 9
    10f6:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x10;   /* R10 */
    10f8:	31 97       	sbiw	r30, 0x01	; 1
    10fa:	20 e1       	ldi	r18, 0x10	; 16
    10fc:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x11;   /* R11 */
    10fe:	31 97       	sbiw	r30, 0x01	; 1
    1100:	70 83       	st	Z, r23
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x12;   /* R12 */
    1102:	31 97       	sbiw	r30, 0x01	; 1
    1104:	22 e1       	ldi	r18, 0x12	; 18
    1106:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x13;   /* R13 */
    1108:	31 97       	sbiw	r30, 0x01	; 1
    110a:	23 e1       	ldi	r18, 0x13	; 19
    110c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x14;   /* R14 */
    110e:	31 97       	sbiw	r30, 0x01	; 1
    1110:	24 e1       	ldi	r18, 0x14	; 20
    1112:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x15;   /* R15 */
    1114:	31 97       	sbiw	r30, 0x01	; 1
    1116:	25 e1       	ldi	r18, 0x15	; 21
    1118:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x16;   /* R16 */
    111a:	31 97       	sbiw	r30, 0x01	; 1
    111c:	26 e1       	ldi	r18, 0x16	; 22
    111e:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x17;   /* R17 */
    1120:	31 97       	sbiw	r30, 0x01	; 1
    1122:	27 e1       	ldi	r18, 0x17	; 23
    1124:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x18;   /* R18 */
    1126:	31 97       	sbiw	r30, 0x01	; 1
    1128:	28 e1       	ldi	r18, 0x18	; 24
    112a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x19;   /* R19 */
    112c:	31 97       	sbiw	r30, 0x01	; 1
    112e:	29 e1       	ldi	r18, 0x19	; 25
    1130:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x20;   /* R20 */
    1132:	31 97       	sbiw	r30, 0x01	; 1
    1134:	20 e2       	ldi	r18, 0x20	; 32
    1136:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x21;   /* R21 */
    1138:	31 97       	sbiw	r30, 0x01	; 1
    113a:	21 e2       	ldi	r18, 0x21	; 33
    113c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x22;   /* R22 */
    113e:	31 97       	sbiw	r30, 0x01	; 1
    1140:	60 83       	st	Z, r22
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x23;   /* R23 */
    1142:	31 97       	sbiw	r30, 0x01	; 1
    1144:	23 e2       	ldi	r18, 0x23	; 35
    1146:	20 83       	st	Z, r18
    pxTopOfStack--;

    /* Place the parameter on the stack in the expected location. */
    usAddress = ( uint16_t ) pvParameters;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    1148:	31 97       	sbiw	r30, 0x01	; 1
    114a:	40 83       	st	Z, r20
    pxTopOfStack--;

    usAddress >>= 8;
    *pxTopOfStack = ( StackType_t ) ( usAddress & ( uint32_t ) 0x000000ff );
    114c:	31 97       	sbiw	r30, 0x01	; 1
    114e:	50 83       	st	Z, r21
    pxTopOfStack--;

    *pxTopOfStack = ( StackType_t ) 0x26;   /* R26 X */
    1150:	31 97       	sbiw	r30, 0x01	; 1
    1152:	26 e2       	ldi	r18, 0x26	; 38
    1154:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x27;   /* R27 */
    1156:	31 97       	sbiw	r30, 0x01	; 1
    1158:	27 e2       	ldi	r18, 0x27	; 39
    115a:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x28;   /* R28 Y */
    115c:	31 97       	sbiw	r30, 0x01	; 1
    115e:	28 e2       	ldi	r18, 0x28	; 40
    1160:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x29;   /* R29 */
    1162:	31 97       	sbiw	r30, 0x01	; 1
    1164:	29 e2       	ldi	r18, 0x29	; 41
    1166:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x30;   /* R30 Z */
    1168:	31 97       	sbiw	r30, 0x01	; 1
    116a:	20 e3       	ldi	r18, 0x30	; 48
    116c:	20 83       	st	Z, r18
    pxTopOfStack--;
    *pxTopOfStack = ( StackType_t ) 0x31;   /* R31 */
    116e:	31 97       	sbiw	r30, 0x01	; 1
    1170:	21 e3       	ldi	r18, 0x31	; 49
    1172:	20 83       	st	Z, r18
    pxTopOfStack--;

    /*lint +e950 +e611 +e923 */

    return pxTopOfStack;
}
    1174:	87 97       	sbiw	r24, 0x27	; 39
    1176:	1f 91       	pop	r17
    1178:	0f 91       	pop	r16
    117a:	08 95       	ret

0000117c <xPortStartScheduler>:
 * Setup timer generate a tick interrupt.
 */
static void prvSetupTimerInterrupt(void)
{
    // disable global interrupt for a moment
    cli();
    117c:	f8 94       	cli

    {
        //enable TC0 clock source, high resolution
        PR.PRPC &= ~(PR_TC0_bm | PR_HIRES_bm);
    117e:	e0 e7       	ldi	r30, 0x70	; 112
    1180:	f0 e0       	ldi	r31, 0x00	; 0
    1182:	83 81       	ldd	r24, Z+3	; 0x03
    1184:	8a 7f       	andi	r24, 0xFA	; 250
    1186:	83 83       	std	Z+3, r24	; 0x03

        //set period of counter
        TCC0.PER = configCPU_CLOCK_HZ / configTICK_RATE_HZ / 1;
    1188:	e0 e0       	ldi	r30, 0x00	; 0
    118a:	f8 e0       	ldi	r31, 0x08	; 8
    118c:	80 e0       	ldi	r24, 0x00	; 0
    118e:	9a ef       	ldi	r25, 0xFA	; 250
    1190:	86 a3       	std	Z+38, r24	; 0x26
    1192:	97 a3       	std	Z+39, r25	; 0x27

        //enable interrupt and set low level
        TCC0.INTCTRLA = TC_OVFINTLVL_LO_gc;
    1194:	91 e0       	ldi	r25, 0x01	; 1
    1196:	96 83       	std	Z+6, r25	; 0x06

        //enable low-level interrupt
        PMIC.CTRL |= PMIC_LOLVLEN_bm;
    1198:	a0 ea       	ldi	r26, 0xA0	; 160
    119a:	b0 e0       	ldi	r27, 0x00	; 0
    119c:	12 96       	adiw	r26, 0x02	; 2
    119e:	8c 91       	ld	r24, X
    11a0:	12 97       	sbiw	r26, 0x02	; 2
    11a2:	81 60       	ori	r24, 0x01	; 1
    11a4:	12 96       	adiw	r26, 0x02	; 2
    11a6:	8c 93       	st	X, r24

        //select (start) the clock source
        TCC0.CTRLA = TC_CLKSEL_DIV1_gc;
    11a8:	90 83       	st	Z, r25

    }

    // enable global interrupt
    sei();
    11aa:	78 94       	sei
{
    /* Setup the hardware to generate the tick. */
    prvSetupTimerInterrupt();

    /* Restore the context of the first task that is going to run. */
    portRESTORE_CONTEXT();
    11ac:	a0 91 b1 22 	lds	r26, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    11b0:	b0 91 b2 22 	lds	r27, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    11b4:	0d 90       	ld	r0, X+
    11b6:	0d be       	out	0x3d, r0	; 61
    11b8:	0d 90       	ld	r0, X+
    11ba:	0e be       	out	0x3e, r0	; 62
    11bc:	ff 91       	pop	r31
    11be:	ef 91       	pop	r30
    11c0:	df 91       	pop	r29
    11c2:	cf 91       	pop	r28
    11c4:	bf 91       	pop	r27
    11c6:	af 91       	pop	r26
    11c8:	9f 91       	pop	r25
    11ca:	8f 91       	pop	r24
    11cc:	7f 91       	pop	r23
    11ce:	6f 91       	pop	r22
    11d0:	5f 91       	pop	r21
    11d2:	4f 91       	pop	r20
    11d4:	3f 91       	pop	r19
    11d6:	2f 91       	pop	r18
    11d8:	1f 91       	pop	r17
    11da:	0f 91       	pop	r16
    11dc:	ff 90       	pop	r15
    11de:	ef 90       	pop	r14
    11e0:	df 90       	pop	r13
    11e2:	cf 90       	pop	r12
    11e4:	bf 90       	pop	r11
    11e6:	af 90       	pop	r10
    11e8:	9f 90       	pop	r9
    11ea:	8f 90       	pop	r8
    11ec:	7f 90       	pop	r7
    11ee:	6f 90       	pop	r6
    11f0:	5f 90       	pop	r5
    11f2:	4f 90       	pop	r4
    11f4:	3f 90       	pop	r3
    11f6:	2f 90       	pop	r2
    11f8:	1f 90       	pop	r1
    11fa:	0f 90       	pop	r0
    11fc:	0f be       	out	0x3f, r0	; 63
    11fe:	0f 90       	pop	r0

    /* Simulate a function call end as generated by the compiler.  We will now
    jump to the start of the task the context of which we have just restored. */
    asm volatile ( "ret" );
    1200:	08 95       	ret

    /* Should not get here. */
    return pdTRUE;
}
    1202:	81 e0       	ldi	r24, 0x01	; 1
    1204:	08 95       	ret

00001206 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
    portSAVE_CONTEXT();
    1206:	0f 92       	push	r0
    1208:	0f b6       	in	r0, 0x3f	; 63
    120a:	f8 94       	cli
    120c:	0f 92       	push	r0
    120e:	1f 92       	push	r1
    1210:	11 24       	eor	r1, r1
    1212:	2f 92       	push	r2
    1214:	3f 92       	push	r3
    1216:	4f 92       	push	r4
    1218:	5f 92       	push	r5
    121a:	6f 92       	push	r6
    121c:	7f 92       	push	r7
    121e:	8f 92       	push	r8
    1220:	9f 92       	push	r9
    1222:	af 92       	push	r10
    1224:	bf 92       	push	r11
    1226:	cf 92       	push	r12
    1228:	df 92       	push	r13
    122a:	ef 92       	push	r14
    122c:	ff 92       	push	r15
    122e:	0f 93       	push	r16
    1230:	1f 93       	push	r17
    1232:	2f 93       	push	r18
    1234:	3f 93       	push	r19
    1236:	4f 93       	push	r20
    1238:	5f 93       	push	r21
    123a:	6f 93       	push	r22
    123c:	7f 93       	push	r23
    123e:	8f 93       	push	r24
    1240:	9f 93       	push	r25
    1242:	af 93       	push	r26
    1244:	bf 93       	push	r27
    1246:	cf 93       	push	r28
    1248:	df 93       	push	r29
    124a:	ef 93       	push	r30
    124c:	ff 93       	push	r31
    124e:	a0 91 b1 22 	lds	r26, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    1252:	b0 91 b2 22 	lds	r27, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    1256:	0d b6       	in	r0, 0x3d	; 61
    1258:	0d 92       	st	X+, r0
    125a:	0e b6       	in	r0, 0x3e	; 62
    125c:	0d 92       	st	X+, r0
    vTaskSwitchContext();
    125e:	7e d6       	rcall	.+3324   	; 0x1f5c <vTaskSwitchContext>
    portRESTORE_CONTEXT();
    1260:	a0 91 b1 22 	lds	r26, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    1264:	b0 91 b2 22 	lds	r27, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    1268:	0d 90       	ld	r0, X+
    126a:	0d be       	out	0x3d, r0	; 61
    126c:	0d 90       	ld	r0, X+
    126e:	0e be       	out	0x3e, r0	; 62
    1270:	ff 91       	pop	r31
    1272:	ef 91       	pop	r30
    1274:	df 91       	pop	r29
    1276:	cf 91       	pop	r28
    1278:	bf 91       	pop	r27
    127a:	af 91       	pop	r26
    127c:	9f 91       	pop	r25
    127e:	8f 91       	pop	r24
    1280:	7f 91       	pop	r23
    1282:	6f 91       	pop	r22
    1284:	5f 91       	pop	r21
    1286:	4f 91       	pop	r20
    1288:	3f 91       	pop	r19
    128a:	2f 91       	pop	r18
    128c:	1f 91       	pop	r17
    128e:	0f 91       	pop	r16
    1290:	ff 90       	pop	r15
    1292:	ef 90       	pop	r14
    1294:	df 90       	pop	r13
    1296:	cf 90       	pop	r12
    1298:	bf 90       	pop	r11
    129a:	af 90       	pop	r10
    129c:	9f 90       	pop	r9
    129e:	8f 90       	pop	r8
    12a0:	7f 90       	pop	r7
    12a2:	6f 90       	pop	r6
    12a4:	5f 90       	pop	r5
    12a6:	4f 90       	pop	r4
    12a8:	3f 90       	pop	r3
    12aa:	2f 90       	pop	r2
    12ac:	1f 90       	pop	r1
    12ae:	0f 90       	pop	r0
    12b0:	0f be       	out	0x3f, r0	; 63
    12b2:	0f 90       	pop	r0

    asm volatile ( "ret" );
    12b4:	08 95       	ret

000012b6 <__vector_14>:
         * Context switch function used by the tick.  This must be identical to
         * vPortYield() from the call to vTaskSwitchContext() onwards.  The only
         * difference from vPortYield() is the tick count is incremented as the
         * call comes from the tick ISR.
         */
        portSAVE_CONTEXT();
    12b6:	0f 92       	push	r0
    12b8:	0f b6       	in	r0, 0x3f	; 63
    12ba:	f8 94       	cli
    12bc:	0f 92       	push	r0
    12be:	1f 92       	push	r1
    12c0:	11 24       	eor	r1, r1
    12c2:	2f 92       	push	r2
    12c4:	3f 92       	push	r3
    12c6:	4f 92       	push	r4
    12c8:	5f 92       	push	r5
    12ca:	6f 92       	push	r6
    12cc:	7f 92       	push	r7
    12ce:	8f 92       	push	r8
    12d0:	9f 92       	push	r9
    12d2:	af 92       	push	r10
    12d4:	bf 92       	push	r11
    12d6:	cf 92       	push	r12
    12d8:	df 92       	push	r13
    12da:	ef 92       	push	r14
    12dc:	ff 92       	push	r15
    12de:	0f 93       	push	r16
    12e0:	1f 93       	push	r17
    12e2:	2f 93       	push	r18
    12e4:	3f 93       	push	r19
    12e6:	4f 93       	push	r20
    12e8:	5f 93       	push	r21
    12ea:	6f 93       	push	r22
    12ec:	7f 93       	push	r23
    12ee:	8f 93       	push	r24
    12f0:	9f 93       	push	r25
    12f2:	af 93       	push	r26
    12f4:	bf 93       	push	r27
    12f6:	cf 93       	push	r28
    12f8:	df 93       	push	r29
    12fa:	ef 93       	push	r30
    12fc:	ff 93       	push	r31
    12fe:	a0 91 b1 22 	lds	r26, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    1302:	b0 91 b2 22 	lds	r27, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    1306:	0d b6       	in	r0, 0x3d	; 61
    1308:	0d 92       	st	X+, r0
    130a:	0e b6       	in	r0, 0x3e	; 62
    130c:	0d 92       	st	X+, r0
        if( xTaskIncrementTick() != pdFALSE )
    130e:	e1 d4       	rcall	.+2498   	; 0x1cd2 <xTaskIncrementTick>
    1310:	81 11       	cpse	r24, r1
        {
            vTaskSwitchContext();
    1312:	24 d6       	rcall	.+3144   	; 0x1f5c <vTaskSwitchContext>
    1314:	a0 91 b1 22 	lds	r26, 0x22B1	; 0x8022b1 <pxCurrentTCB>
        }
        portRESTORE_CONTEXT();
    1318:	b0 91 b2 22 	lds	r27, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    131c:	0d 90       	ld	r0, X+
    131e:	0d be       	out	0x3d, r0	; 61
    1320:	0d 90       	ld	r0, X+
    1322:	0e be       	out	0x3e, r0	; 62
    1324:	ff 91       	pop	r31
    1326:	ef 91       	pop	r30
    1328:	df 91       	pop	r29
    132a:	cf 91       	pop	r28
    132c:	bf 91       	pop	r27
    132e:	af 91       	pop	r26
    1330:	9f 91       	pop	r25
    1332:	8f 91       	pop	r24
    1334:	7f 91       	pop	r23
    1336:	6f 91       	pop	r22
    1338:	5f 91       	pop	r21
    133a:	4f 91       	pop	r20
    133c:	3f 91       	pop	r19
    133e:	2f 91       	pop	r18
    1340:	1f 91       	pop	r17
    1342:	0f 91       	pop	r16
    1344:	ff 90       	pop	r15
    1346:	ef 90       	pop	r14
    1348:	df 90       	pop	r13
    134a:	cf 90       	pop	r12
    134c:	bf 90       	pop	r11
    134e:	af 90       	pop	r10
    1350:	9f 90       	pop	r9
    1352:	8f 90       	pop	r8
    1354:	7f 90       	pop	r7
    1356:	6f 90       	pop	r6
    1358:	5f 90       	pop	r5
    135a:	4f 90       	pop	r4
    135c:	3f 90       	pop	r3
    135e:	2f 90       	pop	r2
    1360:	1f 90       	pop	r1
    1362:	0f 90       	pop	r0
    1364:	0f be       	out	0x3f, r0	; 63
    1366:	0f 90       	pop	r0
    1368:	18 95       	reti

0000136a <pvPortMalloc>:
#endif

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    136a:	cf 93       	push	r28
    136c:	df 93       	push	r29
    136e:	ec 01       	movw	r28, r24
void *pvReturn;

	vTaskSuspendAll();
    1370:	a0 d4       	rcall	.+2368   	; 0x1cb2 <vTaskSuspendAll>
	{
		pvReturn = malloc( xWantedSize );
    1372:	ce 01       	movw	r24, r28
    1374:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <malloc>
		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1378:	ec 01       	movw	r28, r24
    137a:	63 d5       	rcall	.+2758   	; 0x1e42 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    137c:	ce 01       	movw	r24, r28
    137e:	df 91       	pop	r29
    1380:	cf 91       	pop	r28
    1382:	08 95       	ret

00001384 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1384:	cf 93       	push	r28
    1386:	df 93       	push	r29
	if( pv )
    1388:	00 97       	sbiw	r24, 0x00	; 0
    138a:	31 f0       	breq	.+12     	; 0x1398 <vPortFree+0x14>
    138c:	ec 01       	movw	r28, r24
	{
		vTaskSuspendAll();
    138e:	91 d4       	rcall	.+2338   	; 0x1cb2 <vTaskSuspendAll>
		{
			free( pv );
    1390:	ce 01       	movw	r24, r28
    1392:	0e 94 d6 17 	call	0x2fac	; 0x2fac <free>
			traceFREE( pv, 0 );
		}
		( void ) xTaskResumeAll();
    1396:	55 d5       	rcall	.+2730   	; 0x1e42 <xTaskResumeAll>
	}
}
    1398:	df 91       	pop	r29
    139a:	cf 91       	pop	r28
    139c:	08 95       	ret

0000139e <prvIsQueueEmpty>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    139e:	0f b6       	in	r0, 0x3f	; 63
    13a0:	f8 94       	cli
    13a2:	0f 92       	push	r0
    13a4:	fc 01       	movw	r30, r24
    13a6:	92 8d       	ldd	r25, Z+26	; 0x1a
    13a8:	0f 90       	pop	r0
    13aa:	0f be       	out	0x3f, r0	; 63
    13ac:	81 e0       	ldi	r24, 0x01	; 1
    13ae:	91 11       	cpse	r25, r1
    13b0:	80 e0       	ldi	r24, 0x00	; 0
    13b2:	08 95       	ret

000013b4 <prvCopyDataToQueue>:
    13b4:	0f 93       	push	r16
    13b6:	1f 93       	push	r17
    13b8:	cf 93       	push	r28
    13ba:	df 93       	push	r29
    13bc:	ec 01       	movw	r28, r24
    13be:	04 2f       	mov	r16, r20
    13c0:	1a 8d       	ldd	r17, Y+26	; 0x1a
    13c2:	4c 8d       	ldd	r20, Y+28	; 0x1c
    13c4:	44 23       	and	r20, r20
    13c6:	b9 f1       	breq	.+110    	; 0x1436 <prvCopyDataToQueue+0x82>
    13c8:	01 11       	cpse	r16, r1
    13ca:	16 c0       	rjmp	.+44     	; 0x13f8 <prvCopyDataToQueue+0x44>
    13cc:	50 e0       	ldi	r21, 0x00	; 0
    13ce:	8a 81       	ldd	r24, Y+2	; 0x02
    13d0:	9b 81       	ldd	r25, Y+3	; 0x03
    13d2:	0e 94 5f 18 	call	0x30be	; 0x30be <memcpy>
    13d6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    13d8:	8a 81       	ldd	r24, Y+2	; 0x02
    13da:	9b 81       	ldd	r25, Y+3	; 0x03
    13dc:	82 0f       	add	r24, r18
    13de:	91 1d       	adc	r25, r1
    13e0:	8a 83       	std	Y+2, r24	; 0x02
    13e2:	9b 83       	std	Y+3, r25	; 0x03
    13e4:	2c 81       	ldd	r18, Y+4	; 0x04
    13e6:	3d 81       	ldd	r19, Y+5	; 0x05
    13e8:	82 17       	cp	r24, r18
    13ea:	93 07       	cpc	r25, r19
    13ec:	20 f1       	brcs	.+72     	; 0x1436 <prvCopyDataToQueue+0x82>
    13ee:	88 81       	ld	r24, Y
    13f0:	99 81       	ldd	r25, Y+1	; 0x01
    13f2:	8a 83       	std	Y+2, r24	; 0x02
    13f4:	9b 83       	std	Y+3, r25	; 0x03
    13f6:	1f c0       	rjmp	.+62     	; 0x1436 <prvCopyDataToQueue+0x82>
    13f8:	50 e0       	ldi	r21, 0x00	; 0
    13fa:	8e 81       	ldd	r24, Y+6	; 0x06
    13fc:	9f 81       	ldd	r25, Y+7	; 0x07
    13fe:	0e 94 5f 18 	call	0x30be	; 0x30be <memcpy>
    1402:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1404:	90 e0       	ldi	r25, 0x00	; 0
    1406:	91 95       	neg	r25
    1408:	81 95       	neg	r24
    140a:	91 09       	sbc	r25, r1
    140c:	2e 81       	ldd	r18, Y+6	; 0x06
    140e:	3f 81       	ldd	r19, Y+7	; 0x07
    1410:	28 0f       	add	r18, r24
    1412:	39 1f       	adc	r19, r25
    1414:	2e 83       	std	Y+6, r18	; 0x06
    1416:	3f 83       	std	Y+7, r19	; 0x07
    1418:	48 81       	ld	r20, Y
    141a:	59 81       	ldd	r21, Y+1	; 0x01
    141c:	24 17       	cp	r18, r20
    141e:	35 07       	cpc	r19, r21
    1420:	30 f4       	brcc	.+12     	; 0x142e <prvCopyDataToQueue+0x7a>
    1422:	2c 81       	ldd	r18, Y+4	; 0x04
    1424:	3d 81       	ldd	r19, Y+5	; 0x05
    1426:	82 0f       	add	r24, r18
    1428:	93 1f       	adc	r25, r19
    142a:	8e 83       	std	Y+6, r24	; 0x06
    142c:	9f 83       	std	Y+7, r25	; 0x07
    142e:	02 30       	cpi	r16, 0x02	; 2
    1430:	11 f4       	brne	.+4      	; 0x1436 <prvCopyDataToQueue+0x82>
    1432:	11 11       	cpse	r17, r1
    1434:	11 50       	subi	r17, 0x01	; 1
    1436:	1f 5f       	subi	r17, 0xFF	; 255
    1438:	1a 8f       	std	Y+26, r17	; 0x1a
    143a:	80 e0       	ldi	r24, 0x00	; 0
    143c:	df 91       	pop	r29
    143e:	cf 91       	pop	r28
    1440:	1f 91       	pop	r17
    1442:	0f 91       	pop	r16
    1444:	08 95       	ret

00001446 <prvCopyDataFromQueue>:
    1446:	fc 01       	movw	r30, r24
    1448:	44 8d       	ldd	r20, Z+28	; 0x1c
    144a:	44 23       	and	r20, r20
    144c:	a9 f0       	breq	.+42     	; 0x1478 <prvCopyDataFromQueue+0x32>
    144e:	50 e0       	ldi	r21, 0x00	; 0
    1450:	26 81       	ldd	r18, Z+6	; 0x06
    1452:	37 81       	ldd	r19, Z+7	; 0x07
    1454:	24 0f       	add	r18, r20
    1456:	35 1f       	adc	r19, r21
    1458:	26 83       	std	Z+6, r18	; 0x06
    145a:	37 83       	std	Z+7, r19	; 0x07
    145c:	84 81       	ldd	r24, Z+4	; 0x04
    145e:	95 81       	ldd	r25, Z+5	; 0x05
    1460:	28 17       	cp	r18, r24
    1462:	39 07       	cpc	r19, r25
    1464:	20 f0       	brcs	.+8      	; 0x146e <prvCopyDataFromQueue+0x28>
    1466:	80 81       	ld	r24, Z
    1468:	91 81       	ldd	r25, Z+1	; 0x01
    146a:	86 83       	std	Z+6, r24	; 0x06
    146c:	97 83       	std	Z+7, r25	; 0x07
    146e:	cb 01       	movw	r24, r22
    1470:	66 81       	ldd	r22, Z+6	; 0x06
    1472:	77 81       	ldd	r23, Z+7	; 0x07
    1474:	0c 94 5f 18 	jmp	0x30be	; 0x30be <memcpy>
    1478:	08 95       	ret

0000147a <prvUnlockQueue>:
    147a:	ef 92       	push	r14
    147c:	ff 92       	push	r15
    147e:	0f 93       	push	r16
    1480:	1f 93       	push	r17
    1482:	cf 93       	push	r28
    1484:	8c 01       	movw	r16, r24
    1486:	0f b6       	in	r0, 0x3f	; 63
    1488:	f8 94       	cli
    148a:	0f 92       	push	r0
    148c:	fc 01       	movw	r30, r24
    148e:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1490:	1c 16       	cp	r1, r28
    1492:	9c f4       	brge	.+38     	; 0x14ba <prvUnlockQueue+0x40>
    1494:	81 89       	ldd	r24, Z+17	; 0x11
    1496:	81 11       	cpse	r24, r1
    1498:	06 c0       	rjmp	.+12     	; 0x14a6 <prvUnlockQueue+0x2c>
    149a:	0f c0       	rjmp	.+30     	; 0x14ba <prvUnlockQueue+0x40>
    149c:	f8 01       	movw	r30, r16
    149e:	81 89       	ldd	r24, Z+17	; 0x11
    14a0:	81 11       	cpse	r24, r1
    14a2:	05 c0       	rjmp	.+10     	; 0x14ae <prvUnlockQueue+0x34>
    14a4:	0a c0       	rjmp	.+20     	; 0x14ba <prvUnlockQueue+0x40>
    14a6:	78 01       	movw	r14, r16
    14a8:	f1 e1       	ldi	r31, 0x11	; 17
    14aa:	ef 0e       	add	r14, r31
    14ac:	f1 1c       	adc	r15, r1
    14ae:	c7 01       	movw	r24, r14
    14b0:	e4 d5       	rcall	.+3016   	; 0x207a <xTaskRemoveFromEventList>
    14b2:	81 11       	cpse	r24, r1
    14b4:	60 d6       	rcall	.+3264   	; 0x2176 <vTaskMissedYield>
    14b6:	c1 50       	subi	r28, 0x01	; 1
    14b8:	89 f7       	brne	.-30     	; 0x149c <prvUnlockQueue+0x22>
    14ba:	8f ef       	ldi	r24, 0xFF	; 255
    14bc:	f8 01       	movw	r30, r16
    14be:	86 8f       	std	Z+30, r24	; 0x1e
    14c0:	0f 90       	pop	r0
    14c2:	0f be       	out	0x3f, r0	; 63
    14c4:	0f b6       	in	r0, 0x3f	; 63
    14c6:	f8 94       	cli
    14c8:	0f 92       	push	r0
    14ca:	c5 8d       	ldd	r28, Z+29	; 0x1d
    14cc:	1c 16       	cp	r1, r28
    14ce:	9c f4       	brge	.+38     	; 0x14f6 <prvUnlockQueue+0x7c>
    14d0:	80 85       	ldd	r24, Z+8	; 0x08
    14d2:	81 11       	cpse	r24, r1
    14d4:	06 c0       	rjmp	.+12     	; 0x14e2 <prvUnlockQueue+0x68>
    14d6:	0f c0       	rjmp	.+30     	; 0x14f6 <prvUnlockQueue+0x7c>
    14d8:	f8 01       	movw	r30, r16
    14da:	80 85       	ldd	r24, Z+8	; 0x08
    14dc:	81 11       	cpse	r24, r1
    14de:	05 c0       	rjmp	.+10     	; 0x14ea <prvUnlockQueue+0x70>
    14e0:	0a c0       	rjmp	.+20     	; 0x14f6 <prvUnlockQueue+0x7c>
    14e2:	78 01       	movw	r14, r16
    14e4:	f8 e0       	ldi	r31, 0x08	; 8
    14e6:	ef 0e       	add	r14, r31
    14e8:	f1 1c       	adc	r15, r1
    14ea:	c7 01       	movw	r24, r14
    14ec:	c6 d5       	rcall	.+2956   	; 0x207a <xTaskRemoveFromEventList>
    14ee:	81 11       	cpse	r24, r1
    14f0:	42 d6       	rcall	.+3204   	; 0x2176 <vTaskMissedYield>
    14f2:	c1 50       	subi	r28, 0x01	; 1
    14f4:	89 f7       	brne	.-30     	; 0x14d8 <prvUnlockQueue+0x5e>
    14f6:	8f ef       	ldi	r24, 0xFF	; 255
    14f8:	f8 01       	movw	r30, r16
    14fa:	85 8f       	std	Z+29, r24	; 0x1d
    14fc:	0f 90       	pop	r0
    14fe:	0f be       	out	0x3f, r0	; 63
    1500:	cf 91       	pop	r28
    1502:	1f 91       	pop	r17
    1504:	0f 91       	pop	r16
    1506:	ff 90       	pop	r15
    1508:	ef 90       	pop	r14
    150a:	08 95       	ret

0000150c <xQueueGenericReset>:
    150c:	cf 93       	push	r28
    150e:	df 93       	push	r29
    1510:	ec 01       	movw	r28, r24
    1512:	0f b6       	in	r0, 0x3f	; 63
    1514:	f8 94       	cli
    1516:	0f 92       	push	r0
    1518:	e8 81       	ld	r30, Y
    151a:	f9 81       	ldd	r31, Y+1	; 0x01
    151c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    151e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1520:	90 e0       	ldi	r25, 0x00	; 0
    1522:	30 e0       	ldi	r19, 0x00	; 0
    1524:	82 9f       	mul	r24, r18
    1526:	a0 01       	movw	r20, r0
    1528:	83 9f       	mul	r24, r19
    152a:	50 0d       	add	r21, r0
    152c:	92 9f       	mul	r25, r18
    152e:	50 0d       	add	r21, r0
    1530:	11 24       	eor	r1, r1
    1532:	4e 0f       	add	r20, r30
    1534:	5f 1f       	adc	r21, r31
    1536:	4c 83       	std	Y+4, r20	; 0x04
    1538:	5d 83       	std	Y+5, r21	; 0x05
    153a:	1a 8e       	std	Y+26, r1	; 0x1a
    153c:	ea 83       	std	Y+2, r30	; 0x02
    153e:	fb 83       	std	Y+3, r31	; 0x03
    1540:	01 97       	sbiw	r24, 0x01	; 1
    1542:	82 9f       	mul	r24, r18
    1544:	a0 01       	movw	r20, r0
    1546:	83 9f       	mul	r24, r19
    1548:	50 0d       	add	r21, r0
    154a:	92 9f       	mul	r25, r18
    154c:	50 0d       	add	r21, r0
    154e:	11 24       	eor	r1, r1
    1550:	cf 01       	movw	r24, r30
    1552:	84 0f       	add	r24, r20
    1554:	95 1f       	adc	r25, r21
    1556:	8e 83       	std	Y+6, r24	; 0x06
    1558:	9f 83       	std	Y+7, r25	; 0x07
    155a:	8f ef       	ldi	r24, 0xFF	; 255
    155c:	8d 8f       	std	Y+29, r24	; 0x1d
    155e:	8e 8f       	std	Y+30, r24	; 0x1e
    1560:	61 11       	cpse	r22, r1
    1562:	0a c0       	rjmp	.+20     	; 0x1578 <xQueueGenericReset+0x6c>
    1564:	88 85       	ldd	r24, Y+8	; 0x08
    1566:	88 23       	and	r24, r24
    1568:	69 f0       	breq	.+26     	; 0x1584 <xQueueGenericReset+0x78>
    156a:	ce 01       	movw	r24, r28
    156c:	08 96       	adiw	r24, 0x08	; 8
    156e:	85 d5       	rcall	.+2826   	; 0x207a <xTaskRemoveFromEventList>
    1570:	88 23       	and	r24, r24
    1572:	41 f0       	breq	.+16     	; 0x1584 <xQueueGenericReset+0x78>
    1574:	48 de       	rcall	.-880    	; 0x1206 <vPortYield>
    1576:	06 c0       	rjmp	.+12     	; 0x1584 <xQueueGenericReset+0x78>
    1578:	ce 01       	movw	r24, r28
    157a:	08 96       	adiw	r24, 0x08	; 8
    157c:	fd dc       	rcall	.-1542   	; 0xf78 <vListInitialise>
    157e:	ce 01       	movw	r24, r28
    1580:	41 96       	adiw	r24, 0x11	; 17
    1582:	fa dc       	rcall	.-1548   	; 0xf78 <vListInitialise>
    1584:	0f 90       	pop	r0
    1586:	0f be       	out	0x3f, r0	; 63
    1588:	81 e0       	ldi	r24, 0x01	; 1
    158a:	df 91       	pop	r29
    158c:	cf 91       	pop	r28
    158e:	08 95       	ret

00001590 <xQueueGenericCreate>:
    1590:	0f 93       	push	r16
    1592:	1f 93       	push	r17
    1594:	cf 93       	push	r28
    1596:	df 93       	push	r29
    1598:	08 2f       	mov	r16, r24
    159a:	16 2f       	mov	r17, r22
    159c:	86 9f       	mul	r24, r22
    159e:	c0 01       	movw	r24, r0
    15a0:	11 24       	eor	r1, r1
    15a2:	4f 96       	adiw	r24, 0x1f	; 31
    15a4:	e2 de       	rcall	.-572    	; 0x136a <pvPortMalloc>
    15a6:	ec 01       	movw	r28, r24
    15a8:	00 97       	sbiw	r24, 0x00	; 0
    15aa:	69 f0       	breq	.+26     	; 0x15c6 <xQueueGenericCreate+0x36>
    15ac:	11 11       	cpse	r17, r1
    15ae:	03 c0       	rjmp	.+6      	; 0x15b6 <xQueueGenericCreate+0x26>
    15b0:	88 83       	st	Y, r24
    15b2:	99 83       	std	Y+1, r25	; 0x01
    15b4:	03 c0       	rjmp	.+6      	; 0x15bc <xQueueGenericCreate+0x2c>
    15b6:	4f 96       	adiw	r24, 0x1f	; 31
    15b8:	88 83       	st	Y, r24
    15ba:	99 83       	std	Y+1, r25	; 0x01
    15bc:	0b 8f       	std	Y+27, r16	; 0x1b
    15be:	1c 8f       	std	Y+28, r17	; 0x1c
    15c0:	61 e0       	ldi	r22, 0x01	; 1
    15c2:	ce 01       	movw	r24, r28
    15c4:	a3 df       	rcall	.-186    	; 0x150c <xQueueGenericReset>
    15c6:	ce 01       	movw	r24, r28
    15c8:	df 91       	pop	r29
    15ca:	cf 91       	pop	r28
    15cc:	1f 91       	pop	r17
    15ce:	0f 91       	pop	r16
    15d0:	08 95       	ret

000015d2 <xQueueGenericSend>:
    15d2:	af 92       	push	r10
    15d4:	bf 92       	push	r11
    15d6:	cf 92       	push	r12
    15d8:	df 92       	push	r13
    15da:	ef 92       	push	r14
    15dc:	ff 92       	push	r15
    15de:	0f 93       	push	r16
    15e0:	1f 93       	push	r17
    15e2:	cf 93       	push	r28
    15e4:	df 93       	push	r29
    15e6:	cd b7       	in	r28, 0x3d	; 61
    15e8:	de b7       	in	r29, 0x3e	; 62
    15ea:	25 97       	sbiw	r28, 0x05	; 5
    15ec:	cd bf       	out	0x3d, r28	; 61
    15ee:	de bf       	out	0x3e, r29	; 62
    15f0:	8c 01       	movw	r16, r24
    15f2:	6b 01       	movw	r12, r22
    15f4:	4c 83       	std	Y+4, r20	; 0x04
    15f6:	5d 83       	std	Y+5, r21	; 0x05
    15f8:	a2 2e       	mov	r10, r18
    15fa:	b1 2c       	mov	r11, r1
    15fc:	7c 01       	movw	r14, r24
    15fe:	88 e0       	ldi	r24, 0x08	; 8
    1600:	e8 0e       	add	r14, r24
    1602:	f1 1c       	adc	r15, r1
    1604:	0f b6       	in	r0, 0x3f	; 63
    1606:	f8 94       	cli
    1608:	0f 92       	push	r0
    160a:	f8 01       	movw	r30, r16
    160c:	92 8d       	ldd	r25, Z+26	; 0x1a
    160e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1610:	98 17       	cp	r25, r24
    1612:	18 f0       	brcs	.+6      	; 0x161a <xQueueGenericSend+0x48>
    1614:	f2 e0       	ldi	r31, 0x02	; 2
    1616:	af 12       	cpse	r10, r31
    1618:	15 c0       	rjmp	.+42     	; 0x1644 <xQueueGenericSend+0x72>
    161a:	4a 2d       	mov	r20, r10
    161c:	b6 01       	movw	r22, r12
    161e:	c8 01       	movw	r24, r16
    1620:	c9 de       	rcall	.-622    	; 0x13b4 <prvCopyDataToQueue>
    1622:	f8 01       	movw	r30, r16
    1624:	91 89       	ldd	r25, Z+17	; 0x11
    1626:	99 23       	and	r25, r25
    1628:	39 f0       	breq	.+14     	; 0x1638 <xQueueGenericSend+0x66>
    162a:	c8 01       	movw	r24, r16
    162c:	41 96       	adiw	r24, 0x11	; 17
    162e:	25 d5       	rcall	.+2634   	; 0x207a <xTaskRemoveFromEventList>
    1630:	88 23       	and	r24, r24
    1632:	21 f0       	breq	.+8      	; 0x163c <xQueueGenericSend+0x6a>
    1634:	e8 dd       	rcall	.-1072   	; 0x1206 <vPortYield>
    1636:	02 c0       	rjmp	.+4      	; 0x163c <xQueueGenericSend+0x6a>
    1638:	81 11       	cpse	r24, r1
    163a:	e5 dd       	rcall	.-1078   	; 0x1206 <vPortYield>
    163c:	0f 90       	pop	r0
    163e:	0f be       	out	0x3f, r0	; 63
    1640:	81 e0       	ldi	r24, 0x01	; 1
    1642:	46 c0       	rjmp	.+140    	; 0x16d0 <xQueueGenericSend+0xfe>
    1644:	8c 81       	ldd	r24, Y+4	; 0x04
    1646:	9d 81       	ldd	r25, Y+5	; 0x05
    1648:	89 2b       	or	r24, r25
    164a:	21 f4       	brne	.+8      	; 0x1654 <xQueueGenericSend+0x82>
    164c:	0f 90       	pop	r0
    164e:	0f be       	out	0x3f, r0	; 63
    1650:	80 e0       	ldi	r24, 0x00	; 0
    1652:	3e c0       	rjmp	.+124    	; 0x16d0 <xQueueGenericSend+0xfe>
    1654:	b1 10       	cpse	r11, r1
    1656:	05 c0       	rjmp	.+10     	; 0x1662 <xQueueGenericSend+0x90>
    1658:	ce 01       	movw	r24, r28
    165a:	01 96       	adiw	r24, 0x01	; 1
    165c:	56 d5       	rcall	.+2732   	; 0x210a <vTaskInternalSetTimeOutState>
    165e:	bb 24       	eor	r11, r11
    1660:	b3 94       	inc	r11
    1662:	0f 90       	pop	r0
    1664:	0f be       	out	0x3f, r0	; 63
    1666:	25 d3       	rcall	.+1610   	; 0x1cb2 <vTaskSuspendAll>
    1668:	0f b6       	in	r0, 0x3f	; 63
    166a:	f8 94       	cli
    166c:	0f 92       	push	r0
    166e:	f8 01       	movw	r30, r16
    1670:	85 8d       	ldd	r24, Z+29	; 0x1d
    1672:	8f 3f       	cpi	r24, 0xFF	; 255
    1674:	09 f4       	brne	.+2      	; 0x1678 <xQueueGenericSend+0xa6>
    1676:	15 8e       	std	Z+29, r1	; 0x1d
    1678:	f8 01       	movw	r30, r16
    167a:	86 8d       	ldd	r24, Z+30	; 0x1e
    167c:	8f 3f       	cpi	r24, 0xFF	; 255
    167e:	09 f4       	brne	.+2      	; 0x1682 <xQueueGenericSend+0xb0>
    1680:	16 8e       	std	Z+30, r1	; 0x1e
    1682:	0f 90       	pop	r0
    1684:	0f be       	out	0x3f, r0	; 63
    1686:	be 01       	movw	r22, r28
    1688:	6c 5f       	subi	r22, 0xFC	; 252
    168a:	7f 4f       	sbci	r23, 0xFF	; 255
    168c:	ce 01       	movw	r24, r28
    168e:	01 96       	adiw	r24, 0x01	; 1
    1690:	47 d5       	rcall	.+2702   	; 0x2120 <xTaskCheckForTimeOut>
    1692:	81 11       	cpse	r24, r1
    1694:	19 c0       	rjmp	.+50     	; 0x16c8 <xQueueGenericSend+0xf6>
    1696:	0f b6       	in	r0, 0x3f	; 63
    1698:	f8 94       	cli
    169a:	0f 92       	push	r0
    169c:	f8 01       	movw	r30, r16
    169e:	92 8d       	ldd	r25, Z+26	; 0x1a
    16a0:	0f 90       	pop	r0
    16a2:	0f be       	out	0x3f, r0	; 63
    16a4:	83 8d       	ldd	r24, Z+27	; 0x1b
    16a6:	98 13       	cpse	r25, r24
    16a8:	0b c0       	rjmp	.+22     	; 0x16c0 <xQueueGenericSend+0xee>
    16aa:	6c 81       	ldd	r22, Y+4	; 0x04
    16ac:	7d 81       	ldd	r23, Y+5	; 0x05
    16ae:	c7 01       	movw	r24, r14
    16b0:	bb d4       	rcall	.+2422   	; 0x2028 <vTaskPlaceOnEventList>
    16b2:	c8 01       	movw	r24, r16
    16b4:	e2 de       	rcall	.-572    	; 0x147a <prvUnlockQueue>
    16b6:	c5 d3       	rcall	.+1930   	; 0x1e42 <xTaskResumeAll>
    16b8:	81 11       	cpse	r24, r1
    16ba:	a4 cf       	rjmp	.-184    	; 0x1604 <xQueueGenericSend+0x32>
    16bc:	a4 dd       	rcall	.-1208   	; 0x1206 <vPortYield>
    16be:	a2 cf       	rjmp	.-188    	; 0x1604 <xQueueGenericSend+0x32>
    16c0:	c8 01       	movw	r24, r16
    16c2:	db de       	rcall	.-586    	; 0x147a <prvUnlockQueue>
    16c4:	be d3       	rcall	.+1916   	; 0x1e42 <xTaskResumeAll>
    16c6:	9e cf       	rjmp	.-196    	; 0x1604 <xQueueGenericSend+0x32>
    16c8:	c8 01       	movw	r24, r16
    16ca:	d7 de       	rcall	.-594    	; 0x147a <prvUnlockQueue>
    16cc:	ba d3       	rcall	.+1908   	; 0x1e42 <xTaskResumeAll>
    16ce:	80 e0       	ldi	r24, 0x00	; 0
    16d0:	25 96       	adiw	r28, 0x05	; 5
    16d2:	cd bf       	out	0x3d, r28	; 61
    16d4:	de bf       	out	0x3e, r29	; 62
    16d6:	df 91       	pop	r29
    16d8:	cf 91       	pop	r28
    16da:	1f 91       	pop	r17
    16dc:	0f 91       	pop	r16
    16de:	ff 90       	pop	r15
    16e0:	ef 90       	pop	r14
    16e2:	df 90       	pop	r13
    16e4:	cf 90       	pop	r12
    16e6:	bf 90       	pop	r11
    16e8:	af 90       	pop	r10
    16ea:	08 95       	ret

000016ec <xQueueGenericSendFromISR>:
    16ec:	ef 92       	push	r14
    16ee:	ff 92       	push	r15
    16f0:	0f 93       	push	r16
    16f2:	1f 93       	push	r17
    16f4:	cf 93       	push	r28
    16f6:	df 93       	push	r29
    16f8:	8a 01       	movw	r16, r20
    16fa:	fc 01       	movw	r30, r24
    16fc:	52 8d       	ldd	r21, Z+26	; 0x1a
    16fe:	33 8d       	ldd	r19, Z+27	; 0x1b
    1700:	53 17       	cp	r21, r19
    1702:	10 f0       	brcs	.+4      	; 0x1708 <xQueueGenericSendFromISR+0x1c>
    1704:	22 30       	cpi	r18, 0x02	; 2
    1706:	f1 f4       	brne	.+60     	; 0x1744 <xQueueGenericSendFromISR+0x58>
    1708:	42 2f       	mov	r20, r18
    170a:	78 01       	movw	r14, r16
    170c:	ec 01       	movw	r28, r24
    170e:	1e 8d       	ldd	r17, Y+30	; 0x1e
    1710:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1712:	ce 01       	movw	r24, r28
    1714:	4f de       	rcall	.-866    	; 0x13b4 <prvCopyDataToQueue>
    1716:	1f 3f       	cpi	r17, 0xFF	; 255
    1718:	79 f4       	brne	.+30     	; 0x1738 <xQueueGenericSendFromISR+0x4c>
    171a:	89 89       	ldd	r24, Y+17	; 0x11
    171c:	88 23       	and	r24, r24
    171e:	a1 f0       	breq	.+40     	; 0x1748 <xQueueGenericSendFromISR+0x5c>
    1720:	ce 01       	movw	r24, r28
    1722:	41 96       	adiw	r24, 0x11	; 17
    1724:	aa d4       	rcall	.+2388   	; 0x207a <xTaskRemoveFromEventList>
    1726:	88 23       	and	r24, r24
    1728:	89 f0       	breq	.+34     	; 0x174c <xQueueGenericSendFromISR+0x60>
    172a:	e1 14       	cp	r14, r1
    172c:	f1 04       	cpc	r15, r1
    172e:	81 f0       	breq	.+32     	; 0x1750 <xQueueGenericSendFromISR+0x64>
    1730:	81 e0       	ldi	r24, 0x01	; 1
    1732:	f7 01       	movw	r30, r14
    1734:	80 83       	st	Z, r24
    1736:	0d c0       	rjmp	.+26     	; 0x1752 <xQueueGenericSendFromISR+0x66>
    1738:	ff 24       	eor	r15, r15
    173a:	f3 94       	inc	r15
    173c:	f1 0e       	add	r15, r17
    173e:	fe 8e       	std	Y+30, r15	; 0x1e
    1740:	81 e0       	ldi	r24, 0x01	; 1
    1742:	07 c0       	rjmp	.+14     	; 0x1752 <xQueueGenericSendFromISR+0x66>
    1744:	80 e0       	ldi	r24, 0x00	; 0
    1746:	05 c0       	rjmp	.+10     	; 0x1752 <xQueueGenericSendFromISR+0x66>
    1748:	81 e0       	ldi	r24, 0x01	; 1
    174a:	03 c0       	rjmp	.+6      	; 0x1752 <xQueueGenericSendFromISR+0x66>
    174c:	81 e0       	ldi	r24, 0x01	; 1
    174e:	01 c0       	rjmp	.+2      	; 0x1752 <xQueueGenericSendFromISR+0x66>
    1750:	81 e0       	ldi	r24, 0x01	; 1
    1752:	df 91       	pop	r29
    1754:	cf 91       	pop	r28
    1756:	1f 91       	pop	r17
    1758:	0f 91       	pop	r16
    175a:	ff 90       	pop	r15
    175c:	ef 90       	pop	r14
    175e:	08 95       	ret

00001760 <xQueueReceive>:
    1760:	af 92       	push	r10
    1762:	bf 92       	push	r11
    1764:	cf 92       	push	r12
    1766:	df 92       	push	r13
    1768:	ef 92       	push	r14
    176a:	ff 92       	push	r15
    176c:	0f 93       	push	r16
    176e:	1f 93       	push	r17
    1770:	cf 93       	push	r28
    1772:	df 93       	push	r29
    1774:	cd b7       	in	r28, 0x3d	; 61
    1776:	de b7       	in	r29, 0x3e	; 62
    1778:	25 97       	sbiw	r28, 0x05	; 5
    177a:	cd bf       	out	0x3d, r28	; 61
    177c:	de bf       	out	0x3e, r29	; 62
    177e:	8c 01       	movw	r16, r24
    1780:	5b 01       	movw	r10, r22
    1782:	4c 83       	std	Y+4, r20	; 0x04
    1784:	5d 83       	std	Y+5, r21	; 0x05
    1786:	e1 2c       	mov	r14, r1
    1788:	6c 01       	movw	r12, r24
    178a:	81 e1       	ldi	r24, 0x11	; 17
    178c:	c8 0e       	add	r12, r24
    178e:	d1 1c       	adc	r13, r1
    1790:	0f b6       	in	r0, 0x3f	; 63
    1792:	f8 94       	cli
    1794:	0f 92       	push	r0
    1796:	f8 01       	movw	r30, r16
    1798:	f2 8c       	ldd	r15, Z+26	; 0x1a
    179a:	ff 20       	and	r15, r15
    179c:	91 f0       	breq	.+36     	; 0x17c2 <xQueueReceive+0x62>
    179e:	b5 01       	movw	r22, r10
    17a0:	c8 01       	movw	r24, r16
    17a2:	51 de       	rcall	.-862    	; 0x1446 <prvCopyDataFromQueue>
    17a4:	fa 94       	dec	r15
    17a6:	f8 01       	movw	r30, r16
    17a8:	f2 8e       	std	Z+26, r15	; 0x1a
    17aa:	80 85       	ldd	r24, Z+8	; 0x08
    17ac:	88 23       	and	r24, r24
    17ae:	29 f0       	breq	.+10     	; 0x17ba <xQueueReceive+0x5a>
    17b0:	c8 01       	movw	r24, r16
    17b2:	08 96       	adiw	r24, 0x08	; 8
    17b4:	62 d4       	rcall	.+2244   	; 0x207a <xTaskRemoveFromEventList>
    17b6:	81 11       	cpse	r24, r1
    17b8:	26 dd       	rcall	.-1460   	; 0x1206 <vPortYield>
    17ba:	0f 90       	pop	r0
    17bc:	0f be       	out	0x3f, r0	; 63
    17be:	81 e0       	ldi	r24, 0x01	; 1
    17c0:	45 c0       	rjmp	.+138    	; 0x184c <xQueueReceive+0xec>
    17c2:	8c 81       	ldd	r24, Y+4	; 0x04
    17c4:	9d 81       	ldd	r25, Y+5	; 0x05
    17c6:	89 2b       	or	r24, r25
    17c8:	21 f4       	brne	.+8      	; 0x17d2 <xQueueReceive+0x72>
    17ca:	0f 90       	pop	r0
    17cc:	0f be       	out	0x3f, r0	; 63
    17ce:	80 e0       	ldi	r24, 0x00	; 0
    17d0:	3d c0       	rjmp	.+122    	; 0x184c <xQueueReceive+0xec>
    17d2:	e1 10       	cpse	r14, r1
    17d4:	05 c0       	rjmp	.+10     	; 0x17e0 <xQueueReceive+0x80>
    17d6:	ce 01       	movw	r24, r28
    17d8:	01 96       	adiw	r24, 0x01	; 1
    17da:	97 d4       	rcall	.+2350   	; 0x210a <vTaskInternalSetTimeOutState>
    17dc:	ee 24       	eor	r14, r14
    17de:	e3 94       	inc	r14
    17e0:	0f 90       	pop	r0
    17e2:	0f be       	out	0x3f, r0	; 63
    17e4:	66 d2       	rcall	.+1228   	; 0x1cb2 <vTaskSuspendAll>
    17e6:	0f b6       	in	r0, 0x3f	; 63
    17e8:	f8 94       	cli
    17ea:	0f 92       	push	r0
    17ec:	f8 01       	movw	r30, r16
    17ee:	85 8d       	ldd	r24, Z+29	; 0x1d
    17f0:	8f 3f       	cpi	r24, 0xFF	; 255
    17f2:	09 f4       	brne	.+2      	; 0x17f6 <xQueueReceive+0x96>
    17f4:	15 8e       	std	Z+29, r1	; 0x1d
    17f6:	f8 01       	movw	r30, r16
    17f8:	86 8d       	ldd	r24, Z+30	; 0x1e
    17fa:	8f 3f       	cpi	r24, 0xFF	; 255
    17fc:	09 f4       	brne	.+2      	; 0x1800 <xQueueReceive+0xa0>
    17fe:	16 8e       	std	Z+30, r1	; 0x1e
    1800:	0f 90       	pop	r0
    1802:	0f be       	out	0x3f, r0	; 63
    1804:	be 01       	movw	r22, r28
    1806:	6c 5f       	subi	r22, 0xFC	; 252
    1808:	7f 4f       	sbci	r23, 0xFF	; 255
    180a:	ce 01       	movw	r24, r28
    180c:	01 96       	adiw	r24, 0x01	; 1
    180e:	88 d4       	rcall	.+2320   	; 0x2120 <xTaskCheckForTimeOut>
    1810:	81 11       	cpse	r24, r1
    1812:	13 c0       	rjmp	.+38     	; 0x183a <xQueueReceive+0xda>
    1814:	c8 01       	movw	r24, r16
    1816:	c3 dd       	rcall	.-1146   	; 0x139e <prvIsQueueEmpty>
    1818:	88 23       	and	r24, r24
    181a:	59 f0       	breq	.+22     	; 0x1832 <xQueueReceive+0xd2>
    181c:	6c 81       	ldd	r22, Y+4	; 0x04
    181e:	7d 81       	ldd	r23, Y+5	; 0x05
    1820:	c6 01       	movw	r24, r12
    1822:	02 d4       	rcall	.+2052   	; 0x2028 <vTaskPlaceOnEventList>
    1824:	c8 01       	movw	r24, r16
    1826:	29 de       	rcall	.-942    	; 0x147a <prvUnlockQueue>
    1828:	0c d3       	rcall	.+1560   	; 0x1e42 <xTaskResumeAll>
    182a:	81 11       	cpse	r24, r1
    182c:	b1 cf       	rjmp	.-158    	; 0x1790 <xQueueReceive+0x30>
    182e:	eb dc       	rcall	.-1578   	; 0x1206 <vPortYield>
    1830:	af cf       	rjmp	.-162    	; 0x1790 <xQueueReceive+0x30>
    1832:	c8 01       	movw	r24, r16
    1834:	22 de       	rcall	.-956    	; 0x147a <prvUnlockQueue>
    1836:	05 d3       	rcall	.+1546   	; 0x1e42 <xTaskResumeAll>
    1838:	ab cf       	rjmp	.-170    	; 0x1790 <xQueueReceive+0x30>
    183a:	c8 01       	movw	r24, r16
    183c:	1e de       	rcall	.-964    	; 0x147a <prvUnlockQueue>
    183e:	01 d3       	rcall	.+1538   	; 0x1e42 <xTaskResumeAll>
    1840:	c8 01       	movw	r24, r16
    1842:	ad dd       	rcall	.-1190   	; 0x139e <prvIsQueueEmpty>
    1844:	88 23       	and	r24, r24
    1846:	09 f4       	brne	.+2      	; 0x184a <xQueueReceive+0xea>
    1848:	a3 cf       	rjmp	.-186    	; 0x1790 <xQueueReceive+0x30>
    184a:	80 e0       	ldi	r24, 0x00	; 0
    184c:	25 96       	adiw	r28, 0x05	; 5
    184e:	cd bf       	out	0x3d, r28	; 61
    1850:	de bf       	out	0x3e, r29	; 62
    1852:	df 91       	pop	r29
    1854:	cf 91       	pop	r28
    1856:	1f 91       	pop	r17
    1858:	0f 91       	pop	r16
    185a:	ff 90       	pop	r15
    185c:	ef 90       	pop	r14
    185e:	df 90       	pop	r13
    1860:	cf 90       	pop	r12
    1862:	bf 90       	pop	r11
    1864:	af 90       	pop	r10
    1866:	08 95       	ret

00001868 <xQueueSemaphoreTake>:
    1868:	df 92       	push	r13
    186a:	ef 92       	push	r14
    186c:	ff 92       	push	r15
    186e:	0f 93       	push	r16
    1870:	1f 93       	push	r17
    1872:	cf 93       	push	r28
    1874:	df 93       	push	r29
    1876:	cd b7       	in	r28, 0x3d	; 61
    1878:	de b7       	in	r29, 0x3e	; 62
    187a:	25 97       	sbiw	r28, 0x05	; 5
    187c:	cd bf       	out	0x3d, r28	; 61
    187e:	de bf       	out	0x3e, r29	; 62
    1880:	8c 01       	movw	r16, r24
    1882:	6c 83       	std	Y+4, r22	; 0x04
    1884:	7d 83       	std	Y+5, r23	; 0x05
    1886:	d1 2c       	mov	r13, r1
    1888:	7c 01       	movw	r14, r24
    188a:	81 e1       	ldi	r24, 0x11	; 17
    188c:	e8 0e       	add	r14, r24
    188e:	f1 1c       	adc	r15, r1
    1890:	0f b6       	in	r0, 0x3f	; 63
    1892:	f8 94       	cli
    1894:	0f 92       	push	r0
    1896:	f8 01       	movw	r30, r16
    1898:	82 8d       	ldd	r24, Z+26	; 0x1a
    189a:	88 23       	and	r24, r24
    189c:	71 f0       	breq	.+28     	; 0x18ba <xQueueSemaphoreTake+0x52>
    189e:	81 50       	subi	r24, 0x01	; 1
    18a0:	82 8f       	std	Z+26, r24	; 0x1a
    18a2:	80 85       	ldd	r24, Z+8	; 0x08
    18a4:	88 23       	and	r24, r24
    18a6:	29 f0       	breq	.+10     	; 0x18b2 <xQueueSemaphoreTake+0x4a>
    18a8:	c8 01       	movw	r24, r16
    18aa:	08 96       	adiw	r24, 0x08	; 8
    18ac:	e6 d3       	rcall	.+1996   	; 0x207a <xTaskRemoveFromEventList>
    18ae:	81 11       	cpse	r24, r1
    18b0:	aa dc       	rcall	.-1708   	; 0x1206 <vPortYield>
    18b2:	0f 90       	pop	r0
    18b4:	0f be       	out	0x3f, r0	; 63
    18b6:	81 e0       	ldi	r24, 0x01	; 1
    18b8:	45 c0       	rjmp	.+138    	; 0x1944 <xQueueSemaphoreTake+0xdc>
    18ba:	8c 81       	ldd	r24, Y+4	; 0x04
    18bc:	9d 81       	ldd	r25, Y+5	; 0x05
    18be:	89 2b       	or	r24, r25
    18c0:	21 f4       	brne	.+8      	; 0x18ca <xQueueSemaphoreTake+0x62>
    18c2:	0f 90       	pop	r0
    18c4:	0f be       	out	0x3f, r0	; 63
    18c6:	80 e0       	ldi	r24, 0x00	; 0
    18c8:	3d c0       	rjmp	.+122    	; 0x1944 <xQueueSemaphoreTake+0xdc>
    18ca:	d1 10       	cpse	r13, r1
    18cc:	05 c0       	rjmp	.+10     	; 0x18d8 <xQueueSemaphoreTake+0x70>
    18ce:	ce 01       	movw	r24, r28
    18d0:	01 96       	adiw	r24, 0x01	; 1
    18d2:	1b d4       	rcall	.+2102   	; 0x210a <vTaskInternalSetTimeOutState>
    18d4:	dd 24       	eor	r13, r13
    18d6:	d3 94       	inc	r13
    18d8:	0f 90       	pop	r0
    18da:	0f be       	out	0x3f, r0	; 63
    18dc:	ea d1       	rcall	.+980    	; 0x1cb2 <vTaskSuspendAll>
    18de:	0f b6       	in	r0, 0x3f	; 63
    18e0:	f8 94       	cli
    18e2:	0f 92       	push	r0
    18e4:	f8 01       	movw	r30, r16
    18e6:	85 8d       	ldd	r24, Z+29	; 0x1d
    18e8:	8f 3f       	cpi	r24, 0xFF	; 255
    18ea:	09 f4       	brne	.+2      	; 0x18ee <xQueueSemaphoreTake+0x86>
    18ec:	15 8e       	std	Z+29, r1	; 0x1d
    18ee:	f8 01       	movw	r30, r16
    18f0:	86 8d       	ldd	r24, Z+30	; 0x1e
    18f2:	8f 3f       	cpi	r24, 0xFF	; 255
    18f4:	09 f4       	brne	.+2      	; 0x18f8 <xQueueSemaphoreTake+0x90>
    18f6:	16 8e       	std	Z+30, r1	; 0x1e
    18f8:	0f 90       	pop	r0
    18fa:	0f be       	out	0x3f, r0	; 63
    18fc:	be 01       	movw	r22, r28
    18fe:	6c 5f       	subi	r22, 0xFC	; 252
    1900:	7f 4f       	sbci	r23, 0xFF	; 255
    1902:	ce 01       	movw	r24, r28
    1904:	01 96       	adiw	r24, 0x01	; 1
    1906:	0c d4       	rcall	.+2072   	; 0x2120 <xTaskCheckForTimeOut>
    1908:	81 11       	cpse	r24, r1
    190a:	13 c0       	rjmp	.+38     	; 0x1932 <xQueueSemaphoreTake+0xca>
    190c:	c8 01       	movw	r24, r16
    190e:	47 dd       	rcall	.-1394   	; 0x139e <prvIsQueueEmpty>
    1910:	88 23       	and	r24, r24
    1912:	59 f0       	breq	.+22     	; 0x192a <xQueueSemaphoreTake+0xc2>
    1914:	6c 81       	ldd	r22, Y+4	; 0x04
    1916:	7d 81       	ldd	r23, Y+5	; 0x05
    1918:	c7 01       	movw	r24, r14
    191a:	86 d3       	rcall	.+1804   	; 0x2028 <vTaskPlaceOnEventList>
    191c:	c8 01       	movw	r24, r16
    191e:	ad dd       	rcall	.-1190   	; 0x147a <prvUnlockQueue>
    1920:	90 d2       	rcall	.+1312   	; 0x1e42 <xTaskResumeAll>
    1922:	81 11       	cpse	r24, r1
    1924:	b5 cf       	rjmp	.-150    	; 0x1890 <xQueueSemaphoreTake+0x28>
    1926:	6f dc       	rcall	.-1826   	; 0x1206 <vPortYield>
    1928:	b3 cf       	rjmp	.-154    	; 0x1890 <xQueueSemaphoreTake+0x28>
    192a:	c8 01       	movw	r24, r16
    192c:	a6 dd       	rcall	.-1204   	; 0x147a <prvUnlockQueue>
    192e:	89 d2       	rcall	.+1298   	; 0x1e42 <xTaskResumeAll>
    1930:	af cf       	rjmp	.-162    	; 0x1890 <xQueueSemaphoreTake+0x28>
    1932:	c8 01       	movw	r24, r16
    1934:	a2 dd       	rcall	.-1212   	; 0x147a <prvUnlockQueue>
    1936:	85 d2       	rcall	.+1290   	; 0x1e42 <xTaskResumeAll>
    1938:	c8 01       	movw	r24, r16
    193a:	31 dd       	rcall	.-1438   	; 0x139e <prvIsQueueEmpty>
    193c:	88 23       	and	r24, r24
    193e:	09 f4       	brne	.+2      	; 0x1942 <xQueueSemaphoreTake+0xda>
    1940:	a7 cf       	rjmp	.-178    	; 0x1890 <xQueueSemaphoreTake+0x28>
    1942:	80 e0       	ldi	r24, 0x00	; 0
    1944:	25 96       	adiw	r28, 0x05	; 5
    1946:	cd bf       	out	0x3d, r28	; 61
    1948:	de bf       	out	0x3e, r29	; 62
    194a:	df 91       	pop	r29
    194c:	cf 91       	pop	r28
    194e:	1f 91       	pop	r17
    1950:	0f 91       	pop	r16
    1952:	ff 90       	pop	r15
    1954:	ef 90       	pop	r14
    1956:	df 90       	pop	r13
    1958:	08 95       	ret

0000195a <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    195a:	cf 93       	push	r28
    195c:	df 93       	push	r29
    195e:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    1960:	0f b6       	in	r0, 0x3f	; 63
    1962:	f8 94       	cli
    1964:	0f 92       	push	r0
    1966:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1968:	8f 3f       	cpi	r24, 0xFF	; 255
    196a:	09 f4       	brne	.+2      	; 0x196e <vQueueWaitForMessageRestricted+0x14>
    196c:	1d 8e       	std	Y+29, r1	; 0x1d
    196e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1970:	8f 3f       	cpi	r24, 0xFF	; 255
    1972:	09 f4       	brne	.+2      	; 0x1976 <vQueueWaitForMessageRestricted+0x1c>
    1974:	1e 8e       	std	Y+30, r1	; 0x1e
    1976:	0f 90       	pop	r0
    1978:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    197a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    197c:	81 11       	cpse	r24, r1
    197e:	03 c0       	rjmp	.+6      	; 0x1986 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    1980:	ce 01       	movw	r24, r28
    1982:	41 96       	adiw	r24, 0x11	; 17
    1984:	62 d3       	rcall	.+1732   	; 0x204a <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    1986:	ce 01       	movw	r24, r28
    1988:	78 dd       	rcall	.-1296   	; 0x147a <prvUnlockQueue>
	}
    198a:	df 91       	pop	r29
    198c:	cf 91       	pop	r28
    198e:	08 95       	ret

00001990 <prvResetNextTaskUnblockTime>:
	taskENTER_CRITICAL();
	{
		pxTimeOut->xOverflowCount = xNumOfOverflows;
		pxTimeOut->xTimeOnEntering = xTickCount;
	}
	taskEXIT_CRITICAL();
    1990:	e0 91 70 22 	lds	r30, 0x2270	; 0x802270 <pxDelayedTaskList>
    1994:	f0 91 71 22 	lds	r31, 0x2271	; 0x802271 <pxDelayedTaskList+0x1>
    1998:	80 81       	ld	r24, Z
    199a:	81 11       	cpse	r24, r1
    199c:	07 c0       	rjmp	.+14     	; 0x19ac <prvResetNextTaskUnblockTime+0x1c>
    199e:	8f ef       	ldi	r24, 0xFF	; 255
    19a0:	9f ef       	ldi	r25, 0xFF	; 255
    19a2:	80 93 59 22 	sts	0x2259, r24	; 0x802259 <xNextTaskUnblockTime>
    19a6:	90 93 5a 22 	sts	0x225A, r25	; 0x80225a <xNextTaskUnblockTime+0x1>
    19aa:	08 95       	ret
    19ac:	e0 91 70 22 	lds	r30, 0x2270	; 0x802270 <pxDelayedTaskList>
    19b0:	f0 91 71 22 	lds	r31, 0x2271	; 0x802271 <pxDelayedTaskList+0x1>
    19b4:	05 80       	ldd	r0, Z+5	; 0x05
    19b6:	f6 81       	ldd	r31, Z+6	; 0x06
    19b8:	e0 2d       	mov	r30, r0
    19ba:	06 80       	ldd	r0, Z+6	; 0x06
    19bc:	f7 81       	ldd	r31, Z+7	; 0x07
    19be:	e0 2d       	mov	r30, r0
    19c0:	82 81       	ldd	r24, Z+2	; 0x02
    19c2:	93 81       	ldd	r25, Z+3	; 0x03
    19c4:	80 93 59 22 	sts	0x2259, r24	; 0x802259 <xNextTaskUnblockTime>
    19c8:	90 93 5a 22 	sts	0x225A, r25	; 0x80225a <xNextTaskUnblockTime+0x1>
    19cc:	08 95       	ret

000019ce <prvIdleTask>:
    19ce:	c4 e8       	ldi	r28, 0x84	; 132
    19d0:	d2 e2       	ldi	r29, 0x22	; 34
    19d2:	88 81       	ld	r24, Y
    19d4:	82 30       	cpi	r24, 0x02	; 2
    19d6:	e8 f3       	brcs	.-6      	; 0x19d2 <prvIdleTask+0x4>
    19d8:	16 dc       	rcall	.-2004   	; 0x1206 <vPortYield>
    19da:	fb cf       	rjmp	.-10     	; 0x19d2 <prvIdleTask+0x4>

000019dc <prvAddCurrentTaskToDelayedList>:
    19dc:	0f 93       	push	r16
    19de:	1f 93       	push	r17
    19e0:	cf 93       	push	r28
    19e2:	df 93       	push	r29
    19e4:	ec 01       	movw	r28, r24
    19e6:	00 91 62 22 	lds	r16, 0x2262	; 0x802262 <xTickCount>
    19ea:	10 91 63 22 	lds	r17, 0x2263	; 0x802263 <xTickCount+0x1>
    19ee:	80 91 b1 22 	lds	r24, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    19f2:	90 91 b2 22 	lds	r25, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    19f6:	02 96       	adiw	r24, 0x02	; 2
    19f8:	23 db       	rcall	.-2490   	; 0x1040 <uxListRemove>
    19fa:	c0 0f       	add	r28, r16
    19fc:	d1 1f       	adc	r29, r17
    19fe:	e0 91 b1 22 	lds	r30, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    1a02:	f0 91 b2 22 	lds	r31, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    1a06:	c2 83       	std	Z+2, r28	; 0x02
    1a08:	d3 83       	std	Z+3, r29	; 0x03
    1a0a:	c0 17       	cp	r28, r16
    1a0c:	d1 07       	cpc	r29, r17
    1a0e:	60 f4       	brcc	.+24     	; 0x1a28 <prvAddCurrentTaskToDelayedList+0x4c>
    1a10:	60 91 b1 22 	lds	r22, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    1a14:	70 91 b2 22 	lds	r23, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    1a18:	80 91 6e 22 	lds	r24, 0x226E	; 0x80226e <pxOverflowDelayedTaskList>
    1a1c:	90 91 6f 22 	lds	r25, 0x226F	; 0x80226f <pxOverflowDelayedTaskList+0x1>
    1a20:	6e 5f       	subi	r22, 0xFE	; 254
    1a22:	7f 4f       	sbci	r23, 0xFF	; 255
    1a24:	dc da       	rcall	.-2632   	; 0xfde <vListInsert>
    1a26:	16 c0       	rjmp	.+44     	; 0x1a54 <prvAddCurrentTaskToDelayedList+0x78>
    1a28:	60 91 b1 22 	lds	r22, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    1a2c:	70 91 b2 22 	lds	r23, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    1a30:	80 91 70 22 	lds	r24, 0x2270	; 0x802270 <pxDelayedTaskList>
    1a34:	90 91 71 22 	lds	r25, 0x2271	; 0x802271 <pxDelayedTaskList+0x1>
    1a38:	6e 5f       	subi	r22, 0xFE	; 254
    1a3a:	7f 4f       	sbci	r23, 0xFF	; 255
    1a3c:	d0 da       	rcall	.-2656   	; 0xfde <vListInsert>
    1a3e:	80 91 59 22 	lds	r24, 0x2259	; 0x802259 <xNextTaskUnblockTime>
    1a42:	90 91 5a 22 	lds	r25, 0x225A	; 0x80225a <xNextTaskUnblockTime+0x1>
    1a46:	c8 17       	cp	r28, r24
    1a48:	d9 07       	cpc	r29, r25
    1a4a:	20 f4       	brcc	.+8      	; 0x1a54 <prvAddCurrentTaskToDelayedList+0x78>
    1a4c:	c0 93 59 22 	sts	0x2259, r28	; 0x802259 <xNextTaskUnblockTime>
    1a50:	d0 93 5a 22 	sts	0x225A, r29	; 0x80225a <xNextTaskUnblockTime+0x1>
    1a54:	df 91       	pop	r29
    1a56:	cf 91       	pop	r28
    1a58:	1f 91       	pop	r17
    1a5a:	0f 91       	pop	r16
    1a5c:	08 95       	ret

00001a5e <xTaskCreate>:
    1a5e:	4f 92       	push	r4
    1a60:	5f 92       	push	r5
    1a62:	6f 92       	push	r6
    1a64:	7f 92       	push	r7
    1a66:	8f 92       	push	r8
    1a68:	9f 92       	push	r9
    1a6a:	af 92       	push	r10
    1a6c:	bf 92       	push	r11
    1a6e:	cf 92       	push	r12
    1a70:	df 92       	push	r13
    1a72:	ef 92       	push	r14
    1a74:	ff 92       	push	r15
    1a76:	0f 93       	push	r16
    1a78:	1f 93       	push	r17
    1a7a:	cf 93       	push	r28
    1a7c:	df 93       	push	r29
    1a7e:	4c 01       	movw	r8, r24
    1a80:	6b 01       	movw	r12, r22
    1a82:	5a 01       	movw	r10, r20
    1a84:	29 01       	movw	r4, r18
    1a86:	ca 01       	movw	r24, r20
    1a88:	70 dc       	rcall	.-1824   	; 0x136a <pvPortMalloc>
    1a8a:	3c 01       	movw	r6, r24
    1a8c:	89 2b       	or	r24, r25
    1a8e:	09 f4       	brne	.+2      	; 0x1a92 <xTaskCreate+0x34>
    1a90:	d3 c0       	rjmp	.+422    	; 0x1c38 <xTaskCreate+0x1da>
    1a92:	86 e2       	ldi	r24, 0x26	; 38
    1a94:	90 e0       	ldi	r25, 0x00	; 0
    1a96:	69 dc       	rcall	.-1838   	; 0x136a <pvPortMalloc>
    1a98:	ec 01       	movw	r28, r24
    1a9a:	89 2b       	or	r24, r25
    1a9c:	59 f0       	breq	.+22     	; 0x1ab4 <xTaskCreate+0x56>
    1a9e:	6f 8a       	std	Y+23, r6	; 0x17
    1aa0:	78 8e       	std	Y+24, r7	; 0x18
    1aa2:	81 e0       	ldi	r24, 0x01	; 1
    1aa4:	a8 1a       	sub	r10, r24
    1aa6:	b1 08       	sbc	r11, r1
    1aa8:	a6 0c       	add	r10, r6
    1aaa:	b7 1c       	adc	r11, r7
    1aac:	c1 14       	cp	r12, r1
    1aae:	d1 04       	cpc	r13, r1
    1ab0:	21 f4       	brne	.+8      	; 0x1aba <xTaskCreate+0x5c>
    1ab2:	1f c0       	rjmp	.+62     	; 0x1af2 <xTaskCreate+0x94>
    1ab4:	c3 01       	movw	r24, r6
    1ab6:	66 dc       	rcall	.-1844   	; 0x1384 <vPortFree>
    1ab8:	bf c0       	rjmp	.+382    	; 0x1c38 <xTaskCreate+0x1da>
    1aba:	d6 01       	movw	r26, r12
    1abc:	8c 91       	ld	r24, X
    1abe:	89 8f       	std	Y+25, r24	; 0x19
    1ac0:	8c 91       	ld	r24, X
    1ac2:	88 23       	and	r24, r24
    1ac4:	a1 f0       	breq	.+40     	; 0x1aee <xTaskCreate+0x90>
    1ac6:	ae 01       	movw	r20, r28
    1ac8:	46 5e       	subi	r20, 0xE6	; 230
    1aca:	5f 4f       	sbci	r21, 0xFF	; 255
    1acc:	f6 01       	movw	r30, r12
    1ace:	31 96       	adiw	r30, 0x01	; 1
    1ad0:	b8 e0       	ldi	r27, 0x08	; 8
    1ad2:	cb 0e       	add	r12, r27
    1ad4:	d1 1c       	adc	r13, r1
    1ad6:	cf 01       	movw	r24, r30
    1ad8:	21 91       	ld	r18, Z+
    1ada:	da 01       	movw	r26, r20
    1adc:	2d 93       	st	X+, r18
    1ade:	ad 01       	movw	r20, r26
    1ae0:	dc 01       	movw	r26, r24
    1ae2:	8c 91       	ld	r24, X
    1ae4:	88 23       	and	r24, r24
    1ae6:	19 f0       	breq	.+6      	; 0x1aee <xTaskCreate+0x90>
    1ae8:	ce 16       	cp	r12, r30
    1aea:	df 06       	cpc	r13, r31
    1aec:	a1 f7       	brne	.-24     	; 0x1ad6 <xTaskCreate+0x78>
    1aee:	18 a2       	std	Y+32, r1	; 0x20
    1af0:	01 c0       	rjmp	.+2      	; 0x1af4 <xTaskCreate+0x96>
    1af2:	19 8e       	std	Y+25, r1	; 0x19
    1af4:	05 30       	cpi	r16, 0x05	; 5
    1af6:	08 f0       	brcs	.+2      	; 0x1afa <xTaskCreate+0x9c>
    1af8:	04 e0       	ldi	r16, 0x04	; 4
    1afa:	0e 8b       	std	Y+22, r16	; 0x16
    1afc:	6e 01       	movw	r12, r28
    1afe:	b2 e0       	ldi	r27, 0x02	; 2
    1b00:	cb 0e       	add	r12, r27
    1b02:	d1 1c       	adc	r13, r1
    1b04:	c6 01       	movw	r24, r12
    1b06:	46 da       	rcall	.-2932   	; 0xf94 <vListInitialiseItem>
    1b08:	ce 01       	movw	r24, r28
    1b0a:	0c 96       	adiw	r24, 0x0c	; 12
    1b0c:	43 da       	rcall	.-2938   	; 0xf94 <vListInitialiseItem>
    1b0e:	c8 87       	std	Y+8, r28	; 0x08
    1b10:	d9 87       	std	Y+9, r29	; 0x09
    1b12:	85 e0       	ldi	r24, 0x05	; 5
    1b14:	90 e0       	ldi	r25, 0x00	; 0
    1b16:	80 1b       	sub	r24, r16
    1b18:	91 09       	sbc	r25, r1
    1b1a:	8c 87       	std	Y+12, r24	; 0x0c
    1b1c:	9d 87       	std	Y+13, r25	; 0x0d
    1b1e:	ca 8b       	std	Y+18, r28	; 0x12
    1b20:	db 8b       	std	Y+19, r29	; 0x13
    1b22:	19 a2       	std	Y+33, r1	; 0x21
    1b24:	1a a2       	std	Y+34, r1	; 0x22
    1b26:	1b a2       	std	Y+35, r1	; 0x23
    1b28:	1c a2       	std	Y+36, r1	; 0x24
    1b2a:	1d a2       	std	Y+37, r1	; 0x25
    1b2c:	a2 01       	movw	r20, r4
    1b2e:	b4 01       	movw	r22, r8
    1b30:	c5 01       	movw	r24, r10
    1b32:	ad da       	rcall	.-2726   	; 0x108e <pxPortInitialiseStack>
    1b34:	88 83       	st	Y, r24
    1b36:	99 83       	std	Y+1, r25	; 0x01
    1b38:	e1 14       	cp	r14, r1
    1b3a:	f1 04       	cpc	r15, r1
    1b3c:	19 f0       	breq	.+6      	; 0x1b44 <xTaskCreate+0xe6>
    1b3e:	f7 01       	movw	r30, r14
    1b40:	c0 83       	st	Z, r28
    1b42:	d1 83       	std	Z+1, r29	; 0x01
    1b44:	0f b6       	in	r0, 0x3f	; 63
    1b46:	f8 94       	cli
    1b48:	0f 92       	push	r0
    1b4a:	80 91 64 22 	lds	r24, 0x2264	; 0x802264 <uxCurrentNumberOfTasks>
    1b4e:	8f 5f       	subi	r24, 0xFF	; 255
    1b50:	80 93 64 22 	sts	0x2264, r24	; 0x802264 <uxCurrentNumberOfTasks>
    1b54:	80 91 b1 22 	lds	r24, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    1b58:	90 91 b2 22 	lds	r25, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    1b5c:	89 2b       	or	r24, r25
    1b5e:	69 f5       	brne	.+90     	; 0x1bba <xTaskCreate+0x15c>
    1b60:	c0 93 b1 22 	sts	0x22B1, r28	; 0x8022b1 <pxCurrentTCB>
    1b64:	d0 93 b2 22 	sts	0x22B2, r29	; 0x8022b2 <pxCurrentTCB+0x1>
    1b68:	80 91 64 22 	lds	r24, 0x2264	; 0x802264 <uxCurrentNumberOfTasks>
    1b6c:	81 30       	cpi	r24, 0x01	; 1
    1b6e:	a9 f5       	brne	.+106    	; 0x1bda <xTaskCreate+0x17c>
    1b70:	04 e8       	ldi	r16, 0x84	; 132
    1b72:	12 e2       	ldi	r17, 0x22	; 34
    1b74:	0f 2e       	mov	r0, r31
    1b76:	f1 eb       	ldi	r31, 0xB1	; 177
    1b78:	ef 2e       	mov	r14, r31
    1b7a:	f2 e2       	ldi	r31, 0x22	; 34
    1b7c:	ff 2e       	mov	r15, r31
    1b7e:	f0 2d       	mov	r31, r0
    1b80:	c8 01       	movw	r24, r16
    1b82:	fa d9       	rcall	.-3084   	; 0xf78 <vListInitialise>
    1b84:	07 5f       	subi	r16, 0xF7	; 247
    1b86:	1f 4f       	sbci	r17, 0xFF	; 255
    1b88:	0e 15       	cp	r16, r14
    1b8a:	1f 05       	cpc	r17, r15
    1b8c:	c9 f7       	brne	.-14     	; 0x1b80 <xTaskCreate+0x122>
    1b8e:	8b e7       	ldi	r24, 0x7B	; 123
    1b90:	92 e2       	ldi	r25, 0x22	; 34
    1b92:	f2 d9       	rcall	.-3100   	; 0xf78 <vListInitialise>
    1b94:	82 e7       	ldi	r24, 0x72	; 114
    1b96:	92 e2       	ldi	r25, 0x22	; 34
    1b98:	ef d9       	rcall	.-3106   	; 0xf78 <vListInitialise>
    1b9a:	85 e6       	ldi	r24, 0x65	; 101
    1b9c:	92 e2       	ldi	r25, 0x22	; 34
    1b9e:	ec d9       	rcall	.-3112   	; 0xf78 <vListInitialise>
    1ba0:	8b e7       	ldi	r24, 0x7B	; 123
    1ba2:	92 e2       	ldi	r25, 0x22	; 34
    1ba4:	80 93 70 22 	sts	0x2270, r24	; 0x802270 <pxDelayedTaskList>
    1ba8:	90 93 71 22 	sts	0x2271, r25	; 0x802271 <pxDelayedTaskList+0x1>
    1bac:	82 e7       	ldi	r24, 0x72	; 114
    1bae:	92 e2       	ldi	r25, 0x22	; 34
    1bb0:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <pxOverflowDelayedTaskList>
    1bb4:	90 93 6f 22 	sts	0x226F, r25	; 0x80226f <pxOverflowDelayedTaskList+0x1>
    1bb8:	10 c0       	rjmp	.+32     	; 0x1bda <xTaskCreate+0x17c>
    1bba:	80 91 60 22 	lds	r24, 0x2260	; 0x802260 <xSchedulerRunning>
    1bbe:	81 11       	cpse	r24, r1
    1bc0:	0c c0       	rjmp	.+24     	; 0x1bda <xTaskCreate+0x17c>
    1bc2:	e0 91 b1 22 	lds	r30, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    1bc6:	f0 91 b2 22 	lds	r31, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    1bca:	96 89       	ldd	r25, Z+22	; 0x16
    1bcc:	8e 89       	ldd	r24, Y+22	; 0x16
    1bce:	89 17       	cp	r24, r25
    1bd0:	20 f0       	brcs	.+8      	; 0x1bda <xTaskCreate+0x17c>
    1bd2:	c0 93 b1 22 	sts	0x22B1, r28	; 0x8022b1 <pxCurrentTCB>
    1bd6:	d0 93 b2 22 	sts	0x22B2, r29	; 0x8022b2 <pxCurrentTCB+0x1>
    1bda:	80 91 5b 22 	lds	r24, 0x225B	; 0x80225b <uxTaskNumber>
    1bde:	8f 5f       	subi	r24, 0xFF	; 255
    1be0:	80 93 5b 22 	sts	0x225B, r24	; 0x80225b <uxTaskNumber>
    1be4:	8e 89       	ldd	r24, Y+22	; 0x16
    1be6:	90 91 61 22 	lds	r25, 0x2261	; 0x802261 <uxTopReadyPriority>
    1bea:	98 17       	cp	r25, r24
    1bec:	10 f4       	brcc	.+4      	; 0x1bf2 <xTaskCreate+0x194>
    1bee:	80 93 61 22 	sts	0x2261, r24	; 0x802261 <uxTopReadyPriority>
    1bf2:	90 e0       	ldi	r25, 0x00	; 0
    1bf4:	9c 01       	movw	r18, r24
    1bf6:	22 0f       	add	r18, r18
    1bf8:	33 1f       	adc	r19, r19
    1bfa:	22 0f       	add	r18, r18
    1bfc:	33 1f       	adc	r19, r19
    1bfe:	22 0f       	add	r18, r18
    1c00:	33 1f       	adc	r19, r19
    1c02:	82 0f       	add	r24, r18
    1c04:	93 1f       	adc	r25, r19
    1c06:	b6 01       	movw	r22, r12
    1c08:	8c 57       	subi	r24, 0x7C	; 124
    1c0a:	9d 4d       	sbci	r25, 0xDD	; 221
    1c0c:	c7 d9       	rcall	.-3186   	; 0xf9c <vListInsertEnd>
    1c0e:	0f 90       	pop	r0
    1c10:	0f be       	out	0x3f, r0	; 63
    1c12:	80 91 60 22 	lds	r24, 0x2260	; 0x802260 <xSchedulerRunning>
    1c16:	88 23       	and	r24, r24
    1c18:	59 f0       	breq	.+22     	; 0x1c30 <xTaskCreate+0x1d2>
    1c1a:	e0 91 b1 22 	lds	r30, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    1c1e:	f0 91 b2 22 	lds	r31, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    1c22:	96 89       	ldd	r25, Z+22	; 0x16
    1c24:	8e 89       	ldd	r24, Y+22	; 0x16
    1c26:	98 17       	cp	r25, r24
    1c28:	28 f4       	brcc	.+10     	; 0x1c34 <xTaskCreate+0x1d6>
    1c2a:	ed da       	rcall	.-2598   	; 0x1206 <vPortYield>
    1c2c:	81 e0       	ldi	r24, 0x01	; 1
    1c2e:	05 c0       	rjmp	.+10     	; 0x1c3a <xTaskCreate+0x1dc>
    1c30:	81 e0       	ldi	r24, 0x01	; 1
    1c32:	03 c0       	rjmp	.+6      	; 0x1c3a <xTaskCreate+0x1dc>
    1c34:	81 e0       	ldi	r24, 0x01	; 1
    1c36:	01 c0       	rjmp	.+2      	; 0x1c3a <xTaskCreate+0x1dc>
    1c38:	8f ef       	ldi	r24, 0xFF	; 255
    1c3a:	df 91       	pop	r29
    1c3c:	cf 91       	pop	r28
    1c3e:	1f 91       	pop	r17
    1c40:	0f 91       	pop	r16
    1c42:	ff 90       	pop	r15
    1c44:	ef 90       	pop	r14
    1c46:	df 90       	pop	r13
    1c48:	cf 90       	pop	r12
    1c4a:	bf 90       	pop	r11
    1c4c:	af 90       	pop	r10
    1c4e:	9f 90       	pop	r9
    1c50:	8f 90       	pop	r8
    1c52:	7f 90       	pop	r7
    1c54:	6f 90       	pop	r6
    1c56:	5f 90       	pop	r5
    1c58:	4f 90       	pop	r4
    1c5a:	08 95       	ret

00001c5c <vTaskStartScheduler>:
    1c5c:	ef 92       	push	r14
    1c5e:	ff 92       	push	r15
    1c60:	0f 93       	push	r16
    1c62:	0f 2e       	mov	r0, r31
    1c64:	f7 e5       	ldi	r31, 0x57	; 87
    1c66:	ef 2e       	mov	r14, r31
    1c68:	f2 e2       	ldi	r31, 0x22	; 34
    1c6a:	ff 2e       	mov	r15, r31
    1c6c:	f0 2d       	mov	r31, r0
    1c6e:	00 e0       	ldi	r16, 0x00	; 0
    1c70:	20 e0       	ldi	r18, 0x00	; 0
    1c72:	30 e0       	ldi	r19, 0x00	; 0
    1c74:	45 e5       	ldi	r20, 0x55	; 85
    1c76:	50 e0       	ldi	r21, 0x00	; 0
    1c78:	6d e0       	ldi	r22, 0x0D	; 13
    1c7a:	70 e2       	ldi	r23, 0x20	; 32
    1c7c:	87 ee       	ldi	r24, 0xE7	; 231
    1c7e:	9c e0       	ldi	r25, 0x0C	; 12
    1c80:	ee de       	rcall	.-548    	; 0x1a5e <xTaskCreate>
    1c82:	81 30       	cpi	r24, 0x01	; 1
    1c84:	91 f4       	brne	.+36     	; 0x1caa <vTaskStartScheduler+0x4e>
    1c86:	e0 d2       	rcall	.+1472   	; 0x2248 <xTimerCreateTimerTask>
    1c88:	81 30       	cpi	r24, 0x01	; 1
    1c8a:	79 f4       	brne	.+30     	; 0x1caa <vTaskStartScheduler+0x4e>
    1c8c:	f8 94       	cli
    1c8e:	8f ef       	ldi	r24, 0xFF	; 255
    1c90:	9f ef       	ldi	r25, 0xFF	; 255
    1c92:	80 93 59 22 	sts	0x2259, r24	; 0x802259 <xNextTaskUnblockTime>
    1c96:	90 93 5a 22 	sts	0x225A, r25	; 0x80225a <xNextTaskUnblockTime+0x1>
    1c9a:	81 e0       	ldi	r24, 0x01	; 1
    1c9c:	80 93 60 22 	sts	0x2260, r24	; 0x802260 <xSchedulerRunning>
    1ca0:	10 92 62 22 	sts	0x2262, r1	; 0x802262 <xTickCount>
    1ca4:	10 92 63 22 	sts	0x2263, r1	; 0x802263 <xTickCount+0x1>
    1ca8:	69 da       	rcall	.-2862   	; 0x117c <xPortStartScheduler>
    1caa:	0f 91       	pop	r16
    1cac:	ff 90       	pop	r15
    1cae:	ef 90       	pop	r14
    1cb0:	08 95       	ret

00001cb2 <vTaskSuspendAll>:
    1cb2:	80 91 56 22 	lds	r24, 0x2256	; 0x802256 <uxSchedulerSuspended>
    1cb6:	8f 5f       	subi	r24, 0xFF	; 255
    1cb8:	80 93 56 22 	sts	0x2256, r24	; 0x802256 <uxSchedulerSuspended>
    1cbc:	08 95       	ret

00001cbe <xTaskGetTickCount>:
    1cbe:	0f b6       	in	r0, 0x3f	; 63
    1cc0:	f8 94       	cli
    1cc2:	0f 92       	push	r0
    1cc4:	80 91 62 22 	lds	r24, 0x2262	; 0x802262 <xTickCount>
    1cc8:	90 91 63 22 	lds	r25, 0x2263	; 0x802263 <xTickCount+0x1>
    1ccc:	0f 90       	pop	r0
    1cce:	0f be       	out	0x3f, r0	; 63
    1cd0:	08 95       	ret

00001cd2 <xTaskIncrementTick>:
    1cd2:	df 92       	push	r13
    1cd4:	ef 92       	push	r14
    1cd6:	ff 92       	push	r15
    1cd8:	0f 93       	push	r16
    1cda:	1f 93       	push	r17
    1cdc:	cf 93       	push	r28
    1cde:	df 93       	push	r29
    1ce0:	80 91 56 22 	lds	r24, 0x2256	; 0x802256 <uxSchedulerSuspended>
    1ce4:	81 11       	cpse	r24, r1
    1ce6:	9a c0       	rjmp	.+308    	; 0x1e1c <xTaskIncrementTick+0x14a>
    1ce8:	e0 90 62 22 	lds	r14, 0x2262	; 0x802262 <xTickCount>
    1cec:	f0 90 63 22 	lds	r15, 0x2263	; 0x802263 <xTickCount+0x1>
    1cf0:	8f ef       	ldi	r24, 0xFF	; 255
    1cf2:	e8 1a       	sub	r14, r24
    1cf4:	f8 0a       	sbc	r15, r24
    1cf6:	e0 92 62 22 	sts	0x2262, r14	; 0x802262 <xTickCount>
    1cfa:	f0 92 63 22 	sts	0x2263, r15	; 0x802263 <xTickCount+0x1>
    1cfe:	e1 14       	cp	r14, r1
    1d00:	f1 04       	cpc	r15, r1
    1d02:	b1 f4       	brne	.+44     	; 0x1d30 <xTaskIncrementTick+0x5e>
    1d04:	80 91 70 22 	lds	r24, 0x2270	; 0x802270 <pxDelayedTaskList>
    1d08:	90 91 71 22 	lds	r25, 0x2271	; 0x802271 <pxDelayedTaskList+0x1>
    1d0c:	20 91 6e 22 	lds	r18, 0x226E	; 0x80226e <pxOverflowDelayedTaskList>
    1d10:	30 91 6f 22 	lds	r19, 0x226F	; 0x80226f <pxOverflowDelayedTaskList+0x1>
    1d14:	20 93 70 22 	sts	0x2270, r18	; 0x802270 <pxDelayedTaskList>
    1d18:	30 93 71 22 	sts	0x2271, r19	; 0x802271 <pxDelayedTaskList+0x1>
    1d1c:	80 93 6e 22 	sts	0x226E, r24	; 0x80226e <pxOverflowDelayedTaskList>
    1d20:	90 93 6f 22 	sts	0x226F, r25	; 0x80226f <pxOverflowDelayedTaskList+0x1>
    1d24:	80 91 5c 22 	lds	r24, 0x225C	; 0x80225c <xNumOfOverflows>
    1d28:	8f 5f       	subi	r24, 0xFF	; 255
    1d2a:	80 93 5c 22 	sts	0x225C, r24	; 0x80225c <xNumOfOverflows>
    1d2e:	30 de       	rcall	.-928    	; 0x1990 <prvResetNextTaskUnblockTime>
    1d30:	80 91 59 22 	lds	r24, 0x2259	; 0x802259 <xNextTaskUnblockTime>
    1d34:	90 91 5a 22 	lds	r25, 0x225A	; 0x80225a <xNextTaskUnblockTime+0x1>
    1d38:	e8 16       	cp	r14, r24
    1d3a:	f9 06       	cpc	r15, r25
    1d3c:	10 f4       	brcc	.+4      	; 0x1d42 <xTaskIncrementTick+0x70>
    1d3e:	d1 2c       	mov	r13, r1
    1d40:	4f c0       	rjmp	.+158    	; 0x1de0 <xTaskIncrementTick+0x10e>
    1d42:	d1 2c       	mov	r13, r1
    1d44:	e0 91 70 22 	lds	r30, 0x2270	; 0x802270 <pxDelayedTaskList>
    1d48:	f0 91 71 22 	lds	r31, 0x2271	; 0x802271 <pxDelayedTaskList+0x1>
    1d4c:	80 81       	ld	r24, Z
    1d4e:	81 11       	cpse	r24, r1
    1d50:	07 c0       	rjmp	.+14     	; 0x1d60 <xTaskIncrementTick+0x8e>
    1d52:	8f ef       	ldi	r24, 0xFF	; 255
    1d54:	9f ef       	ldi	r25, 0xFF	; 255
    1d56:	80 93 59 22 	sts	0x2259, r24	; 0x802259 <xNextTaskUnblockTime>
    1d5a:	90 93 5a 22 	sts	0x225A, r25	; 0x80225a <xNextTaskUnblockTime+0x1>
    1d5e:	40 c0       	rjmp	.+128    	; 0x1de0 <xTaskIncrementTick+0x10e>
    1d60:	e0 91 70 22 	lds	r30, 0x2270	; 0x802270 <pxDelayedTaskList>
    1d64:	f0 91 71 22 	lds	r31, 0x2271	; 0x802271 <pxDelayedTaskList+0x1>
    1d68:	05 80       	ldd	r0, Z+5	; 0x05
    1d6a:	f6 81       	ldd	r31, Z+6	; 0x06
    1d6c:	e0 2d       	mov	r30, r0
    1d6e:	c6 81       	ldd	r28, Z+6	; 0x06
    1d70:	d7 81       	ldd	r29, Z+7	; 0x07
    1d72:	8a 81       	ldd	r24, Y+2	; 0x02
    1d74:	9b 81       	ldd	r25, Y+3	; 0x03
    1d76:	e8 16       	cp	r14, r24
    1d78:	f9 06       	cpc	r15, r25
    1d7a:	28 f4       	brcc	.+10     	; 0x1d86 <xTaskIncrementTick+0xb4>
    1d7c:	80 93 59 22 	sts	0x2259, r24	; 0x802259 <xNextTaskUnblockTime>
    1d80:	90 93 5a 22 	sts	0x225A, r25	; 0x80225a <xNextTaskUnblockTime+0x1>
    1d84:	2d c0       	rjmp	.+90     	; 0x1de0 <xTaskIncrementTick+0x10e>
    1d86:	8e 01       	movw	r16, r28
    1d88:	0e 5f       	subi	r16, 0xFE	; 254
    1d8a:	1f 4f       	sbci	r17, 0xFF	; 255
    1d8c:	c8 01       	movw	r24, r16
    1d8e:	58 d9       	rcall	.-3408   	; 0x1040 <uxListRemove>
    1d90:	8c 89       	ldd	r24, Y+20	; 0x14
    1d92:	9d 89       	ldd	r25, Y+21	; 0x15
    1d94:	89 2b       	or	r24, r25
    1d96:	19 f0       	breq	.+6      	; 0x1d9e <xTaskIncrementTick+0xcc>
    1d98:	ce 01       	movw	r24, r28
    1d9a:	0c 96       	adiw	r24, 0x0c	; 12
    1d9c:	51 d9       	rcall	.-3422   	; 0x1040 <uxListRemove>
    1d9e:	8e 89       	ldd	r24, Y+22	; 0x16
    1da0:	90 91 61 22 	lds	r25, 0x2261	; 0x802261 <uxTopReadyPriority>
    1da4:	98 17       	cp	r25, r24
    1da6:	10 f4       	brcc	.+4      	; 0x1dac <xTaskIncrementTick+0xda>
    1da8:	80 93 61 22 	sts	0x2261, r24	; 0x802261 <uxTopReadyPriority>
    1dac:	90 e0       	ldi	r25, 0x00	; 0
    1dae:	9c 01       	movw	r18, r24
    1db0:	22 0f       	add	r18, r18
    1db2:	33 1f       	adc	r19, r19
    1db4:	22 0f       	add	r18, r18
    1db6:	33 1f       	adc	r19, r19
    1db8:	22 0f       	add	r18, r18
    1dba:	33 1f       	adc	r19, r19
    1dbc:	82 0f       	add	r24, r18
    1dbe:	93 1f       	adc	r25, r19
    1dc0:	b8 01       	movw	r22, r16
    1dc2:	8c 57       	subi	r24, 0x7C	; 124
    1dc4:	9d 4d       	sbci	r25, 0xDD	; 221
    1dc6:	ea d8       	rcall	.-3628   	; 0xf9c <vListInsertEnd>
    1dc8:	e0 91 b1 22 	lds	r30, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    1dcc:	f0 91 b2 22 	lds	r31, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    1dd0:	9e 89       	ldd	r25, Y+22	; 0x16
    1dd2:	86 89       	ldd	r24, Z+22	; 0x16
    1dd4:	98 17       	cp	r25, r24
    1dd6:	08 f4       	brcc	.+2      	; 0x1dda <xTaskIncrementTick+0x108>
    1dd8:	b5 cf       	rjmp	.-150    	; 0x1d44 <xTaskIncrementTick+0x72>
    1dda:	dd 24       	eor	r13, r13
    1ddc:	d3 94       	inc	r13
    1dde:	b2 cf       	rjmp	.-156    	; 0x1d44 <xTaskIncrementTick+0x72>
    1de0:	e0 91 b1 22 	lds	r30, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    1de4:	f0 91 b2 22 	lds	r31, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    1de8:	86 89       	ldd	r24, Z+22	; 0x16
    1dea:	90 e0       	ldi	r25, 0x00	; 0
    1dec:	fc 01       	movw	r30, r24
    1dee:	ee 0f       	add	r30, r30
    1df0:	ff 1f       	adc	r31, r31
    1df2:	ee 0f       	add	r30, r30
    1df4:	ff 1f       	adc	r31, r31
    1df6:	ee 0f       	add	r30, r30
    1df8:	ff 1f       	adc	r31, r31
    1dfa:	8e 0f       	add	r24, r30
    1dfc:	9f 1f       	adc	r25, r31
    1dfe:	fc 01       	movw	r30, r24
    1e00:	ec 57       	subi	r30, 0x7C	; 124
    1e02:	fd 4d       	sbci	r31, 0xDD	; 221
    1e04:	80 81       	ld	r24, Z
    1e06:	82 30       	cpi	r24, 0x02	; 2
    1e08:	10 f0       	brcs	.+4      	; 0x1e0e <xTaskIncrementTick+0x13c>
    1e0a:	dd 24       	eor	r13, r13
    1e0c:	d3 94       	inc	r13
    1e0e:	80 91 5d 22 	lds	r24, 0x225D	; 0x80225d <xYieldPending>
    1e12:	88 23       	and	r24, r24
    1e14:	69 f0       	breq	.+26     	; 0x1e30 <xTaskIncrementTick+0x15e>
    1e16:	dd 24       	eor	r13, r13
    1e18:	d3 94       	inc	r13
    1e1a:	0a c0       	rjmp	.+20     	; 0x1e30 <xTaskIncrementTick+0x15e>
    1e1c:	80 91 5e 22 	lds	r24, 0x225E	; 0x80225e <xPendedTicks>
    1e20:	90 91 5f 22 	lds	r25, 0x225F	; 0x80225f <xPendedTicks+0x1>
    1e24:	01 96       	adiw	r24, 0x01	; 1
    1e26:	80 93 5e 22 	sts	0x225E, r24	; 0x80225e <xPendedTicks>
    1e2a:	90 93 5f 22 	sts	0x225F, r25	; 0x80225f <xPendedTicks+0x1>
    1e2e:	d1 2c       	mov	r13, r1
    1e30:	8d 2d       	mov	r24, r13
    1e32:	df 91       	pop	r29
    1e34:	cf 91       	pop	r28
    1e36:	1f 91       	pop	r17
    1e38:	0f 91       	pop	r16
    1e3a:	ff 90       	pop	r15
    1e3c:	ef 90       	pop	r14
    1e3e:	df 90       	pop	r13
    1e40:	08 95       	ret

00001e42 <xTaskResumeAll>:
    1e42:	df 92       	push	r13
    1e44:	ef 92       	push	r14
    1e46:	ff 92       	push	r15
    1e48:	0f 93       	push	r16
    1e4a:	1f 93       	push	r17
    1e4c:	cf 93       	push	r28
    1e4e:	df 93       	push	r29
    1e50:	0f b6       	in	r0, 0x3f	; 63
    1e52:	f8 94       	cli
    1e54:	0f 92       	push	r0
    1e56:	80 91 56 22 	lds	r24, 0x2256	; 0x802256 <uxSchedulerSuspended>
    1e5a:	81 50       	subi	r24, 0x01	; 1
    1e5c:	80 93 56 22 	sts	0x2256, r24	; 0x802256 <uxSchedulerSuspended>
    1e60:	80 91 56 22 	lds	r24, 0x2256	; 0x802256 <uxSchedulerSuspended>
    1e64:	81 11       	cpse	r24, r1
    1e66:	5d c0       	rjmp	.+186    	; 0x1f22 <xTaskResumeAll+0xe0>
    1e68:	80 91 64 22 	lds	r24, 0x2264	; 0x802264 <uxCurrentNumberOfTasks>
    1e6c:	81 11       	cpse	r24, r1
    1e6e:	30 c0       	rjmp	.+96     	; 0x1ed0 <xTaskResumeAll+0x8e>
    1e70:	5b c0       	rjmp	.+182    	; 0x1f28 <xTaskResumeAll+0xe6>
    1e72:	d7 01       	movw	r26, r14
    1e74:	15 96       	adiw	r26, 0x05	; 5
    1e76:	ed 91       	ld	r30, X+
    1e78:	fc 91       	ld	r31, X
    1e7a:	16 97       	sbiw	r26, 0x06	; 6
    1e7c:	c6 81       	ldd	r28, Z+6	; 0x06
    1e7e:	d7 81       	ldd	r29, Z+7	; 0x07
    1e80:	ce 01       	movw	r24, r28
    1e82:	0c 96       	adiw	r24, 0x0c	; 12
    1e84:	dd d8       	rcall	.-3654   	; 0x1040 <uxListRemove>
    1e86:	8e 01       	movw	r16, r28
    1e88:	0e 5f       	subi	r16, 0xFE	; 254
    1e8a:	1f 4f       	sbci	r17, 0xFF	; 255
    1e8c:	c8 01       	movw	r24, r16
    1e8e:	d8 d8       	rcall	.-3664   	; 0x1040 <uxListRemove>
    1e90:	8e 89       	ldd	r24, Y+22	; 0x16
    1e92:	90 91 61 22 	lds	r25, 0x2261	; 0x802261 <uxTopReadyPriority>
    1e96:	98 17       	cp	r25, r24
    1e98:	10 f4       	brcc	.+4      	; 0x1e9e <xTaskResumeAll+0x5c>
    1e9a:	80 93 61 22 	sts	0x2261, r24	; 0x802261 <uxTopReadyPriority>
    1e9e:	90 e0       	ldi	r25, 0x00	; 0
    1ea0:	9c 01       	movw	r18, r24
    1ea2:	22 0f       	add	r18, r18
    1ea4:	33 1f       	adc	r19, r19
    1ea6:	22 0f       	add	r18, r18
    1ea8:	33 1f       	adc	r19, r19
    1eaa:	22 0f       	add	r18, r18
    1eac:	33 1f       	adc	r19, r19
    1eae:	82 0f       	add	r24, r18
    1eb0:	93 1f       	adc	r25, r19
    1eb2:	b8 01       	movw	r22, r16
    1eb4:	8c 57       	subi	r24, 0x7C	; 124
    1eb6:	9d 4d       	sbci	r25, 0xDD	; 221
    1eb8:	71 d8       	rcall	.-3870   	; 0xf9c <vListInsertEnd>
    1eba:	e0 91 b1 22 	lds	r30, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    1ebe:	f0 91 b2 22 	lds	r31, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    1ec2:	9e 89       	ldd	r25, Y+22	; 0x16
    1ec4:	86 89       	ldd	r24, Z+22	; 0x16
    1ec6:	98 17       	cp	r25, r24
    1ec8:	68 f0       	brcs	.+26     	; 0x1ee4 <xTaskResumeAll+0xa2>
    1eca:	d0 92 5d 22 	sts	0x225D, r13	; 0x80225d <xYieldPending>
    1ece:	0a c0       	rjmp	.+20     	; 0x1ee4 <xTaskResumeAll+0xa2>
    1ed0:	c0 e0       	ldi	r28, 0x00	; 0
    1ed2:	d0 e0       	ldi	r29, 0x00	; 0
    1ed4:	0f 2e       	mov	r0, r31
    1ed6:	f5 e6       	ldi	r31, 0x65	; 101
    1ed8:	ef 2e       	mov	r14, r31
    1eda:	f2 e2       	ldi	r31, 0x22	; 34
    1edc:	ff 2e       	mov	r15, r31
    1ede:	f0 2d       	mov	r31, r0
    1ee0:	dd 24       	eor	r13, r13
    1ee2:	d3 94       	inc	r13
    1ee4:	f7 01       	movw	r30, r14
    1ee6:	80 81       	ld	r24, Z
    1ee8:	81 11       	cpse	r24, r1
    1eea:	c3 cf       	rjmp	.-122    	; 0x1e72 <xTaskResumeAll+0x30>
    1eec:	cd 2b       	or	r28, r29
    1eee:	09 f0       	breq	.+2      	; 0x1ef2 <xTaskResumeAll+0xb0>
    1ef0:	4f dd       	rcall	.-1378   	; 0x1990 <prvResetNextTaskUnblockTime>
    1ef2:	c0 91 5e 22 	lds	r28, 0x225E	; 0x80225e <xPendedTicks>
    1ef6:	d0 91 5f 22 	lds	r29, 0x225F	; 0x80225f <xPendedTicks+0x1>
    1efa:	20 97       	sbiw	r28, 0x00	; 0
    1efc:	59 f0       	breq	.+22     	; 0x1f14 <xTaskResumeAll+0xd2>
    1efe:	11 e0       	ldi	r17, 0x01	; 1
    1f00:	e8 de       	rcall	.-560    	; 0x1cd2 <xTaskIncrementTick>
    1f02:	81 11       	cpse	r24, r1
    1f04:	10 93 5d 22 	sts	0x225D, r17	; 0x80225d <xYieldPending>
    1f08:	21 97       	sbiw	r28, 0x01	; 1
    1f0a:	d1 f7       	brne	.-12     	; 0x1f00 <xTaskResumeAll+0xbe>
    1f0c:	10 92 5e 22 	sts	0x225E, r1	; 0x80225e <xPendedTicks>
    1f10:	10 92 5f 22 	sts	0x225F, r1	; 0x80225f <xPendedTicks+0x1>
    1f14:	80 91 5d 22 	lds	r24, 0x225D	; 0x80225d <xYieldPending>
    1f18:	88 23       	and	r24, r24
    1f1a:	29 f0       	breq	.+10     	; 0x1f26 <xTaskResumeAll+0xe4>
    1f1c:	74 d9       	rcall	.-3352   	; 0x1206 <vPortYield>
    1f1e:	81 e0       	ldi	r24, 0x01	; 1
    1f20:	03 c0       	rjmp	.+6      	; 0x1f28 <xTaskResumeAll+0xe6>
    1f22:	80 e0       	ldi	r24, 0x00	; 0
    1f24:	01 c0       	rjmp	.+2      	; 0x1f28 <xTaskResumeAll+0xe6>
    1f26:	80 e0       	ldi	r24, 0x00	; 0
    1f28:	0f 90       	pop	r0
    1f2a:	0f be       	out	0x3f, r0	; 63
    1f2c:	df 91       	pop	r29
    1f2e:	cf 91       	pop	r28
    1f30:	1f 91       	pop	r17
    1f32:	0f 91       	pop	r16
    1f34:	ff 90       	pop	r15
    1f36:	ef 90       	pop	r14
    1f38:	df 90       	pop	r13
    1f3a:	08 95       	ret

00001f3c <vTaskDelay>:
    1f3c:	cf 93       	push	r28
    1f3e:	df 93       	push	r29
    1f40:	ec 01       	movw	r28, r24
    1f42:	89 2b       	or	r24, r25
    1f44:	39 f0       	breq	.+14     	; 0x1f54 <vTaskDelay+0x18>
    1f46:	b5 de       	rcall	.-662    	; 0x1cb2 <vTaskSuspendAll>
    1f48:	60 e0       	ldi	r22, 0x00	; 0
    1f4a:	ce 01       	movw	r24, r28
    1f4c:	47 dd       	rcall	.-1394   	; 0x19dc <prvAddCurrentTaskToDelayedList>
    1f4e:	79 df       	rcall	.-270    	; 0x1e42 <xTaskResumeAll>
    1f50:	81 11       	cpse	r24, r1
    1f52:	01 c0       	rjmp	.+2      	; 0x1f56 <vTaskDelay+0x1a>
    1f54:	58 d9       	rcall	.-3408   	; 0x1206 <vPortYield>
    1f56:	df 91       	pop	r29
    1f58:	cf 91       	pop	r28
    1f5a:	08 95       	ret

00001f5c <vTaskSwitchContext>:
    1f5c:	80 91 56 22 	lds	r24, 0x2256	; 0x802256 <uxSchedulerSuspended>
    1f60:	88 23       	and	r24, r24
    1f62:	21 f0       	breq	.+8      	; 0x1f6c <vTaskSwitchContext+0x10>
    1f64:	81 e0       	ldi	r24, 0x01	; 1
    1f66:	80 93 5d 22 	sts	0x225D, r24	; 0x80225d <xYieldPending>
    1f6a:	08 95       	ret
    1f6c:	10 92 5d 22 	sts	0x225D, r1	; 0x80225d <xYieldPending>
    1f70:	20 91 61 22 	lds	r18, 0x2261	; 0x802261 <uxTopReadyPriority>
    1f74:	82 2f       	mov	r24, r18
    1f76:	90 e0       	ldi	r25, 0x00	; 0
    1f78:	fc 01       	movw	r30, r24
    1f7a:	ee 0f       	add	r30, r30
    1f7c:	ff 1f       	adc	r31, r31
    1f7e:	ee 0f       	add	r30, r30
    1f80:	ff 1f       	adc	r31, r31
    1f82:	ee 0f       	add	r30, r30
    1f84:	ff 1f       	adc	r31, r31
    1f86:	e8 0f       	add	r30, r24
    1f88:	f9 1f       	adc	r31, r25
    1f8a:	ec 57       	subi	r30, 0x7C	; 124
    1f8c:	fd 4d       	sbci	r31, 0xDD	; 221
    1f8e:	30 81       	ld	r19, Z
    1f90:	31 11       	cpse	r19, r1
    1f92:	11 c0       	rjmp	.+34     	; 0x1fb6 <vTaskSwitchContext+0x5a>
    1f94:	21 50       	subi	r18, 0x01	; 1
    1f96:	82 2f       	mov	r24, r18
    1f98:	90 e0       	ldi	r25, 0x00	; 0
    1f9a:	fc 01       	movw	r30, r24
    1f9c:	ee 0f       	add	r30, r30
    1f9e:	ff 1f       	adc	r31, r31
    1fa0:	ee 0f       	add	r30, r30
    1fa2:	ff 1f       	adc	r31, r31
    1fa4:	ee 0f       	add	r30, r30
    1fa6:	ff 1f       	adc	r31, r31
    1fa8:	e8 0f       	add	r30, r24
    1faa:	f9 1f       	adc	r31, r25
    1fac:	ec 57       	subi	r30, 0x7C	; 124
    1fae:	fd 4d       	sbci	r31, 0xDD	; 221
    1fb0:	30 81       	ld	r19, Z
    1fb2:	33 23       	and	r19, r19
    1fb4:	79 f3       	breq	.-34     	; 0x1f94 <vTaskSwitchContext+0x38>
    1fb6:	ac 01       	movw	r20, r24
    1fb8:	44 0f       	add	r20, r20
    1fba:	55 1f       	adc	r21, r21
    1fbc:	44 0f       	add	r20, r20
    1fbe:	55 1f       	adc	r21, r21
    1fc0:	44 0f       	add	r20, r20
    1fc2:	55 1f       	adc	r21, r21
    1fc4:	48 0f       	add	r20, r24
    1fc6:	59 1f       	adc	r21, r25
    1fc8:	da 01       	movw	r26, r20
    1fca:	ac 57       	subi	r26, 0x7C	; 124
    1fcc:	bd 4d       	sbci	r27, 0xDD	; 221
    1fce:	11 96       	adiw	r26, 0x01	; 1
    1fd0:	ed 91       	ld	r30, X+
    1fd2:	fc 91       	ld	r31, X
    1fd4:	12 97       	sbiw	r26, 0x02	; 2
    1fd6:	02 80       	ldd	r0, Z+2	; 0x02
    1fd8:	f3 81       	ldd	r31, Z+3	; 0x03
    1fda:	e0 2d       	mov	r30, r0
    1fdc:	11 96       	adiw	r26, 0x01	; 1
    1fde:	ed 93       	st	X+, r30
    1fe0:	fc 93       	st	X, r31
    1fe2:	12 97       	sbiw	r26, 0x02	; 2
    1fe4:	49 57       	subi	r20, 0x79	; 121
    1fe6:	5d 4d       	sbci	r21, 0xDD	; 221
    1fe8:	e4 17       	cp	r30, r20
    1fea:	f5 07       	cpc	r31, r21
    1fec:	29 f4       	brne	.+10     	; 0x1ff8 <vTaskSwitchContext+0x9c>
    1fee:	42 81       	ldd	r20, Z+2	; 0x02
    1ff0:	53 81       	ldd	r21, Z+3	; 0x03
    1ff2:	fd 01       	movw	r30, r26
    1ff4:	41 83       	std	Z+1, r20	; 0x01
    1ff6:	52 83       	std	Z+2, r21	; 0x02
    1ff8:	fc 01       	movw	r30, r24
    1ffa:	ee 0f       	add	r30, r30
    1ffc:	ff 1f       	adc	r31, r31
    1ffe:	ee 0f       	add	r30, r30
    2000:	ff 1f       	adc	r31, r31
    2002:	ee 0f       	add	r30, r30
    2004:	ff 1f       	adc	r31, r31
    2006:	8e 0f       	add	r24, r30
    2008:	9f 1f       	adc	r25, r31
    200a:	fc 01       	movw	r30, r24
    200c:	ec 57       	subi	r30, 0x7C	; 124
    200e:	fd 4d       	sbci	r31, 0xDD	; 221
    2010:	01 80       	ldd	r0, Z+1	; 0x01
    2012:	f2 81       	ldd	r31, Z+2	; 0x02
    2014:	e0 2d       	mov	r30, r0
    2016:	86 81       	ldd	r24, Z+6	; 0x06
    2018:	97 81       	ldd	r25, Z+7	; 0x07
    201a:	80 93 b1 22 	sts	0x22B1, r24	; 0x8022b1 <pxCurrentTCB>
    201e:	90 93 b2 22 	sts	0x22B2, r25	; 0x8022b2 <pxCurrentTCB+0x1>
    2022:	20 93 61 22 	sts	0x2261, r18	; 0x802261 <uxTopReadyPriority>
    2026:	08 95       	ret

00002028 <vTaskPlaceOnEventList>:
    2028:	cf 93       	push	r28
    202a:	df 93       	push	r29
    202c:	eb 01       	movw	r28, r22
    202e:	60 91 b1 22 	lds	r22, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    2032:	70 91 b2 22 	lds	r23, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    2036:	64 5f       	subi	r22, 0xF4	; 244
    2038:	7f 4f       	sbci	r23, 0xFF	; 255
    203a:	0e 94 ef 07 	call	0xfde	; 0xfde <vListInsert>
    203e:	61 e0       	ldi	r22, 0x01	; 1
    2040:	ce 01       	movw	r24, r28
    2042:	cc dc       	rcall	.-1640   	; 0x19dc <prvAddCurrentTaskToDelayedList>
    2044:	df 91       	pop	r29
    2046:	cf 91       	pop	r28
    2048:	08 95       	ret

0000204a <vTaskPlaceOnEventListRestricted>:
    204a:	0f 93       	push	r16
    204c:	1f 93       	push	r17
    204e:	cf 93       	push	r28
    2050:	8b 01       	movw	r16, r22
    2052:	c4 2f       	mov	r28, r20
    2054:	60 91 b1 22 	lds	r22, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    2058:	70 91 b2 22 	lds	r23, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    205c:	64 5f       	subi	r22, 0xF4	; 244
    205e:	7f 4f       	sbci	r23, 0xFF	; 255
    2060:	0e 94 ce 07 	call	0xf9c	; 0xf9c <vListInsertEnd>
    2064:	cc 23       	and	r28, r28
    2066:	11 f0       	breq	.+4      	; 0x206c <vTaskPlaceOnEventListRestricted+0x22>
    2068:	0f ef       	ldi	r16, 0xFF	; 255
    206a:	1f ef       	ldi	r17, 0xFF	; 255
    206c:	6c 2f       	mov	r22, r28
    206e:	c8 01       	movw	r24, r16
    2070:	b5 dc       	rcall	.-1686   	; 0x19dc <prvAddCurrentTaskToDelayedList>
    2072:	cf 91       	pop	r28
    2074:	1f 91       	pop	r17
    2076:	0f 91       	pop	r16
    2078:	08 95       	ret

0000207a <xTaskRemoveFromEventList>:
    207a:	0f 93       	push	r16
    207c:	1f 93       	push	r17
    207e:	cf 93       	push	r28
    2080:	df 93       	push	r29
    2082:	dc 01       	movw	r26, r24
    2084:	15 96       	adiw	r26, 0x05	; 5
    2086:	ed 91       	ld	r30, X+
    2088:	fc 91       	ld	r31, X
    208a:	16 97       	sbiw	r26, 0x06	; 6
    208c:	c6 81       	ldd	r28, Z+6	; 0x06
    208e:	d7 81       	ldd	r29, Z+7	; 0x07
    2090:	8e 01       	movw	r16, r28
    2092:	04 5f       	subi	r16, 0xF4	; 244
    2094:	1f 4f       	sbci	r17, 0xFF	; 255
    2096:	c8 01       	movw	r24, r16
    2098:	0e 94 20 08 	call	0x1040	; 0x1040 <uxListRemove>
    209c:	80 91 56 22 	lds	r24, 0x2256	; 0x802256 <uxSchedulerSuspended>
    20a0:	81 11       	cpse	r24, r1
    20a2:	1c c0       	rjmp	.+56     	; 0x20dc <xTaskRemoveFromEventList+0x62>
    20a4:	0a 50       	subi	r16, 0x0A	; 10
    20a6:	11 09       	sbc	r17, r1
    20a8:	c8 01       	movw	r24, r16
    20aa:	0e 94 20 08 	call	0x1040	; 0x1040 <uxListRemove>
    20ae:	8e 89       	ldd	r24, Y+22	; 0x16
    20b0:	90 91 61 22 	lds	r25, 0x2261	; 0x802261 <uxTopReadyPriority>
    20b4:	98 17       	cp	r25, r24
    20b6:	10 f4       	brcc	.+4      	; 0x20bc <xTaskRemoveFromEventList+0x42>
    20b8:	80 93 61 22 	sts	0x2261, r24	; 0x802261 <uxTopReadyPriority>
    20bc:	90 e0       	ldi	r25, 0x00	; 0
    20be:	9c 01       	movw	r18, r24
    20c0:	22 0f       	add	r18, r18
    20c2:	33 1f       	adc	r19, r19
    20c4:	22 0f       	add	r18, r18
    20c6:	33 1f       	adc	r19, r19
    20c8:	22 0f       	add	r18, r18
    20ca:	33 1f       	adc	r19, r19
    20cc:	82 0f       	add	r24, r18
    20ce:	93 1f       	adc	r25, r19
    20d0:	b8 01       	movw	r22, r16
    20d2:	8c 57       	subi	r24, 0x7C	; 124
    20d4:	9d 4d       	sbci	r25, 0xDD	; 221
    20d6:	0e 94 ce 07 	call	0xf9c	; 0xf9c <vListInsertEnd>
    20da:	05 c0       	rjmp	.+10     	; 0x20e6 <xTaskRemoveFromEventList+0x6c>
    20dc:	b8 01       	movw	r22, r16
    20de:	85 e6       	ldi	r24, 0x65	; 101
    20e0:	92 e2       	ldi	r25, 0x22	; 34
    20e2:	0e 94 ce 07 	call	0xf9c	; 0xf9c <vListInsertEnd>
    20e6:	e0 91 b1 22 	lds	r30, 0x22B1	; 0x8022b1 <pxCurrentTCB>
    20ea:	f0 91 b2 22 	lds	r31, 0x22B2	; 0x8022b2 <pxCurrentTCB+0x1>
    20ee:	9e 89       	ldd	r25, Y+22	; 0x16
    20f0:	86 89       	ldd	r24, Z+22	; 0x16
    20f2:	89 17       	cp	r24, r25
    20f4:	20 f4       	brcc	.+8      	; 0x20fe <xTaskRemoveFromEventList+0x84>
    20f6:	81 e0       	ldi	r24, 0x01	; 1
    20f8:	80 93 5d 22 	sts	0x225D, r24	; 0x80225d <xYieldPending>
    20fc:	01 c0       	rjmp	.+2      	; 0x2100 <xTaskRemoveFromEventList+0x86>
    20fe:	80 e0       	ldi	r24, 0x00	; 0
    2100:	df 91       	pop	r29
    2102:	cf 91       	pop	r28
    2104:	1f 91       	pop	r17
    2106:	0f 91       	pop	r16
    2108:	08 95       	ret

0000210a <vTaskInternalSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	/* For internal use only as it does not use a critical section. */
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    210a:	20 91 5c 22 	lds	r18, 0x225C	; 0x80225c <xNumOfOverflows>
    210e:	fc 01       	movw	r30, r24
    2110:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    2112:	20 91 62 22 	lds	r18, 0x2262	; 0x802262 <xTickCount>
    2116:	30 91 63 22 	lds	r19, 0x2263	; 0x802263 <xTickCount+0x1>
    211a:	21 83       	std	Z+1, r18	; 0x01
    211c:	32 83       	std	Z+2, r19	; 0x02
    211e:	08 95       	ret

00002120 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    2120:	0f b6       	in	r0, 0x3f	; 63
    2122:	f8 94       	cli
    2124:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    2126:	20 91 62 22 	lds	r18, 0x2262	; 0x802262 <xTickCount>
    212a:	30 91 63 22 	lds	r19, 0x2263	; 0x802263 <xTickCount+0x1>
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    212e:	dc 01       	movw	r26, r24
    2130:	11 96       	adiw	r26, 0x01	; 1
    2132:	4d 91       	ld	r20, X+
    2134:	5c 91       	ld	r21, X
    2136:	12 97       	sbiw	r26, 0x02	; 2
				xReturn = pdFALSE;
			}
			else
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    2138:	e0 91 5c 22 	lds	r30, 0x225C	; 0x80225c <xNumOfOverflows>
    213c:	fc 91       	ld	r31, X
    213e:	fe 17       	cp	r31, r30
    2140:	19 f0       	breq	.+6      	; 0x2148 <xTaskCheckForTimeOut+0x28>
    2142:	24 17       	cp	r18, r20
    2144:	35 07       	cpc	r19, r21
    2146:	98 f4       	brcc	.+38     	; 0x216e <xTaskCheckForTimeOut+0x4e>

	taskENTER_CRITICAL();
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
    2148:	24 1b       	sub	r18, r20
    214a:	35 0b       	sbc	r19, r21
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
		}
		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
    214c:	fb 01       	movw	r30, r22
    214e:	40 81       	ld	r20, Z
    2150:	51 81       	ldd	r21, Z+1	; 0x01
    2152:	24 17       	cp	r18, r20
    2154:	35 07       	cpc	r19, r21
    2156:	38 f4       	brcc	.+14     	; 0x2166 <xTaskCheckForTimeOut+0x46>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= xElapsedTime;
    2158:	42 1b       	sub	r20, r18
    215a:	53 0b       	sbc	r21, r19
    215c:	40 83       	st	Z, r20
    215e:	51 83       	std	Z+1, r21	; 0x01
			vTaskInternalSetTimeOutState( pxTimeOut );
    2160:	d4 df       	rcall	.-88     	; 0x210a <vTaskInternalSetTimeOutState>
			xReturn = pdFALSE;
    2162:	80 e0       	ldi	r24, 0x00	; 0
    2164:	05 c0       	rjmp	.+10     	; 0x2170 <xTaskCheckForTimeOut+0x50>
		}
		else
		{
			*pxTicksToWait = 0;
    2166:	10 82       	st	Z, r1
    2168:	11 82       	std	Z+1, r1	; 0x01
			xReturn = pdTRUE;
    216a:	81 e0       	ldi	r24, 0x01	; 1
    216c:	01 c0       	rjmp	.+2      	; 0x2170 <xTaskCheckForTimeOut+0x50>
			/* The tick count is greater than the time at which
			vTaskSetTimeout() was called, but has also overflowed since
			vTaskSetTimeOut() was called.  It must have wrapped all the way
			around and gone past again. This passed since vTaskSetTimeout()
			was called. */
			xReturn = pdTRUE;
    216e:	81 e0       	ldi	r24, 0x01	; 1
		{
			*pxTicksToWait = 0;
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
    2170:	0f 90       	pop	r0
    2172:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    2174:	08 95       	ret

00002176 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    2176:	81 e0       	ldi	r24, 0x01	; 1
    2178:	80 93 5d 22 	sts	0x225D, r24	; 0x80225d <xYieldPending>
    217c:	08 95       	ret

0000217e <xTaskGetSchedulerState>:

	BaseType_t xTaskGetSchedulerState( void )
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
    217e:	80 91 60 22 	lds	r24, 0x2260	; 0x802260 <xSchedulerRunning>
    2182:	88 23       	and	r24, r24
    2184:	31 f0       	breq	.+12     	; 0x2192 <xTaskGetSchedulerState+0x14>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    2186:	80 91 56 22 	lds	r24, 0x2256	; 0x802256 <uxSchedulerSuspended>
    218a:	88 23       	and	r24, r24
    218c:	21 f0       	breq	.+8      	; 0x2196 <xTaskGetSchedulerState+0x18>
			{
				xReturn = taskSCHEDULER_RUNNING;
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    218e:	80 e0       	ldi	r24, 0x00	; 0
    2190:	08 95       	ret
	{
	BaseType_t xReturn;

		if( xSchedulerRunning == pdFALSE )
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    2192:	81 e0       	ldi	r24, 0x01	; 1
    2194:	08 95       	ret
		}
		else
		{
			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
			{
				xReturn = taskSCHEDULER_RUNNING;
    2196:	82 e0       	ldi	r24, 0x02	; 2
				xReturn = taskSCHEDULER_SUSPENDED;
			}
		}

		return xReturn;
	}
    2198:	08 95       	ret

0000219a <prvInsertTimerInActiveList>:
			pxNewTimer->ucStatus = 0x00;
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
		}

		return pxNewTimer;
	}
    219a:	fc 01       	movw	r30, r24
    219c:	62 83       	std	Z+2, r22	; 0x02
    219e:	73 83       	std	Z+3, r23	; 0x03
    21a0:	80 87       	std	Z+8, r24	; 0x08
    21a2:	91 87       	std	Z+9, r25	; 0x09
    21a4:	46 17       	cp	r20, r22
    21a6:	57 07       	cpc	r21, r23
    21a8:	90 f0       	brcs	.+36     	; 0x21ce <prvInsertTimerInActiveList+0x34>
    21aa:	42 1b       	sub	r20, r18
    21ac:	53 0b       	sbc	r21, r19
    21ae:	84 85       	ldd	r24, Z+12	; 0x0c
    21b0:	95 85       	ldd	r25, Z+13	; 0x0d
    21b2:	48 17       	cp	r20, r24
    21b4:	59 07       	cpc	r21, r25
    21b6:	e0 f4       	brcc	.+56     	; 0x21f0 <prvInsertTimerInActiveList+0x56>
    21b8:	bf 01       	movw	r22, r30
    21ba:	6e 5f       	subi	r22, 0xFE	; 254
    21bc:	7f 4f       	sbci	r23, 0xFF	; 255
    21be:	80 91 b9 22 	lds	r24, 0x22B9	; 0x8022b9 <pxOverflowTimerList>
    21c2:	90 91 ba 22 	lds	r25, 0x22BA	; 0x8022ba <pxOverflowTimerList+0x1>
    21c6:	0e 94 ef 07 	call	0xfde	; 0xfde <vListInsert>
    21ca:	80 e0       	ldi	r24, 0x00	; 0
    21cc:	08 95       	ret
    21ce:	42 17       	cp	r20, r18
    21d0:	53 07       	cpc	r21, r19
    21d2:	18 f4       	brcc	.+6      	; 0x21da <prvInsertTimerInActiveList+0x40>
    21d4:	62 17       	cp	r22, r18
    21d6:	73 07       	cpc	r23, r19
    21d8:	68 f4       	brcc	.+26     	; 0x21f4 <prvInsertTimerInActiveList+0x5a>
    21da:	bf 01       	movw	r22, r30
    21dc:	6e 5f       	subi	r22, 0xFE	; 254
    21de:	7f 4f       	sbci	r23, 0xFF	; 255
    21e0:	80 91 bb 22 	lds	r24, 0x22BB	; 0x8022bb <pxCurrentTimerList>
    21e4:	90 91 bc 22 	lds	r25, 0x22BC	; 0x8022bc <pxCurrentTimerList+0x1>
    21e8:	0e 94 ef 07 	call	0xfde	; 0xfde <vListInsert>
    21ec:	80 e0       	ldi	r24, 0x00	; 0
    21ee:	08 95       	ret
    21f0:	81 e0       	ldi	r24, 0x01	; 1
    21f2:	08 95       	ret
    21f4:	81 e0       	ldi	r24, 0x01	; 1
    21f6:	08 95       	ret

000021f8 <prvCheckForValidListAndQueue>:
    21f8:	0f b6       	in	r0, 0x3f	; 63
    21fa:	f8 94       	cli
    21fc:	0f 92       	push	r0
    21fe:	80 91 b7 22 	lds	r24, 0x22B7	; 0x8022b7 <xTimerQueue>
    2202:	90 91 b8 22 	lds	r25, 0x22B8	; 0x8022b8 <xTimerQueue+0x1>
    2206:	89 2b       	or	r24, r25
    2208:	e1 f4       	brne	.+56     	; 0x2242 <prvCheckForValidListAndQueue+0x4a>
    220a:	86 ec       	ldi	r24, 0xC6	; 198
    220c:	92 e2       	ldi	r25, 0x22	; 34
    220e:	0e 94 bc 07 	call	0xf78	; 0xf78 <vListInitialise>
    2212:	8d eb       	ldi	r24, 0xBD	; 189
    2214:	92 e2       	ldi	r25, 0x22	; 34
    2216:	0e 94 bc 07 	call	0xf78	; 0xf78 <vListInitialise>
    221a:	86 ec       	ldi	r24, 0xC6	; 198
    221c:	92 e2       	ldi	r25, 0x22	; 34
    221e:	80 93 bb 22 	sts	0x22BB, r24	; 0x8022bb <pxCurrentTimerList>
    2222:	90 93 bc 22 	sts	0x22BC, r25	; 0x8022bc <pxCurrentTimerList+0x1>
    2226:	8d eb       	ldi	r24, 0xBD	; 189
    2228:	92 e2       	ldi	r25, 0x22	; 34
    222a:	80 93 b9 22 	sts	0x22B9, r24	; 0x8022b9 <pxOverflowTimerList>
    222e:	90 93 ba 22 	sts	0x22BA, r25	; 0x8022ba <pxOverflowTimerList+0x1>
    2232:	40 e0       	ldi	r20, 0x00	; 0
    2234:	65 e0       	ldi	r22, 0x05	; 5
    2236:	8a e0       	ldi	r24, 0x0A	; 10
    2238:	ab d9       	rcall	.-3242   	; 0x1590 <xQueueGenericCreate>
    223a:	80 93 b7 22 	sts	0x22B7, r24	; 0x8022b7 <xTimerQueue>
    223e:	90 93 b8 22 	sts	0x22B8, r25	; 0x8022b8 <xTimerQueue+0x1>
    2242:	0f 90       	pop	r0
    2244:	0f be       	out	0x3f, r0	; 63
    2246:	08 95       	ret

00002248 <xTimerCreateTimerTask>:
    2248:	ef 92       	push	r14
    224a:	ff 92       	push	r15
    224c:	0f 93       	push	r16
    224e:	d4 df       	rcall	.-88     	; 0x21f8 <prvCheckForValidListAndQueue>
    2250:	80 91 b7 22 	lds	r24, 0x22B7	; 0x8022b7 <xTimerQueue>
    2254:	90 91 b8 22 	lds	r25, 0x22B8	; 0x8022b8 <xTimerQueue+0x1>
    2258:	89 2b       	or	r24, r25
    225a:	89 f0       	breq	.+34     	; 0x227e <xTimerCreateTimerTask+0x36>
    225c:	0f 2e       	mov	r0, r31
    225e:	f5 eb       	ldi	r31, 0xB5	; 181
    2260:	ef 2e       	mov	r14, r31
    2262:	f2 e2       	ldi	r31, 0x22	; 34
    2264:	ff 2e       	mov	r15, r31
    2266:	f0 2d       	mov	r31, r0
    2268:	03 e0       	ldi	r16, 0x03	; 3
    226a:	20 e0       	ldi	r18, 0x00	; 0
    226c:	30 e0       	ldi	r19, 0x00	; 0
    226e:	45 e5       	ldi	r20, 0x55	; 85
    2270:	50 e0       	ldi	r21, 0x00	; 0
    2272:	62 e1       	ldi	r22, 0x12	; 18
    2274:	70 e2       	ldi	r23, 0x20	; 32
    2276:	84 ef       	ldi	r24, 0xF4	; 244
    2278:	91 e1       	ldi	r25, 0x11	; 17
    227a:	f1 db       	rcall	.-2078   	; 0x1a5e <xTaskCreate>
    227c:	01 c0       	rjmp	.+2      	; 0x2280 <xTimerCreateTimerTask+0x38>
    227e:	80 e0       	ldi	r24, 0x00	; 0
    2280:	0f 91       	pop	r16
    2282:	ff 90       	pop	r15
    2284:	ef 90       	pop	r14
    2286:	08 95       	ret

00002288 <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    2288:	0f 93       	push	r16
    228a:	1f 93       	push	r17
    228c:	cf 93       	push	r28
    228e:	df 93       	push	r29
    2290:	cd b7       	in	r28, 0x3d	; 61
    2292:	de b7       	in	r29, 0x3e	; 62
    2294:	25 97       	sbiw	r28, 0x05	; 5
    2296:	cd bf       	out	0x3d, r28	; 61
    2298:	de bf       	out	0x3e, r29	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    229a:	e0 91 b7 22 	lds	r30, 0x22B7	; 0x8022b7 <xTimerQueue>
    229e:	f0 91 b8 22 	lds	r31, 0x22B8	; 0x8022b8 <xTimerQueue+0x1>
    22a2:	30 97       	sbiw	r30, 0x00	; 0
    22a4:	51 f1       	breq	.+84     	; 0x22fa <xTimerGenericCommand+0x72>
    22a6:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    22a8:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    22aa:	4a 83       	std	Y+2, r20	; 0x02
    22ac:	5b 83       	std	Y+3, r21	; 0x03
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    22ae:	8c 83       	std	Y+4, r24	; 0x04
    22b0:	9d 83       	std	Y+5, r25	; 0x05

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    22b2:	66 30       	cpi	r22, 0x06	; 6
    22b4:	d4 f4       	brge	.+52     	; 0x22ea <xTimerGenericCommand+0x62>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    22b6:	63 df       	rcall	.-314    	; 0x217e <xTaskGetSchedulerState>
    22b8:	82 30       	cpi	r24, 0x02	; 2
    22ba:	59 f4       	brne	.+22     	; 0x22d2 <xTimerGenericCommand+0x4a>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    22bc:	20 e0       	ldi	r18, 0x00	; 0
    22be:	a8 01       	movw	r20, r16
    22c0:	be 01       	movw	r22, r28
    22c2:	6f 5f       	subi	r22, 0xFF	; 255
    22c4:	7f 4f       	sbci	r23, 0xFF	; 255
    22c6:	80 91 b7 22 	lds	r24, 0x22B7	; 0x8022b7 <xTimerQueue>
    22ca:	90 91 b8 22 	lds	r25, 0x22B8	; 0x8022b8 <xTimerQueue+0x1>
    22ce:	81 d9       	rcall	.-3326   	; 0x15d2 <xQueueGenericSend>
    22d0:	15 c0       	rjmp	.+42     	; 0x22fc <xTimerGenericCommand+0x74>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    22d2:	20 e0       	ldi	r18, 0x00	; 0
    22d4:	40 e0       	ldi	r20, 0x00	; 0
    22d6:	50 e0       	ldi	r21, 0x00	; 0
    22d8:	be 01       	movw	r22, r28
    22da:	6f 5f       	subi	r22, 0xFF	; 255
    22dc:	7f 4f       	sbci	r23, 0xFF	; 255
    22de:	80 91 b7 22 	lds	r24, 0x22B7	; 0x8022b7 <xTimerQueue>
    22e2:	90 91 b8 22 	lds	r25, 0x22B8	; 0x8022b8 <xTimerQueue+0x1>
    22e6:	75 d9       	rcall	.-3350   	; 0x15d2 <xQueueGenericSend>
    22e8:	09 c0       	rjmp	.+18     	; 0x22fc <xTimerGenericCommand+0x74>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    22ea:	20 e0       	ldi	r18, 0x00	; 0
    22ec:	ad 01       	movw	r20, r26
    22ee:	be 01       	movw	r22, r28
    22f0:	6f 5f       	subi	r22, 0xFF	; 255
    22f2:	7f 4f       	sbci	r23, 0xFF	; 255
    22f4:	cf 01       	movw	r24, r30
    22f6:	fa d9       	rcall	.-3084   	; 0x16ec <xQueueGenericSendFromISR>
    22f8:	01 c0       	rjmp	.+2      	; 0x22fc <xTimerGenericCommand+0x74>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    22fa:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    22fc:	25 96       	adiw	r28, 0x05	; 5
    22fe:	cd bf       	out	0x3d, r28	; 61
    2300:	de bf       	out	0x3e, r29	; 62
    2302:	df 91       	pop	r29
    2304:	cf 91       	pop	r28
    2306:	1f 91       	pop	r17
    2308:	0f 91       	pop	r16
    230a:	08 95       	ret

0000230c <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    230c:	af 92       	push	r10
    230e:	bf 92       	push	r11
    2310:	cf 92       	push	r12
    2312:	df 92       	push	r13
    2314:	ef 92       	push	r14
    2316:	ff 92       	push	r15
    2318:	0f 93       	push	r16
    231a:	1f 93       	push	r17
    231c:	cf 93       	push	r28
    231e:	df 93       	push	r29
    2320:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    2322:	cd dc       	rcall	.-1638   	; 0x1cbe <xTaskGetTickCount>
    2324:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    2326:	80 91 b3 22 	lds	r24, 0x22B3	; 0x8022b3 <xLastTime.4598>
    232a:	90 91 b4 22 	lds	r25, 0x22B4	; 0x8022b4 <xLastTime.4598+0x1>
    232e:	e8 16       	cp	r14, r24
    2330:	f9 06       	cpc	r15, r25
    2332:	08 f0       	brcs	.+2      	; 0x2336 <prvSampleTimeNow+0x2a>
    2334:	47 c0       	rjmp	.+142    	; 0x23c4 <prvSampleTimeNow+0xb8>
    2336:	2f c0       	rjmp	.+94     	; 0x2396 <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    2338:	05 80       	ldd	r0, Z+5	; 0x05
    233a:	f6 81       	ldd	r31, Z+6	; 0x06
    233c:	e0 2d       	mov	r30, r0
    233e:	a0 80       	ld	r10, Z
    2340:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    2342:	c6 81       	ldd	r28, Z+6	; 0x06
    2344:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2346:	8e 01       	movw	r16, r28
    2348:	0e 5f       	subi	r16, 0xFE	; 254
    234a:	1f 4f       	sbci	r17, 0xFF	; 255
    234c:	c8 01       	movw	r24, r16
    234e:	0e 94 20 08 	call	0x1040	; 0x1040 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2352:	e8 89       	ldd	r30, Y+16	; 0x10
    2354:	f9 89       	ldd	r31, Y+17	; 0x11
    2356:	ce 01       	movw	r24, r28
    2358:	19 95       	eicall

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    235a:	8a 89       	ldd	r24, Y+18	; 0x12
    235c:	82 ff       	sbrs	r24, 2
    235e:	1b c0       	rjmp	.+54     	; 0x2396 <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    2360:	8c 85       	ldd	r24, Y+12	; 0x0c
    2362:	9d 85       	ldd	r25, Y+13	; 0x0d
    2364:	8a 0d       	add	r24, r10
    2366:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    2368:	a8 16       	cp	r10, r24
    236a:	b9 06       	cpc	r11, r25
    236c:	60 f4       	brcc	.+24     	; 0x2386 <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    236e:	8a 83       	std	Y+2, r24	; 0x02
    2370:	9b 83       	std	Y+3, r25	; 0x03
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2372:	c8 87       	std	Y+8, r28	; 0x08
    2374:	d9 87       	std	Y+9, r29	; 0x09
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    2376:	b8 01       	movw	r22, r16
    2378:	80 91 bb 22 	lds	r24, 0x22BB	; 0x8022bb <pxCurrentTimerList>
    237c:	90 91 bc 22 	lds	r25, 0x22BC	; 0x8022bc <pxCurrentTimerList+0x1>
    2380:	0e 94 ef 07 	call	0xfde	; 0xfde <vListInsert>
    2384:	08 c0       	rjmp	.+16     	; 0x2396 <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    2386:	00 e0       	ldi	r16, 0x00	; 0
    2388:	10 e0       	ldi	r17, 0x00	; 0
    238a:	20 e0       	ldi	r18, 0x00	; 0
    238c:	30 e0       	ldi	r19, 0x00	; 0
    238e:	a5 01       	movw	r20, r10
    2390:	60 e0       	ldi	r22, 0x00	; 0
    2392:	ce 01       	movw	r24, r28
    2394:	79 df       	rcall	.-270    	; 0x2288 <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    2396:	e0 91 bb 22 	lds	r30, 0x22BB	; 0x8022bb <pxCurrentTimerList>
    239a:	f0 91 bc 22 	lds	r31, 0x22BC	; 0x8022bc <pxCurrentTimerList+0x1>
    239e:	80 81       	ld	r24, Z
    23a0:	81 11       	cpse	r24, r1
    23a2:	ca cf       	rjmp	.-108    	; 0x2338 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    23a4:	80 91 b9 22 	lds	r24, 0x22B9	; 0x8022b9 <pxOverflowTimerList>
    23a8:	90 91 ba 22 	lds	r25, 0x22BA	; 0x8022ba <pxOverflowTimerList+0x1>
    23ac:	80 93 bb 22 	sts	0x22BB, r24	; 0x8022bb <pxCurrentTimerList>
    23b0:	90 93 bc 22 	sts	0x22BC, r25	; 0x8022bc <pxCurrentTimerList+0x1>
	pxOverflowTimerList = pxTemp;
    23b4:	e0 93 b9 22 	sts	0x22B9, r30	; 0x8022b9 <pxOverflowTimerList>
    23b8:	f0 93 ba 22 	sts	0x22BA, r31	; 0x8022ba <pxOverflowTimerList+0x1>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    23bc:	81 e0       	ldi	r24, 0x01	; 1
    23be:	f6 01       	movw	r30, r12
    23c0:	80 83       	st	Z, r24
    23c2:	02 c0       	rjmp	.+4      	; 0x23c8 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    23c4:	f6 01       	movw	r30, r12
    23c6:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    23c8:	e0 92 b3 22 	sts	0x22B3, r14	; 0x8022b3 <xLastTime.4598>
    23cc:	f0 92 b4 22 	sts	0x22B4, r15	; 0x8022b4 <xLastTime.4598+0x1>

	return xTimeNow;
}
    23d0:	c7 01       	movw	r24, r14
    23d2:	df 91       	pop	r29
    23d4:	cf 91       	pop	r28
    23d6:	1f 91       	pop	r17
    23d8:	0f 91       	pop	r16
    23da:	ff 90       	pop	r15
    23dc:	ef 90       	pop	r14
    23de:	df 90       	pop	r13
    23e0:	cf 90       	pop	r12
    23e2:	bf 90       	pop	r11
    23e4:	af 90       	pop	r10
    23e6:	08 95       	ret

000023e8 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    23e8:	cf 93       	push	r28
    23ea:	df 93       	push	r29
    23ec:	00 d0       	rcall	.+0      	; 0x23ee <prvTimerTask+0x6>
    23ee:	00 d0       	rcall	.+0      	; 0x23f0 <prvTimerTask+0x8>
    23f0:	cd b7       	in	r28, 0x3d	; 61
    23f2:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    23f4:	ce 01       	movw	r24, r28
    23f6:	01 96       	adiw	r24, 0x01	; 1
    23f8:	5c 01       	movw	r10, r24
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    23fa:	e8 2e       	mov	r14, r24
    23fc:	fb 2c       	mov	r15, r11
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    23fe:	e0 91 bb 22 	lds	r30, 0x22BB	; 0x8022bb <pxCurrentTimerList>
    2402:	f0 91 bc 22 	lds	r31, 0x22BC	; 0x8022bc <pxCurrentTimerList+0x1>
    2406:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    2408:	88 23       	and	r24, r24
    240a:	09 f4       	brne	.+2      	; 0x240e <prvTimerTask+0x26>
    240c:	cf c0       	rjmp	.+414    	; 0x25ac <prvTimerTask+0x1c4>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    240e:	05 80       	ldd	r0, Z+5	; 0x05
    2410:	f6 81       	ldd	r31, Z+6	; 0x06
    2412:	e0 2d       	mov	r30, r0
    2414:	c0 80       	ld	r12, Z
    2416:	d1 80       	ldd	r13, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    2418:	4c dc       	rcall	.-1896   	; 0x1cb2 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    241a:	c5 01       	movw	r24, r10
    241c:	77 df       	rcall	.-274    	; 0x230c <prvSampleTimeNow>
    241e:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    2420:	89 81       	ldd	r24, Y+1	; 0x01
    2422:	81 11       	cpse	r24, r1
    2424:	46 c0       	rjmp	.+140    	; 0x24b2 <prvTimerTask+0xca>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2426:	0c 15       	cp	r16, r12
    2428:	1d 05       	cpc	r17, r13
			{
				( void ) xTaskResumeAll();
    242a:	a0 f1       	brcs	.+104    	; 0x2494 <prvTimerTask+0xac>
    242c:	0a dd       	rcall	.-1516   	; 0x1e42 <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    242e:	e0 91 bb 22 	lds	r30, 0x22BB	; 0x8022bb <pxCurrentTimerList>
    2432:	f0 91 bc 22 	lds	r31, 0x22BC	; 0x8022bc <pxCurrentTimerList+0x1>
    2436:	05 80       	ldd	r0, Z+5	; 0x05
    2438:	f6 81       	ldd	r31, Z+6	; 0x06
    243a:	e0 2d       	mov	r30, r0
    243c:	86 80       	ldd	r8, Z+6	; 0x06
    243e:	97 80       	ldd	r9, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    2440:	c4 01       	movw	r24, r8
    2442:	02 96       	adiw	r24, 0x02	; 2
    2444:	0e 94 20 08 	call	0x1040	; 0x1040 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto-reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    2448:	d4 01       	movw	r26, r8
    244a:	52 96       	adiw	r26, 0x12	; 18
    244c:	8c 91       	ld	r24, X
    244e:	52 97       	sbiw	r26, 0x12	; 18
    2450:	82 ff       	sbrs	r24, 2
    2452:	15 c0       	rjmp	.+42     	; 0x247e <prvTimerTask+0x96>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    2454:	1c 96       	adiw	r26, 0x0c	; 12
    2456:	6d 91       	ld	r22, X+
    2458:	7c 91       	ld	r23, X
    245a:	1d 97       	sbiw	r26, 0x0d	; 13
    245c:	6c 0d       	add	r22, r12
    245e:	7d 1d       	adc	r23, r13
    2460:	96 01       	movw	r18, r12
    2462:	a8 01       	movw	r20, r16
    2464:	c4 01       	movw	r24, r8
    2466:	99 de       	rcall	.-718    	; 0x219a <prvInsertTimerInActiveList>
    2468:	88 23       	and	r24, r24
    246a:	61 f0       	breq	.+24     	; 0x2484 <prvTimerTask+0x9c>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    246c:	00 e0       	ldi	r16, 0x00	; 0
    246e:	10 e0       	ldi	r17, 0x00	; 0
    2470:	20 e0       	ldi	r18, 0x00	; 0
    2472:	30 e0       	ldi	r19, 0x00	; 0
    2474:	a6 01       	movw	r20, r12
    2476:	60 e0       	ldi	r22, 0x00	; 0
    2478:	c4 01       	movw	r24, r8
    247a:	06 df       	rcall	.-500    	; 0x2288 <xTimerGenericCommand>
    247c:	03 c0       	rjmp	.+6      	; 0x2484 <prvTimerTask+0x9c>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    247e:	8e 7f       	andi	r24, 0xFE	; 254
    2480:	f4 01       	movw	r30, r8
    2482:	82 8b       	std	Z+18, r24	; 0x12
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    2484:	d4 01       	movw	r26, r8
    2486:	50 96       	adiw	r26, 0x10	; 16
    2488:	ed 91       	ld	r30, X+
    248a:	fc 91       	ld	r31, X
    248c:	51 97       	sbiw	r26, 0x11	; 17
    248e:	c4 01       	movw	r24, r8
    2490:	19 95       	eicall
    2492:	80 c0       	rjmp	.+256    	; 0x2594 <prvTimerTask+0x1ac>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    2494:	40 e0       	ldi	r20, 0x00	; 0
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    2496:	b6 01       	movw	r22, r12
    2498:	60 1b       	sub	r22, r16
    249a:	71 0b       	sbc	r23, r17
    249c:	80 91 b7 22 	lds	r24, 0x22B7	; 0x8022b7 <xTimerQueue>
    24a0:	90 91 b8 22 	lds	r25, 0x22B8	; 0x8022b8 <xTimerQueue+0x1>

				if( xTaskResumeAll() == pdFALSE )
    24a4:	5a da       	rcall	.-2892   	; 0x195a <vQueueWaitForMessageRestricted>
    24a6:	cd dc       	rcall	.-1638   	; 0x1e42 <xTaskResumeAll>
    24a8:	81 11       	cpse	r24, r1
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    24aa:	74 c0       	rjmp	.+232    	; 0x2594 <prvTimerTask+0x1ac>
    24ac:	0e 94 03 09 	call	0x1206	; 0x1206 <vPortYield>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    24b0:	71 c0       	rjmp	.+226    	; 0x2594 <prvTimerTask+0x1ac>
    24b2:	c7 dc       	rcall	.-1650   	; 0x1e42 <xTaskResumeAll>
    24b4:	6f c0       	rjmp	.+222    	; 0x2594 <prvTimerTask+0x1ac>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    24b6:	89 81       	ldd	r24, Y+1	; 0x01
    24b8:	88 23       	and	r24, r24
    24ba:	0c f4       	brge	.+2      	; 0x24be <prvTimerTask+0xd6>
    24bc:	6b c0       	rjmp	.+214    	; 0x2594 <prvTimerTask+0x1ac>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    24be:	cc 80       	ldd	r12, Y+4	; 0x04
    24c0:	dd 80       	ldd	r13, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    24c2:	f6 01       	movw	r30, r12
    24c4:	82 85       	ldd	r24, Z+10	; 0x0a
    24c6:	93 85       	ldd	r25, Z+11	; 0x0b
    24c8:	89 2b       	or	r24, r25
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    24ca:	21 f0       	breq	.+8      	; 0x24d4 <prvTimerTask+0xec>
    24cc:	c6 01       	movw	r24, r12
    24ce:	02 96       	adiw	r24, 0x02	; 2
    24d0:	0e 94 20 08 	call	0x1040	; 0x1040 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    24d4:	ce 01       	movw	r24, r28
    24d6:	06 96       	adiw	r24, 0x06	; 6
    24d8:	19 df       	rcall	.-462    	; 0x230c <prvSampleTimeNow>
    24da:	ac 01       	movw	r20, r24

			switch( xMessage.xMessageID )
    24dc:	e9 81       	ldd	r30, Y+1	; 0x01
    24de:	0e 2e       	mov	r0, r30
    24e0:	00 0c       	add	r0, r0
    24e2:	ff 0b       	sbc	r31, r31
    24e4:	ea 30       	cpi	r30, 0x0A	; 10
    24e6:	f1 05       	cpc	r31, r1
    24e8:	08 f0       	brcs	.+2      	; 0x24ec <prvTimerTask+0x104>
    24ea:	54 c0       	rjmp	.+168    	; 0x2594 <prvTimerTask+0x1ac>
    24ec:	88 27       	eor	r24, r24
    24ee:	e2 50       	subi	r30, 0x02	; 2
    24f0:	ff 4f       	sbci	r31, 0xFF	; 255
    24f2:	8f 4f       	sbci	r24, 0xFF	; 255
    24f4:	bb c4       	rjmp	.+2422   	; 0x2e6c <__tablejump2__>
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    24f6:	d6 01       	movw	r26, r12
    24f8:	52 96       	adiw	r26, 0x12	; 18
    24fa:	8c 91       	ld	r24, X
    24fc:	52 97       	sbiw	r26, 0x12	; 18
    24fe:	81 60       	ori	r24, 0x01	; 1
    2500:	52 96       	adiw	r26, 0x12	; 18
    2502:	8c 93       	st	X, r24
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    2504:	52 97       	sbiw	r26, 0x12	; 18
    2506:	2a 81       	ldd	r18, Y+2	; 0x02
    2508:	3b 81       	ldd	r19, Y+3	; 0x03
    250a:	1c 96       	adiw	r26, 0x0c	; 12
    250c:	6d 91       	ld	r22, X+
    250e:	7c 91       	ld	r23, X
    2510:	1d 97       	sbiw	r26, 0x0d	; 13
    2512:	62 0f       	add	r22, r18
    2514:	73 1f       	adc	r23, r19
    2516:	c6 01       	movw	r24, r12
    2518:	40 de       	rcall	.-896    	; 0x219a <prvInsertTimerInActiveList>
    251a:	88 23       	and	r24, r24
    251c:	d9 f1       	breq	.+118    	; 0x2594 <prvTimerTask+0x1ac>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    251e:	d6 01       	movw	r26, r12
    2520:	50 96       	adiw	r26, 0x10	; 16
    2522:	ed 91       	ld	r30, X+
    2524:	fc 91       	ld	r31, X
    2526:	51 97       	sbiw	r26, 0x11	; 17
    2528:	c6 01       	movw	r24, r12
    252a:	19 95       	eicall
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    252c:	f6 01       	movw	r30, r12
    252e:	82 89       	ldd	r24, Z+18	; 0x12
    2530:	82 ff       	sbrs	r24, 2
    2532:	30 c0       	rjmp	.+96     	; 0x2594 <prvTimerTask+0x1ac>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    2534:	4a 81       	ldd	r20, Y+2	; 0x02
    2536:	5b 81       	ldd	r21, Y+3	; 0x03
    2538:	84 85       	ldd	r24, Z+12	; 0x0c
    253a:	95 85       	ldd	r25, Z+13	; 0x0d
    253c:	48 0f       	add	r20, r24
    253e:	59 1f       	adc	r21, r25
    2540:	00 e0       	ldi	r16, 0x00	; 0
    2542:	10 e0       	ldi	r17, 0x00	; 0
    2544:	20 e0       	ldi	r18, 0x00	; 0
    2546:	30 e0       	ldi	r19, 0x00	; 0
    2548:	60 e0       	ldi	r22, 0x00	; 0
    254a:	c6 01       	movw	r24, r12
    254c:	9d de       	rcall	.-710    	; 0x2288 <xTimerGenericCommand>
    254e:	22 c0       	rjmp	.+68     	; 0x2594 <prvTimerTask+0x1ac>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    2550:	d6 01       	movw	r26, r12
    2552:	52 96       	adiw	r26, 0x12	; 18
    2554:	8c 91       	ld	r24, X
    2556:	52 97       	sbiw	r26, 0x12	; 18
    2558:	8e 7f       	andi	r24, 0xFE	; 254
    255a:	52 96       	adiw	r26, 0x12	; 18
    255c:	8c 93       	st	X, r24
    255e:	1a c0       	rjmp	.+52     	; 0x2594 <prvTimerTask+0x1ac>
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    2560:	f6 01       	movw	r30, r12
    2562:	82 89       	ldd	r24, Z+18	; 0x12
    2564:	81 60       	ori	r24, 0x01	; 1
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    2566:	82 8b       	std	Z+18, r24	; 0x12
    2568:	6a 81       	ldd	r22, Y+2	; 0x02
    256a:	7b 81       	ldd	r23, Y+3	; 0x03
    256c:	64 87       	std	Z+12, r22	; 0x0c
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    256e:	75 87       	std	Z+13, r23	; 0x0d
    2570:	64 0f       	add	r22, r20
    2572:	75 1f       	adc	r23, r21
    2574:	9a 01       	movw	r18, r20
    2576:	c6 01       	movw	r24, r12
    2578:	10 de       	rcall	.-992    	; 0x219a <prvInsertTimerInActiveList>
    257a:	0c c0       	rjmp	.+24     	; 0x2594 <prvTimerTask+0x1ac>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    257c:	d6 01       	movw	r26, r12
    257e:	52 96       	adiw	r26, 0x12	; 18
    2580:	8c 91       	ld	r24, X
    2582:	81 fd       	sbrc	r24, 1
    2584:	04 c0       	rjmp	.+8      	; 0x258e <prvTimerTask+0x1a6>
						{
							vPortFree( pxTimer );
    2586:	c6 01       	movw	r24, r12
    2588:	0e 94 c2 09 	call	0x1384	; 0x1384 <vPortFree>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    258c:	03 c0       	rjmp	.+6      	; 0x2594 <prvTimerTask+0x1ac>
    258e:	8e 7f       	andi	r24, 0xFE	; 254
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    2590:	f6 01       	movw	r30, r12
    2592:	82 8b       	std	Z+18, r24	; 0x12
    2594:	40 e0       	ldi	r20, 0x00	; 0
    2596:	50 e0       	ldi	r21, 0x00	; 0
    2598:	6e 2d       	mov	r22, r14
    259a:	7f 2d       	mov	r23, r15
    259c:	80 91 b7 22 	lds	r24, 0x22B7	; 0x8022b7 <xTimerQueue>
    25a0:	90 91 b8 22 	lds	r25, 0x22B8	; 0x8022b8 <xTimerQueue+0x1>
    25a4:	dd d8       	rcall	.-3654   	; 0x1760 <xQueueReceive>
    25a6:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    25a8:	86 cf       	rjmp	.-244    	; 0x24b6 <prvTimerTask+0xce>
    25aa:	29 cf       	rjmp	.-430    	; 0x23fe <prvTimerTask+0x16>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    25ac:	82 db       	rcall	.-2300   	; 0x1cb2 <vTaskSuspendAll>
    25ae:	c5 01       	movw	r24, r10
    25b0:	ad de       	rcall	.-678    	; 0x230c <prvSampleTimeNow>
    25b2:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    25b4:	89 81       	ldd	r24, Y+1	; 0x01
    25b6:	81 11       	cpse	r24, r1
    25b8:	7c cf       	rjmp	.-264    	; 0x24b2 <prvTimerTask+0xca>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    25ba:	e0 91 b9 22 	lds	r30, 0x22B9	; 0x8022b9 <pxOverflowTimerList>
    25be:	f0 91 ba 22 	lds	r31, 0x22BA	; 0x8022ba <pxOverflowTimerList+0x1>
    25c2:	80 81       	ld	r24, Z
    25c4:	41 e0       	ldi	r20, 0x01	; 1
    25c6:	81 11       	cpse	r24, r1
    25c8:	40 e0       	ldi	r20, 0x00	; 0
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    25ca:	c1 2c       	mov	r12, r1
    25cc:	d1 2c       	mov	r13, r1
    25ce:	63 cf       	rjmp	.-314    	; 0x2496 <prvTimerTask+0xae>

000025d0 <usart_spi_init>:
		*data = usart_spi_transmit(usart, CONFIG_USART_SPI_DUMMY);
		len--;
		data++;
 	}
	return STATUS_OK;
}
    25d0:	80 3a       	cpi	r24, 0xA0	; 160
    25d2:	28 e0       	ldi	r18, 0x08	; 8
    25d4:	92 07       	cpc	r25, r18
    25d6:	21 f4       	brne	.+8      	; 0x25e0 <usart_spi_init+0x10>
    25d8:	60 e1       	ldi	r22, 0x10	; 16
    25da:	83 e0       	ldi	r24, 0x03	; 3
    25dc:	22 c1       	rjmp	.+580    	; 0x2822 <sysclk_enable_module>
    25de:	08 95       	ret
    25e0:	80 3b       	cpi	r24, 0xB0	; 176
    25e2:	28 e0       	ldi	r18, 0x08	; 8
    25e4:	92 07       	cpc	r25, r18
    25e6:	21 f4       	brne	.+8      	; 0x25f0 <usart_spi_init+0x20>
    25e8:	60 e2       	ldi	r22, 0x20	; 32
    25ea:	83 e0       	ldi	r24, 0x03	; 3
    25ec:	1a c1       	rjmp	.+564    	; 0x2822 <sysclk_enable_module>
    25ee:	08 95       	ret
    25f0:	80 3a       	cpi	r24, 0xA0	; 160
    25f2:	29 e0       	ldi	r18, 0x09	; 9
    25f4:	92 07       	cpc	r25, r18
    25f6:	21 f4       	brne	.+8      	; 0x2600 <usart_spi_init+0x30>
    25f8:	60 e1       	ldi	r22, 0x10	; 16
    25fa:	84 e0       	ldi	r24, 0x04	; 4
    25fc:	12 c1       	rjmp	.+548    	; 0x2822 <sysclk_enable_module>
    25fe:	08 95       	ret
    2600:	80 3b       	cpi	r24, 0xB0	; 176
    2602:	29 e0       	ldi	r18, 0x09	; 9
    2604:	92 07       	cpc	r25, r18
    2606:	21 f4       	brne	.+8      	; 0x2610 <usart_spi_init+0x40>
    2608:	60 e2       	ldi	r22, 0x20	; 32
    260a:	84 e0       	ldi	r24, 0x04	; 4
    260c:	0a c1       	rjmp	.+532    	; 0x2822 <sysclk_enable_module>
    260e:	08 95       	ret
    2610:	80 3a       	cpi	r24, 0xA0	; 160
    2612:	2a e0       	ldi	r18, 0x0A	; 10
    2614:	92 07       	cpc	r25, r18
    2616:	21 f4       	brne	.+8      	; 0x2620 <usart_spi_init+0x50>
    2618:	60 e1       	ldi	r22, 0x10	; 16
    261a:	85 e0       	ldi	r24, 0x05	; 5
    261c:	02 c1       	rjmp	.+516    	; 0x2822 <sysclk_enable_module>
    261e:	08 95       	ret
    2620:	80 3a       	cpi	r24, 0xA0	; 160
    2622:	9b 40       	sbci	r25, 0x0B	; 11
    2624:	19 f4       	brne	.+6      	; 0x262c <usart_spi_init+0x5c>
    2626:	60 e1       	ldi	r22, 0x10	; 16
    2628:	86 e0       	ldi	r24, 0x06	; 6
    262a:	fb c0       	rjmp	.+502    	; 0x2822 <sysclk_enable_module>
    262c:	08 95       	ret

0000262e <usart_spi_setup_device>:
    262e:	0f 93       	push	r16
    2630:	1f 93       	push	r17
    2632:	cf 93       	push	r28
    2634:	df 93       	push	r29
    2636:	00 d0       	rcall	.+0      	; 0x2638 <usart_spi_setup_device+0xa>
    2638:	00 d0       	rcall	.+0      	; 0x263a <usart_spi_setup_device+0xc>
    263a:	cd b7       	in	r28, 0x3d	; 61
    263c:	de b7       	in	r29, 0x3e	; 62
    263e:	09 83       	std	Y+1, r16	; 0x01
    2640:	1a 83       	std	Y+2, r17	; 0x02
    2642:	2b 83       	std	Y+3, r18	; 0x03
    2644:	3c 83       	std	Y+4, r19	; 0x04
    2646:	4d 83       	std	Y+5, r20	; 0x05
    2648:	1e 82       	std	Y+6, r1	; 0x06
    264a:	be 01       	movw	r22, r28
    264c:	6f 5f       	subi	r22, 0xFF	; 255
    264e:	7f 4f       	sbci	r23, 0xFF	; 255
    2650:	0e 94 bb 05 	call	0xb76	; 0xb76 <usart_init_spi>
    2654:	26 96       	adiw	r28, 0x06	; 6
    2656:	cd bf       	out	0x3d, r28	; 61
    2658:	de bf       	out	0x3e, r29	; 62
    265a:	df 91       	pop	r29
    265c:	cf 91       	pop	r28
    265e:	1f 91       	pop	r17
    2660:	0f 91       	pop	r16
    2662:	08 95       	ret

00002664 <usart_spi_select_device>:

void usart_spi_select_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_low(device->id);
    2664:	fb 01       	movw	r30, r22
    2666:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    2668:	e8 2f       	mov	r30, r24
    266a:	e6 95       	lsr	r30
    266c:	e6 95       	lsr	r30
    266e:	e6 95       	lsr	r30
    2670:	40 e2       	ldi	r20, 0x20	; 32
    2672:	e4 9f       	mul	r30, r20
    2674:	f0 01       	movw	r30, r0
    2676:	11 24       	eor	r1, r1
    2678:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    267a:	87 70       	andi	r24, 0x07	; 7
    267c:	21 e0       	ldi	r18, 0x01	; 1
    267e:	30 e0       	ldi	r19, 0x00	; 0
    2680:	a9 01       	movw	r20, r18
    2682:	02 c0       	rjmp	.+4      	; 0x2688 <usart_spi_select_device+0x24>
    2684:	44 0f       	add	r20, r20
    2686:	55 1f       	adc	r21, r21
    2688:	8a 95       	dec	r24
    268a:	e2 f7       	brpl	.-8      	; 0x2684 <usart_spi_select_device+0x20>
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    268c:	46 83       	std	Z+6, r20	; 0x06
    268e:	08 95       	ret

00002690 <usart_spi_deselect_device>:
}

void usart_spi_deselect_device(USART_t *usart, struct usart_spi_device *device)
{
	ioport_set_pin_high(device->id);
    2690:	fb 01       	movw	r30, r22
    2692:	80 81       	ld	r24, Z
	return pin >> 3;
}

__always_inline static PORT_t *arch_ioport_port_to_base(ioport_port_t port)
{
	return (PORT_t *)((uintptr_t)IOPORT_BASE_ADDRESS +
    2694:	e8 2f       	mov	r30, r24
    2696:	e6 95       	lsr	r30
    2698:	e6 95       	lsr	r30
    269a:	e6 95       	lsr	r30
    269c:	40 e2       	ldi	r20, 0x20	; 32
    269e:	e4 9f       	mul	r30, r20
    26a0:	f0 01       	movw	r30, r0
    26a2:	11 24       	eor	r1, r1
    26a4:	fa 5f       	subi	r31, 0xFA	; 250
}

__always_inline static ioport_port_mask_t arch_ioport_pin_to_mask(
		ioport_pin_t pin)
{
	return 1U << (pin & 0x07);
    26a6:	87 70       	andi	r24, 0x07	; 7
    26a8:	21 e0       	ldi	r18, 0x01	; 1
    26aa:	30 e0       	ldi	r19, 0x00	; 0
    26ac:	a9 01       	movw	r20, r18
    26ae:	02 c0       	rjmp	.+4      	; 0x26b4 <usart_spi_deselect_device+0x24>
    26b0:	44 0f       	add	r20, r20
    26b2:	55 1f       	adc	r21, r21
    26b4:	8a 95       	dec	r24
    26b6:	e2 f7       	brpl	.-8      	; 0x26b0 <usart_spi_deselect_device+0x20>
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    26b8:	45 83       	std	Z+5, r20	; 0x05
    26ba:	08 95       	ret

000026bc <gfx_mono_set_framebuffer>:
	gfx_coord_t *framebuffer_pt = fbpointer +
			((page * GFX_MONO_LCD_WIDTH) + column);
	do {
		*data++ = *framebuffer_pt++;
	} while (--width > 0);
}
    26bc:	80 93 cf 22 	sts	0x22CF, r24	; 0x8022cf <fbpointer>
    26c0:	90 93 d0 22 	sts	0x22D0, r25	; 0x8022d0 <fbpointer+0x1>
    26c4:	08 95       	ret

000026c6 <gfx_mono_framebuffer_put_byte>:
\endcode
 */
void gfx_mono_framebuffer_put_byte(gfx_coord_t page, gfx_coord_t column,
		uint8_t data)
{
	*(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column) = data;
    26c6:	20 91 cf 22 	lds	r18, 0x22CF	; 0x8022cf <fbpointer>
    26ca:	30 91 d0 22 	lds	r19, 0x22D0	; 0x8022d0 <fbpointer+0x1>
    26ce:	90 e8       	ldi	r25, 0x80	; 128
    26d0:	89 9f       	mul	r24, r25
    26d2:	20 0d       	add	r18, r0
    26d4:	31 1d       	adc	r19, r1
    26d6:	11 24       	eor	r1, r1
    26d8:	f9 01       	movw	r30, r18
    26da:	e6 0f       	add	r30, r22
    26dc:	f1 1d       	adc	r31, r1
    26de:	40 83       	st	Z, r20
    26e0:	08 95       	ret

000026e2 <gfx_mono_framebuffer_get_byte>:
	data = gfx_mono_framebuffer_get_byte(0, 0);
\endcode
 */
uint8_t gfx_mono_framebuffer_get_byte(gfx_coord_t page, gfx_coord_t column)
{
	return *(fbpointer + (page * GFX_MONO_LCD_WIDTH) + column);
    26e2:	20 91 cf 22 	lds	r18, 0x22CF	; 0x8022cf <fbpointer>
    26e6:	30 91 d0 22 	lds	r19, 0x22D0	; 0x8022d0 <fbpointer+0x1>
    26ea:	90 e8       	ldi	r25, 0x80	; 128
    26ec:	89 9f       	mul	r24, r25
    26ee:	20 0d       	add	r18, r0
    26f0:	31 1d       	adc	r19, r1
    26f2:	11 24       	eor	r1, r1
    26f4:	f9 01       	movw	r30, r18
    26f6:	e6 0f       	add	r30, r22
    26f8:	f1 1d       	adc	r31, r1
}
    26fa:	80 81       	ld	r24, Z
    26fc:	08 95       	ret

000026fe <gfx_mono_generic_draw_horizontal_line>:
	gfx_mono_draw_horizontal_line(x, y, width, color);
	gfx_mono_draw_horizontal_line(x, y + height - 1, width, color);

	gfx_mono_draw_vertical_line(x, y, height, color);
	gfx_mono_draw_vertical_line(x + width - 1, y, height, color);
}
    26fe:	ff 92       	push	r15
    2700:	0f 93       	push	r16
    2702:	1f 93       	push	r17
    2704:	cf 93       	push	r28
    2706:	df 93       	push	r29
    2708:	e4 2f       	mov	r30, r20
    270a:	f0 e0       	ldi	r31, 0x00	; 0
    270c:	e8 0f       	add	r30, r24
    270e:	f1 1d       	adc	r31, r1
    2710:	e1 38       	cpi	r30, 0x81	; 129
    2712:	f1 05       	cpc	r31, r1
    2714:	1c f0       	brlt	.+6      	; 0x271c <gfx_mono_generic_draw_horizontal_line+0x1e>
    2716:	c0 e8       	ldi	r28, 0x80	; 128
    2718:	4c 2f       	mov	r20, r28
    271a:	48 1b       	sub	r20, r24
    271c:	44 23       	and	r20, r20
    271e:	09 f4       	brne	.+2      	; 0x2722 <gfx_mono_generic_draw_horizontal_line+0x24>
    2720:	50 c0       	rjmp	.+160    	; 0x27c2 <gfx_mono_generic_draw_horizontal_line+0xc4>
    2722:	d6 2f       	mov	r29, r22
    2724:	d6 95       	lsr	r29
    2726:	d6 95       	lsr	r29
    2728:	d6 95       	lsr	r29
    272a:	70 e0       	ldi	r23, 0x00	; 0
    272c:	98 e0       	ldi	r25, 0x08	; 8
    272e:	d9 9f       	mul	r29, r25
    2730:	60 19       	sub	r22, r0
    2732:	71 09       	sbc	r23, r1
    2734:	11 24       	eor	r1, r1
    2736:	e1 e0       	ldi	r30, 0x01	; 1
    2738:	f0 e0       	ldi	r31, 0x00	; 0
    273a:	df 01       	movw	r26, r30
    273c:	02 c0       	rjmp	.+4      	; 0x2742 <gfx_mono_generic_draw_horizontal_line+0x44>
    273e:	aa 0f       	add	r26, r26
    2740:	bb 1f       	adc	r27, r27
    2742:	6a 95       	dec	r22
    2744:	e2 f7       	brpl	.-8      	; 0x273e <gfx_mono_generic_draw_horizontal_line+0x40>
    2746:	fa 2e       	mov	r15, r26
    2748:	21 30       	cpi	r18, 0x01	; 1
    274a:	21 f0       	breq	.+8      	; 0x2754 <gfx_mono_generic_draw_horizontal_line+0x56>
    274c:	a8 f0       	brcs	.+42     	; 0x2778 <gfx_mono_generic_draw_horizontal_line+0x7a>
    274e:	22 30       	cpi	r18, 0x02	; 2
    2750:	39 f1       	breq	.+78     	; 0x27a0 <gfx_mono_generic_draw_horizontal_line+0xa2>
    2752:	37 c0       	rjmp	.+110    	; 0x27c2 <gfx_mono_generic_draw_horizontal_line+0xc4>
    2754:	c4 2f       	mov	r28, r20
    2756:	1f ef       	ldi	r17, 0xFF	; 255
    2758:	18 0f       	add	r17, r24
    275a:	01 2f       	mov	r16, r17
    275c:	0c 0f       	add	r16, r28
    275e:	60 2f       	mov	r22, r16
    2760:	8d 2f       	mov	r24, r29
    2762:	0e 94 86 05 	call	0xb0c	; 0xb0c <gfx_mono_st7565r_get_byte>
    2766:	4f 2d       	mov	r20, r15
    2768:	48 2b       	or	r20, r24
    276a:	60 2f       	mov	r22, r16
    276c:	8d 2f       	mov	r24, r29
    276e:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <gfx_mono_st7565r_put_byte>
    2772:	c1 50       	subi	r28, 0x01	; 1
    2774:	91 f7       	brne	.-28     	; 0x275a <gfx_mono_generic_draw_horizontal_line+0x5c>
    2776:	25 c0       	rjmp	.+74     	; 0x27c2 <gfx_mono_generic_draw_horizontal_line+0xc4>
    2778:	c4 2f       	mov	r28, r20
    277a:	1f ef       	ldi	r17, 0xFF	; 255
    277c:	18 0f       	add	r17, r24
    277e:	fa 2e       	mov	r15, r26
    2780:	f0 94       	com	r15
    2782:	01 2f       	mov	r16, r17
    2784:	0c 0f       	add	r16, r28
    2786:	60 2f       	mov	r22, r16
    2788:	8d 2f       	mov	r24, r29
    278a:	0e 94 86 05 	call	0xb0c	; 0xb0c <gfx_mono_st7565r_get_byte>
    278e:	4f 2d       	mov	r20, r15
    2790:	48 23       	and	r20, r24
    2792:	60 2f       	mov	r22, r16
    2794:	8d 2f       	mov	r24, r29
    2796:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <gfx_mono_st7565r_put_byte>
    279a:	c1 50       	subi	r28, 0x01	; 1
    279c:	91 f7       	brne	.-28     	; 0x2782 <gfx_mono_generic_draw_horizontal_line+0x84>
    279e:	11 c0       	rjmp	.+34     	; 0x27c2 <gfx_mono_generic_draw_horizontal_line+0xc4>
    27a0:	c4 2f       	mov	r28, r20
    27a2:	1f ef       	ldi	r17, 0xFF	; 255
    27a4:	18 0f       	add	r17, r24
    27a6:	01 2f       	mov	r16, r17
    27a8:	0c 0f       	add	r16, r28
    27aa:	60 2f       	mov	r22, r16
    27ac:	8d 2f       	mov	r24, r29
    27ae:	0e 94 86 05 	call	0xb0c	; 0xb0c <gfx_mono_st7565r_get_byte>
    27b2:	4f 2d       	mov	r20, r15
    27b4:	48 27       	eor	r20, r24
    27b6:	60 2f       	mov	r22, r16
    27b8:	8d 2f       	mov	r24, r29
    27ba:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <gfx_mono_st7565r_put_byte>
    27be:	c1 50       	subi	r28, 0x01	; 1
    27c0:	91 f7       	brne	.-28     	; 0x27a6 <gfx_mono_generic_draw_horizontal_line+0xa8>
    27c2:	df 91       	pop	r29
    27c4:	cf 91       	pop	r28
    27c6:	1f 91       	pop	r17
    27c8:	0f 91       	pop	r16
    27ca:	ff 90       	pop	r15
    27cc:	08 95       	ret

000027ce <gfx_mono_generic_draw_filled_rect>:
 * \param  color       Pixel operation of the line
 */
void gfx_mono_generic_draw_filled_rect(gfx_coord_t x, gfx_coord_t y,
		gfx_coord_t width, gfx_coord_t height,
		enum gfx_mono_color color)
{
    27ce:	ff 92       	push	r15
    27d0:	0f 93       	push	r16
    27d2:	1f 93       	push	r17
    27d4:	cf 93       	push	r28
    27d6:	df 93       	push	r29
	if (height == 0) {
    27d8:	22 23       	and	r18, r18
    27da:	69 f0       	breq	.+26     	; 0x27f6 <gfx_mono_generic_draw_filled_rect+0x28>
    27dc:	f4 2e       	mov	r15, r20
    27de:	18 2f       	mov	r17, r24
    27e0:	c2 2f       	mov	r28, r18
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
    27e2:	df ef       	ldi	r29, 0xFF	; 255
    27e4:	d6 0f       	add	r29, r22
    27e6:	6d 2f       	mov	r22, r29
    27e8:	6c 0f       	add	r22, r28
    27ea:	20 2f       	mov	r18, r16
    27ec:	4f 2d       	mov	r20, r15
    27ee:	81 2f       	mov	r24, r17
    27f0:	86 df       	rcall	.-244    	; 0x26fe <gfx_mono_generic_draw_horizontal_line>
    27f2:	c1 50       	subi	r28, 0x01	; 1
	if (height == 0) {
		/* Nothing to do. Move along. */
		return;
	}

	while (height-- > 0) {
    27f4:	c1 f7       	brne	.-16     	; 0x27e6 <gfx_mono_generic_draw_filled_rect+0x18>
		gfx_mono_draw_horizontal_line(x, y + height, width, color);
	}
}
    27f6:	df 91       	pop	r29
    27f8:	cf 91       	pop	r28
    27fa:	1f 91       	pop	r17
    27fc:	0f 91       	pop	r16
    27fe:	ff 90       	pop	r15
    2800:	08 95       	ret

00002802 <sysclk_init>:
#endif
	bool need_rc2mhz = false;

	/* Turn off all peripheral clocks that can be turned off. */
	for (i = 0; i <= SYSCLK_PORT_F; i++) {
		*(reg++) = 0xff;
    2802:	8f ef       	ldi	r24, 0xFF	; 255
    2804:	80 93 70 00 	sts	0x0070, r24	; 0x800070 <__TEXT_REGION_LENGTH__+0x700070>
    2808:	80 93 71 00 	sts	0x0071, r24	; 0x800071 <__TEXT_REGION_LENGTH__+0x700071>
    280c:	80 93 72 00 	sts	0x0072, r24	; 0x800072 <__TEXT_REGION_LENGTH__+0x700072>
    2810:	80 93 73 00 	sts	0x0073, r24	; 0x800073 <__TEXT_REGION_LENGTH__+0x700073>
    2814:	80 93 74 00 	sts	0x0074, r24	; 0x800074 <__TEXT_REGION_LENGTH__+0x700074>
    2818:	80 93 75 00 	sts	0x0075, r24	; 0x800075 <__TEXT_REGION_LENGTH__+0x700075>
    281c:	80 93 76 00 	sts	0x0076, r24	; 0x800076 <__TEXT_REGION_LENGTH__+0x700076>
    2820:	08 95       	ret

00002822 <sysclk_enable_module>:
	sysclk_rtcsrc_enable(CONFIG_RTC_SOURCE);
#endif
}

void sysclk_enable_module(enum sysclk_port_id port, uint8_t id)
{
    2822:	cf 93       	push	r28
    2824:	df 93       	push	r29
    2826:	1f 92       	push	r1
    2828:	cd b7       	in	r28, 0x3d	; 61
    282a:	de b7       	in	r29, 0x3e	; 62

typedef uint8_t irqflags_t;

static inline irqflags_t cpu_irq_save(void)
{
	volatile irqflags_t flags = SREG;
    282c:	9f b7       	in	r25, 0x3f	; 63
    282e:	99 83       	std	Y+1, r25	; 0x01
	cpu_irq_disable();
    2830:	f8 94       	cli
	return flags;
    2832:	99 81       	ldd	r25, Y+1	; 0x01
	irqflags_t flags = cpu_irq_save();

	*((uint8_t *)&PR.PRGEN + port) &= ~id;
    2834:	e8 2f       	mov	r30, r24
    2836:	f0 e0       	ldi	r31, 0x00	; 0
    2838:	e0 59       	subi	r30, 0x90	; 144
    283a:	ff 4f       	sbci	r31, 0xFF	; 255
    283c:	60 95       	com	r22
    283e:	80 81       	ld	r24, Z
    2840:	68 23       	and	r22, r24
    2842:	60 83       	st	Z, r22
}

static inline void cpu_irq_restore(irqflags_t flags)
{
	barrier();
	SREG = flags;
    2844:	9f bf       	out	0x3f, r25	; 63

	cpu_irq_restore(flags);
}
    2846:	0f 90       	pop	r0
    2848:	df 91       	pop	r29
    284a:	cf 91       	pop	r28
    284c:	08 95       	ret

0000284e <gfx_mono_draw_char>:
 * \param y        Y coordinate on screen.
 * \param font     Font to draw character in
 */
void gfx_mono_draw_char(const char c, const gfx_coord_t x, const gfx_coord_t y,
		const struct font *font)
{
    284e:	af 92       	push	r10
    2850:	bf 92       	push	r11
    2852:	cf 92       	push	r12
    2854:	df 92       	push	r13
    2856:	ef 92       	push	r14
    2858:	ff 92       	push	r15
    285a:	0f 93       	push	r16
    285c:	1f 93       	push	r17
    285e:	cf 93       	push	r28
    2860:	df 93       	push	r29
    2862:	c8 2f       	mov	r28, r24
    2864:	e6 2e       	mov	r14, r22
    2866:	b4 2e       	mov	r11, r20
    2868:	69 01       	movw	r12, r18
	gfx_mono_draw_filled_rect(x, y, font->width, font->height,
    286a:	00 e0       	ldi	r16, 0x00	; 0
    286c:	f9 01       	movw	r30, r18
    286e:	24 81       	ldd	r18, Z+4	; 0x04
    2870:	43 81       	ldd	r20, Z+3	; 0x03
    2872:	6b 2d       	mov	r22, r11
    2874:	8e 2d       	mov	r24, r14
    2876:	ab df       	rcall	.-170    	; 0x27ce <gfx_mono_generic_draw_filled_rect>
			GFX_PIXEL_CLR);

	switch (font->type) {
    2878:	f6 01       	movw	r30, r12
    287a:	80 81       	ld	r24, Z
    287c:	81 11       	cpse	r24, r1
    287e:	3a c0       	rjmp	.+116    	; 0x28f4 <gfx_mono_draw_char+0xa6>
	Assert(font != NULL);

	gfx_coord_t inc_x = x;
	gfx_coord_t inc_y = y;

	char_row_size = font->width / CONFIG_FONT_PIXELS_PER_BYTE;
    2880:	83 81       	ldd	r24, Z+3	; 0x03
    2882:	28 2f       	mov	r18, r24
    2884:	26 95       	lsr	r18
    2886:	26 95       	lsr	r18
    2888:	26 95       	lsr	r18
	if (font->width % CONFIG_FONT_PIXELS_PER_BYTE) {
    288a:	87 70       	andi	r24, 0x07	; 7
    288c:	09 f0       	breq	.+2      	; 0x2890 <gfx_mono_draw_char+0x42>
		char_row_size++;
    288e:	2f 5f       	subi	r18, 0xFF	; 255
	}

	glyph_data_offset = char_row_size * font->height *
    2890:	f6 01       	movw	r30, r12
    2892:	a4 80       	ldd	r10, Z+4	; 0x04
			((uint8_t)ch - font->first_char);
	glyph_data = font->data.progmem + glyph_data_offset;
    2894:	8c 2f       	mov	r24, r28
    2896:	90 e0       	ldi	r25, 0x00	; 0
    2898:	35 81       	ldd	r19, Z+5	; 0x05
    289a:	83 1b       	sub	r24, r19
    289c:	91 09       	sbc	r25, r1
    289e:	2a 9d       	mul	r18, r10
    28a0:	90 01       	movw	r18, r0
    28a2:	11 24       	eor	r1, r1
    28a4:	82 9f       	mul	r24, r18
    28a6:	a0 01       	movw	r20, r0
    28a8:	83 9f       	mul	r24, r19
    28aa:	50 0d       	add	r21, r0
    28ac:	92 9f       	mul	r25, r18
    28ae:	50 0d       	add	r21, r0
    28b0:	11 24       	eor	r1, r1
    28b2:	01 81       	ldd	r16, Z+1	; 0x01
    28b4:	12 81       	ldd	r17, Z+2	; 0x02
    28b6:	04 0f       	add	r16, r20
    28b8:	15 1f       	adc	r17, r21
	rows_left = font->height;

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;
    28ba:	f6 01       	movw	r30, r12
    28bc:	f3 80       	ldd	r15, Z+3	; 0x03

		for (i = 0; i < pixelsToDraw; i++) {
    28be:	ff 20       	and	r15, r15
    28c0:	a9 f0       	breq	.+42     	; 0x28ec <gfx_mono_draw_char+0x9e>
    28c2:	d0 e0       	ldi	r29, 0x00	; 0
    28c4:	c0 e0       	ldi	r28, 0x00	; 0
    28c6:	8e 2d       	mov	r24, r14
    28c8:	8c 0f       	add	r24, r28
			if (i % CONFIG_FONT_PIXELS_PER_BYTE == 0) {
    28ca:	9c 2f       	mov	r25, r28
    28cc:	97 70       	andi	r25, 0x07	; 7
    28ce:	21 f4       	brne	.+8      	; 0x28d8 <gfx_mono_draw_char+0x8a>
				glyph_byte = PROGMEM_READ_BYTE(glyph_data);
    28d0:	f8 01       	movw	r30, r16
    28d2:	d4 91       	lpm	r29, Z
				glyph_data++;
    28d4:	0f 5f       	subi	r16, 0xFF	; 255
    28d6:	1f 4f       	sbci	r17, 0xFF	; 255
			}

			if ((glyph_byte & 0x80)) {
    28d8:	dd 23       	and	r29, r29
    28da:	24 f4       	brge	.+8      	; 0x28e4 <gfx_mono_draw_char+0x96>
				gfx_mono_draw_pixel(inc_x, inc_y,
    28dc:	41 e0       	ldi	r20, 0x01	; 1
    28de:	6b 2d       	mov	r22, r11
    28e0:	0e 94 4f 05 	call	0xa9e	; 0xa9e <gfx_mono_st7565r_draw_pixel>
						GFX_PIXEL_SET);
			}

			inc_x += 1;
			glyph_byte <<= 1;
    28e4:	dd 0f       	add	r29, r29

	do {
		uint8_t glyph_byte = 0;
		uint8_t pixelsToDraw = font->width;

		for (i = 0; i < pixelsToDraw; i++) {
    28e6:	cf 5f       	subi	r28, 0xFF	; 255
    28e8:	fc 12       	cpse	r15, r28
    28ea:	ed cf       	rjmp	.-38     	; 0x28c6 <gfx_mono_draw_char+0x78>

			inc_x += 1;
			glyph_byte <<= 1;
		}

		inc_y += 1;
    28ec:	b3 94       	inc	r11
		inc_x = x;
		rows_left--;
    28ee:	aa 94       	dec	r10
	} while (rows_left > 0);
    28f0:	a1 10       	cpse	r10, r1
    28f2:	e3 cf       	rjmp	.-58     	; 0x28ba <gfx_mono_draw_char+0x6c>
	default:
		/* Unsupported mode, call assert */
		Assert(false);
		break;
	}
}
    28f4:	df 91       	pop	r29
    28f6:	cf 91       	pop	r28
    28f8:	1f 91       	pop	r17
    28fa:	0f 91       	pop	r16
    28fc:	ff 90       	pop	r15
    28fe:	ef 90       	pop	r14
    2900:	df 90       	pop	r13
    2902:	cf 90       	pop	r12
    2904:	bf 90       	pop	r11
    2906:	af 90       	pop	r10
    2908:	08 95       	ret

0000290a <gfx_mono_draw_string>:
 * \param y         Y coordinate on screen.
 * \param font      Font to draw string in
 */
void gfx_mono_draw_string(const char *str, gfx_coord_t x, gfx_coord_t y,
		const struct font *font)
{
    290a:	df 92       	push	r13
    290c:	ef 92       	push	r14
    290e:	ff 92       	push	r15
    2910:	0f 93       	push	r16
    2912:	1f 93       	push	r17
    2914:	cf 93       	push	r28
    2916:	df 93       	push	r29
    2918:	d6 2e       	mov	r13, r22
    291a:	04 2f       	mov	r16, r20
    291c:	79 01       	movw	r14, r18
    291e:	ec 01       	movw	r28, r24
    2920:	16 2f       	mov	r17, r22
	Assert(font != NULL);

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
    2922:	89 91       	ld	r24, Y+
    2924:	8a 30       	cpi	r24, 0x0A	; 10
    2926:	31 f4       	brne	.+12     	; 0x2934 <gfx_mono_draw_string+0x2a>
			x = start_of_string_position_x;
			y += font->height + 1;
    2928:	f7 01       	movw	r30, r14
    292a:	84 81       	ldd	r24, Z+4	; 0x04
    292c:	8f 5f       	subi	r24, 0xFF	; 255
    292e:	08 0f       	add	r16, r24

	/* Draw characters until trailing null byte */
	do {
		/* Handle '\n' as newline, draw normal characters. */
		if (*str == '\n') {
			x = start_of_string_position_x;
    2930:	1d 2d       	mov	r17, r13
    2932:	09 c0       	rjmp	.+18     	; 0x2946 <gfx_mono_draw_string+0x3c>
			y += font->height + 1;
		} else if (*str == '\r') {
    2934:	8d 30       	cpi	r24, 0x0D	; 13
    2936:	39 f0       	breq	.+14     	; 0x2946 <gfx_mono_draw_string+0x3c>
			/* Skip '\r' characters. */
		} else {
			gfx_mono_draw_char(*str, x, y, font);
    2938:	97 01       	movw	r18, r14
    293a:	40 2f       	mov	r20, r16
    293c:	61 2f       	mov	r22, r17
    293e:	87 df       	rcall	.-242    	; 0x284e <gfx_mono_draw_char>
			x += font->width;
    2940:	f7 01       	movw	r30, r14
    2942:	83 81       	ldd	r24, Z+3	; 0x03
    2944:	18 0f       	add	r17, r24
		}
	} while (*(++str));
    2946:	88 81       	ld	r24, Y
    2948:	81 11       	cpse	r24, r1
    294a:	eb cf       	rjmp	.-42     	; 0x2922 <gfx_mono_draw_string+0x18>
}
    294c:	df 91       	pop	r29
    294e:	cf 91       	pop	r28
    2950:	1f 91       	pop	r17
    2952:	0f 91       	pop	r16
    2954:	ff 90       	pop	r15
    2956:	ef 90       	pop	r14
    2958:	df 90       	pop	r13
    295a:	08 95       	ret

0000295c <ioport_configure_port_pin>:
#include "ioport_compat.h"

#if defined(IOPORT_XMEGA_COMPAT)
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
    295c:	cf 93       	push	r28
    295e:	df 93       	push	r29
    2960:	fc 01       	movw	r30, r24
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    2962:	20 e0       	ldi	r18, 0x00	; 0
    2964:	30 e0       	ldi	r19, 0x00	; 0
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
		if (pin_mask & (1 << pin)) {
    2966:	c6 2f       	mov	r28, r22
    2968:	d0 e0       	ldi	r29, 0x00	; 0
    296a:	de 01       	movw	r26, r28
    296c:	02 2e       	mov	r0, r18
    296e:	02 c0       	rjmp	.+4      	; 0x2974 <ioport_configure_port_pin+0x18>
    2970:	b5 95       	asr	r27
    2972:	a7 95       	ror	r26
    2974:	0a 94       	dec	r0
    2976:	e2 f7       	brpl	.-8      	; 0x2970 <ioport_configure_port_pin+0x14>
    2978:	a0 fd       	sbrc	r26, 0
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
    297a:	50 8b       	std	Z+16, r21	; 0x10
    297c:	2f 5f       	subi	r18, 0xFF	; 255
    297e:	3f 4f       	sbci	r19, 0xFF	; 255
    2980:	31 96       	adiw	r30, 0x01	; 1
void ioport_configure_port_pin(void *port, pin_mask_t pin_mask,
		port_pin_flags_t flags)
{
	uint8_t pin;

	for (pin = 0; pin < 8; pin++) {
    2982:	28 30       	cpi	r18, 0x08	; 8
    2984:	31 05       	cpc	r19, r1
    2986:	89 f7       	brne	.-30     	; 0x296a <ioport_configure_port_pin+0xe>
		if (pin_mask & (1 << pin)) {
			*((uint8_t *)port + PORT_PIN0CTRL + pin) = flags >> 8;
		}
	}
	/* Select direction and initial pin state */
	if (flags & IOPORT_DIR_OUTPUT) {
    2988:	40 ff       	sbrs	r20, 0
    298a:	0a c0       	rjmp	.+20     	; 0x29a0 <ioport_configure_port_pin+0x44>
		if (flags & IOPORT_INIT_HIGH) {
    298c:	41 ff       	sbrs	r20, 1
    298e:	03 c0       	rjmp	.+6      	; 0x2996 <ioport_configure_port_pin+0x3a>
			*((uint8_t *)port + PORT_OUTSET) = pin_mask;
    2990:	fc 01       	movw	r30, r24
    2992:	65 83       	std	Z+5, r22	; 0x05
    2994:	02 c0       	rjmp	.+4      	; 0x299a <ioport_configure_port_pin+0x3e>
		} else {
			*((uint8_t *)port + PORT_OUTCLR) = pin_mask;
    2996:	fc 01       	movw	r30, r24
    2998:	66 83       	std	Z+6, r22	; 0x06
		}

		*((uint8_t *)port + PORT_DIRSET) = pin_mask;
    299a:	fc 01       	movw	r30, r24
    299c:	61 83       	std	Z+1, r22	; 0x01
    299e:	02 c0       	rjmp	.+4      	; 0x29a4 <ioport_configure_port_pin+0x48>
	} else {
		*((uint8_t *)port + PORT_DIRCLR) = pin_mask;
    29a0:	fc 01       	movw	r30, r24
    29a2:	62 83       	std	Z+2, r22	; 0x02
	}
}
    29a4:	df 91       	pop	r29
    29a6:	cf 91       	pop	r28
    29a8:	08 95       	ret

000029aa <board_init>:
 * \param flags Bitmask of flags specifying additional configuration
 * parameters.
 */
static inline void ioport_configure_pin(port_pin_t pin, port_pin_flags_t flags)
{
	ioport_configure_port_pin(arch_ioport_pin_to_base(pin),
    29aa:	43 e0       	ldi	r20, 0x03	; 3
    29ac:	50 e0       	ldi	r21, 0x00	; 0
    29ae:	61 e0       	ldi	r22, 0x01	; 1
    29b0:	80 ee       	ldi	r24, 0xE0	; 224
    29b2:	97 e0       	ldi	r25, 0x07	; 7
    29b4:	d3 df       	rcall	.-90     	; 0x295c <ioport_configure_port_pin>
    29b6:	43 e0       	ldi	r20, 0x03	; 3
    29b8:	50 e0       	ldi	r21, 0x00	; 0
    29ba:	62 e0       	ldi	r22, 0x02	; 2
    29bc:	80 ee       	ldi	r24, 0xE0	; 224
    29be:	97 e0       	ldi	r25, 0x07	; 7
    29c0:	cd df       	rcall	.-102    	; 0x295c <ioport_configure_port_pin>
    29c2:	43 e0       	ldi	r20, 0x03	; 3
    29c4:	50 e0       	ldi	r21, 0x00	; 0
    29c6:	60 e1       	ldi	r22, 0x10	; 16
    29c8:	80 e6       	ldi	r24, 0x60	; 96
    29ca:	96 e0       	ldi	r25, 0x06	; 6
    29cc:	c7 df       	rcall	.-114    	; 0x295c <ioport_configure_port_pin>
    29ce:	41 e0       	ldi	r20, 0x01	; 1
    29d0:	50 e4       	ldi	r21, 0x40	; 64
    29d2:	60 e2       	ldi	r22, 0x20	; 32
    29d4:	80 e6       	ldi	r24, 0x60	; 96
    29d6:	96 e0       	ldi	r25, 0x06	; 6
    29d8:	c1 df       	rcall	.-126    	; 0x295c <ioport_configure_port_pin>
    29da:	40 e0       	ldi	r20, 0x00	; 0
    29dc:	5b e1       	ldi	r21, 0x1B	; 27
    29de:	60 e2       	ldi	r22, 0x20	; 32
    29e0:	80 e8       	ldi	r24, 0x80	; 128
    29e2:	96 e0       	ldi	r25, 0x06	; 6
    29e4:	bb df       	rcall	.-138    	; 0x295c <ioport_configure_port_pin>
    29e6:	40 e0       	ldi	r20, 0x00	; 0
    29e8:	5b e1       	ldi	r21, 0x1B	; 27
    29ea:	62 e0       	ldi	r22, 0x02	; 2
    29ec:	80 ea       	ldi	r24, 0xA0	; 160
    29ee:	96 e0       	ldi	r25, 0x06	; 6
    29f0:	b5 df       	rcall	.-150    	; 0x295c <ioport_configure_port_pin>
    29f2:	40 e0       	ldi	r20, 0x00	; 0
    29f4:	5b e1       	ldi	r21, 0x1B	; 27
    29f6:	64 e0       	ldi	r22, 0x04	; 4
    29f8:	80 ea       	ldi	r24, 0xA0	; 160
    29fa:	96 e0       	ldi	r25, 0x06	; 6
    29fc:	af df       	rcall	.-162    	; 0x295c <ioport_configure_port_pin>
    29fe:	43 e0       	ldi	r20, 0x03	; 3
    2a00:	50 e0       	ldi	r21, 0x00	; 0
    2a02:	62 e0       	ldi	r22, 0x02	; 2
    2a04:	80 e6       	ldi	r24, 0x60	; 96
    2a06:	96 e0       	ldi	r25, 0x06	; 6
    2a08:	a9 df       	rcall	.-174    	; 0x295c <ioport_configure_port_pin>
    2a0a:	43 e0       	ldi	r20, 0x03	; 3
    2a0c:	50 e0       	ldi	r21, 0x00	; 0
    2a0e:	68 e0       	ldi	r22, 0x08	; 8
    2a10:	80 e6       	ldi	r24, 0x60	; 96
    2a12:	96 e0       	ldi	r25, 0x06	; 6
    2a14:	a3 df       	rcall	.-186    	; 0x295c <ioport_configure_port_pin>
    2a16:	43 e0       	ldi	r20, 0x03	; 3
    2a18:	50 e0       	ldi	r21, 0x00	; 0
    2a1a:	68 e0       	ldi	r22, 0x08	; 8
    2a1c:	80 ea       	ldi	r24, 0xA0	; 160
    2a1e:	96 e0       	ldi	r25, 0x06	; 6
    2a20:	9d df       	rcall	.-198    	; 0x295c <ioport_configure_port_pin>
    2a22:	43 e0       	ldi	r20, 0x03	; 3
    2a24:	50 e0       	ldi	r21, 0x00	; 0
    2a26:	61 e0       	ldi	r22, 0x01	; 1
    2a28:	80 e6       	ldi	r24, 0x60	; 96
    2a2a:	96 e0       	ldi	r25, 0x06	; 6
    2a2c:	97 df       	rcall	.-210    	; 0x295c <ioport_configure_port_pin>
    2a2e:	43 e0       	ldi	r20, 0x03	; 3
    2a30:	50 e0       	ldi	r21, 0x00	; 0
    2a32:	68 e0       	ldi	r22, 0x08	; 8
    2a34:	80 e0       	ldi	r24, 0x00	; 0
    2a36:	96 e0       	ldi	r25, 0x06	; 6
    2a38:	91 df       	rcall	.-222    	; 0x295c <ioport_configure_port_pin>
    2a3a:	41 e0       	ldi	r20, 0x01	; 1
    2a3c:	50 e0       	ldi	r21, 0x00	; 0
    2a3e:	60 e1       	ldi	r22, 0x10	; 16
    2a40:	80 e8       	ldi	r24, 0x80	; 128
    2a42:	96 e0       	ldi	r25, 0x06	; 6
    2a44:	8b df       	rcall	.-234    	; 0x295c <ioport_configure_port_pin>
    2a46:	43 e0       	ldi	r20, 0x03	; 3
    2a48:	50 e0       	ldi	r21, 0x00	; 0
    2a4a:	62 e0       	ldi	r22, 0x02	; 2
    2a4c:	80 e6       	ldi	r24, 0x60	; 96
    2a4e:	96 e0       	ldi	r25, 0x06	; 6
    2a50:	85 df       	rcall	.-246    	; 0x295c <ioport_configure_port_pin>
    2a52:	43 e0       	ldi	r20, 0x03	; 3
    2a54:	50 e0       	ldi	r21, 0x00	; 0
    2a56:	68 e0       	ldi	r22, 0x08	; 8
    2a58:	80 e6       	ldi	r24, 0x60	; 96
    2a5a:	96 e0       	ldi	r25, 0x06	; 6
    2a5c:	7f df       	rcall	.-258    	; 0x295c <ioport_configure_port_pin>
    2a5e:	40 e0       	ldi	r20, 0x00	; 0
    2a60:	50 e0       	ldi	r21, 0x00	; 0
    2a62:	64 e0       	ldi	r22, 0x04	; 4
    2a64:	80 e6       	ldi	r24, 0x60	; 96
    2a66:	96 e0       	ldi	r25, 0x06	; 6
    2a68:	79 df       	rcall	.-270    	; 0x295c <ioport_configure_port_pin>
    2a6a:	43 e0       	ldi	r20, 0x03	; 3
    2a6c:	50 e0       	ldi	r21, 0x00	; 0
    2a6e:	60 e1       	ldi	r22, 0x10	; 16
    2a70:	80 ea       	ldi	r24, 0xA0	; 160
    2a72:	96 e0       	ldi	r25, 0x06	; 6
    2a74:	73 df       	rcall	.-282    	; 0x295c <ioport_configure_port_pin>
    2a76:	40 e0       	ldi	r20, 0x00	; 0
    2a78:	50 e0       	ldi	r21, 0x00	; 0
    2a7a:	61 e0       	ldi	r22, 0x01	; 1
    2a7c:	80 e0       	ldi	r24, 0x00	; 0
    2a7e:	96 e0       	ldi	r25, 0x06	; 6
    2a80:	6d df       	rcall	.-294    	; 0x295c <ioport_configure_port_pin>
    2a82:	40 e0       	ldi	r20, 0x00	; 0
    2a84:	50 e0       	ldi	r21, 0x00	; 0
    2a86:	64 e0       	ldi	r22, 0x04	; 4
    2a88:	80 e0       	ldi	r24, 0x00	; 0
    2a8a:	96 e0       	ldi	r25, 0x06	; 6
    2a8c:	67 df       	rcall	.-306    	; 0x295c <ioport_configure_port_pin>
    2a8e:	40 e0       	ldi	r20, 0x00	; 0
    2a90:	50 e0       	ldi	r21, 0x00	; 0
    2a92:	62 e0       	ldi	r22, 0x02	; 2
    2a94:	80 e2       	ldi	r24, 0x20	; 32
    2a96:	96 e0       	ldi	r25, 0x06	; 6
    2a98:	61 df       	rcall	.-318    	; 0x295c <ioport_configure_port_pin>
    2a9a:	43 e0       	ldi	r20, 0x03	; 3
    2a9c:	50 e0       	ldi	r21, 0x00	; 0
    2a9e:	68 e0       	ldi	r22, 0x08	; 8
    2aa0:	80 e4       	ldi	r24, 0x40	; 64
    2aa2:	96 e0       	ldi	r25, 0x06	; 6
    2aa4:	5b df       	rcall	.-330    	; 0x295c <ioport_configure_port_pin>
    2aa6:	40 e0       	ldi	r20, 0x00	; 0
    2aa8:	50 e0       	ldi	r21, 0x00	; 0
    2aaa:	64 e0       	ldi	r22, 0x04	; 4
    2aac:	80 e4       	ldi	r24, 0x40	; 64
    2aae:	96 e0       	ldi	r25, 0x06	; 6
    2ab0:	55 df       	rcall	.-342    	; 0x295c <ioport_configure_port_pin>
    2ab2:	43 e0       	ldi	r20, 0x03	; 3
    2ab4:	50 e0       	ldi	r21, 0x00	; 0
    2ab6:	68 e0       	ldi	r22, 0x08	; 8
    2ab8:	80 e6       	ldi	r24, 0x60	; 96
    2aba:	96 e0       	ldi	r25, 0x06	; 6
    2abc:	4f df       	rcall	.-354    	; 0x295c <ioport_configure_port_pin>
    2abe:	40 e0       	ldi	r20, 0x00	; 0
    2ac0:	50 e0       	ldi	r21, 0x00	; 0
    2ac2:	64 e0       	ldi	r22, 0x04	; 4
    2ac4:	80 e6       	ldi	r24, 0x60	; 96
    2ac6:	96 e0       	ldi	r25, 0x06	; 6
    2ac8:	49 df       	rcall	.-366    	; 0x295c <ioport_configure_port_pin>
    2aca:	43 e0       	ldi	r20, 0x03	; 3
    2acc:	50 e0       	ldi	r21, 0x00	; 0
    2ace:	68 e0       	ldi	r22, 0x08	; 8
    2ad0:	80 e8       	ldi	r24, 0x80	; 128
    2ad2:	96 e0       	ldi	r25, 0x06	; 6
    2ad4:	43 df       	rcall	.-378    	; 0x295c <ioport_configure_port_pin>
    2ad6:	40 e0       	ldi	r20, 0x00	; 0
    2ad8:	50 e0       	ldi	r21, 0x00	; 0
    2ada:	64 e0       	ldi	r22, 0x04	; 4
    2adc:	80 e8       	ldi	r24, 0x80	; 128
    2ade:	96 e0       	ldi	r25, 0x06	; 6
    2ae0:	3d cf       	rjmp	.-390    	; 0x295c <ioport_configure_port_pin>
    2ae2:	08 95       	ret

00002ae4 <vCounter>:

		vTaskDelay(10 / portTICK_PERIOD_MS);
	}
}

static portTASK_FUNCTION(vCounter, r_) {
    2ae4:	cf 93       	push	r28
    2ae6:	df 93       	push	r29
    2ae8:	cd b7       	in	r28, 0x3d	; 61
    2aea:	de b7       	in	r29, 0x3e	; 62
    2aec:	c0 58       	subi	r28, 0x80	; 128
    2aee:	d1 09       	sbc	r29, r1
    2af0:	cd bf       	out	0x3d, r28	; 61
    2af2:	de bf       	out	0x3e, r29	; 62
	char strbuf[128];

	while (1) {
		if (xSemaphoreTake(xSemaphore, (TickType_t)10) == pdTRUE) {
			counter++;
			snprintf(strbuf, sizeof(strbuf), "Counter : %d", counter);
    2af4:	0f 2e       	mov	r0, r31
    2af6:	fa e1       	ldi	r31, 0x1A	; 26
    2af8:	ef 2e       	mov	r14, r31
    2afa:	f0 e2       	ldi	r31, 0x20	; 32
    2afc:	ff 2e       	mov	r15, r31
    2afe:	f0 2d       	mov	r31, r0
    2b00:	68 94       	set
    2b02:	dd 24       	eor	r13, r13
    2b04:	d7 f8       	bld	r13, 7
    2b06:	8e 01       	movw	r16, r28
    2b08:	0f 5f       	subi	r16, 0xFF	; 255
    2b0a:	1f 4f       	sbci	r17, 0xFF	; 255

static portTASK_FUNCTION(vCounter, r_) {
	char strbuf[128];

	while (1) {
		if (xSemaphoreTake(xSemaphore, (TickType_t)10) == pdTRUE) {
    2b0c:	6a e0       	ldi	r22, 0x0A	; 10
    2b0e:	70 e0       	ldi	r23, 0x00	; 0
    2b10:	80 91 d3 22 	lds	r24, 0x22D3	; 0x8022d3 <xSemaphore>
    2b14:	90 91 d4 22 	lds	r25, 0x22D4	; 0x8022d4 <xSemaphore+0x1>
    2b18:	0e 94 34 0c 	call	0x1868	; 0x1868 <xQueueSemaphoreTake>
    2b1c:	81 30       	cpi	r24, 0x01	; 1
    2b1e:	29 f5       	brne	.+74     	; 0x2b6a <vCounter+0x86>
			counter++;
    2b20:	80 91 d1 22 	lds	r24, 0x22D1	; 0x8022d1 <counter>
    2b24:	90 91 d2 22 	lds	r25, 0x22D2	; 0x8022d2 <counter+0x1>
    2b28:	01 96       	adiw	r24, 0x01	; 1
    2b2a:	80 93 d1 22 	sts	0x22D1, r24	; 0x8022d1 <counter>
    2b2e:	90 93 d2 22 	sts	0x22D2, r25	; 0x8022d2 <counter+0x1>
			snprintf(strbuf, sizeof(strbuf), "Counter : %d", counter);
    2b32:	9f 93       	push	r25
    2b34:	8f 93       	push	r24
    2b36:	ff 92       	push	r15
    2b38:	ef 92       	push	r14
    2b3a:	1f 92       	push	r1
    2b3c:	df 92       	push	r13
    2b3e:	1f 93       	push	r17
    2b40:	0f 93       	push	r16
    2b42:	c6 d2       	rcall	.+1420   	; 0x30d0 <snprintf>
			gfx_mono_draw_string(strbuf, 0, 8, &sysfont);
    2b44:	26 e0       	ldi	r18, 0x06	; 6
    2b46:	30 e2       	ldi	r19, 0x20	; 32
    2b48:	48 e0       	ldi	r20, 0x08	; 8
    2b4a:	60 e0       	ldi	r22, 0x00	; 0
    2b4c:	c8 01       	movw	r24, r16
    2b4e:	dd de       	rcall	.-582    	; 0x290a <gfx_mono_draw_string>
			xSemaphoreGive(xSemaphore);
    2b50:	20 e0       	ldi	r18, 0x00	; 0
    2b52:	40 e0       	ldi	r20, 0x00	; 0
    2b54:	50 e0       	ldi	r21, 0x00	; 0
    2b56:	60 e0       	ldi	r22, 0x00	; 0
    2b58:	70 e0       	ldi	r23, 0x00	; 0
    2b5a:	80 91 d3 22 	lds	r24, 0x22D3	; 0x8022d3 <xSemaphore>
    2b5e:	90 91 d4 22 	lds	r25, 0x22D4	; 0x8022d4 <xSemaphore+0x1>
    2b62:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <xQueueGenericSend>
    2b66:	cd bf       	out	0x3d, r28	; 61
    2b68:	de bf       	out	0x3e, r29	; 62
		}

		vTaskDelay(100 / portTICK_PERIOD_MS);
    2b6a:	82 e3       	ldi	r24, 0x32	; 50
    2b6c:	90 e0       	ldi	r25, 0x00	; 0
    2b6e:	e6 d9       	rcall	.-3124   	; 0x1f3c <vTaskDelay>
	}
    2b70:	cd cf       	rjmp	.-102    	; 0x2b0c <vCounter+0x28>

00002b72 <vPushButton1>:
		}
		vTaskDelay(20 / portTICK_PERIOD_MS); // Adjust delay for smooth movement
	}
}

static portTASK_FUNCTION(vPushButton1, s_) {
    2b72:	cf 93       	push	r28
    2b74:	df 93       	push	r29
    2b76:	cd b7       	in	r28, 0x3d	; 61
    2b78:	de b7       	in	r29, 0x3e	; 62
    2b7a:	c0 58       	subi	r28, 0x80	; 128
    2b7c:	d1 09       	sbc	r29, r1
    2b7e:	cd bf       	out	0x3d, r28	; 61
    2b80:	de bf       	out	0x3e, r29	; 62

__always_inline static bool arch_ioport_get_pin_level(ioport_pin_t pin)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	return base->IN & arch_ioport_pin_to_mask(pin);
    2b82:	00 ea       	ldi	r16, 0xA0	; 160
    2b84:	16 e0       	ldi	r17, 0x06	; 6

	while (1) {
		if (ioport_get_pin_level(GPIO_PUSH_BUTTON_1) == 0) {
			if (xSemaphoreTake(xSemaphore, (TickType_t)10) == pdTRUE) {
				counter++;
				snprintf(strbuf, sizeof(strbuf), "Counter : %d", counter);
    2b86:	0f 2e       	mov	r0, r31
    2b88:	fa e1       	ldi	r31, 0x1A	; 26
    2b8a:	cf 2e       	mov	r12, r31
    2b8c:	f0 e2       	ldi	r31, 0x20	; 32
    2b8e:	df 2e       	mov	r13, r31
    2b90:	f0 2d       	mov	r31, r0
    2b92:	68 94       	set
    2b94:	bb 24       	eor	r11, r11
    2b96:	b7 f8       	bld	r11, 7
    2b98:	ce 01       	movw	r24, r28
    2b9a:	01 96       	adiw	r24, 0x01	; 1
    2b9c:	7c 01       	movw	r14, r24
    2b9e:	f8 01       	movw	r30, r16
    2ba0:	80 85       	ldd	r24, Z+8	; 0x08

static portTASK_FUNCTION(vPushButton1, s_) {
	char strbuf[128];

	while (1) {
		if (ioport_get_pin_level(GPIO_PUSH_BUTTON_1) == 0) {
    2ba2:	81 fd       	sbrc	r24, 1
    2ba4:	2f c0       	rjmp	.+94     	; 0x2c04 <vPushButton1+0x92>
			if (xSemaphoreTake(xSemaphore, (TickType_t)10) == pdTRUE) {
    2ba6:	6a e0       	ldi	r22, 0x0A	; 10
    2ba8:	70 e0       	ldi	r23, 0x00	; 0
    2baa:	80 91 d3 22 	lds	r24, 0x22D3	; 0x8022d3 <xSemaphore>
    2bae:	90 91 d4 22 	lds	r25, 0x22D4	; 0x8022d4 <xSemaphore+0x1>
    2bb2:	0e 94 34 0c 	call	0x1868	; 0x1868 <xQueueSemaphoreTake>
    2bb6:	81 30       	cpi	r24, 0x01	; 1
    2bb8:	29 f5       	brne	.+74     	; 0x2c04 <vPushButton1+0x92>
				counter++;
    2bba:	80 91 d1 22 	lds	r24, 0x22D1	; 0x8022d1 <counter>
    2bbe:	90 91 d2 22 	lds	r25, 0x22D2	; 0x8022d2 <counter+0x1>
    2bc2:	01 96       	adiw	r24, 0x01	; 1
    2bc4:	80 93 d1 22 	sts	0x22D1, r24	; 0x8022d1 <counter>
    2bc8:	90 93 d2 22 	sts	0x22D2, r25	; 0x8022d2 <counter+0x1>
				snprintf(strbuf, sizeof(strbuf), "Counter : %d", counter);
    2bcc:	9f 93       	push	r25
    2bce:	8f 93       	push	r24
    2bd0:	df 92       	push	r13
    2bd2:	cf 92       	push	r12
    2bd4:	1f 92       	push	r1
    2bd6:	bf 92       	push	r11
    2bd8:	ff 92       	push	r15
    2bda:	ef 92       	push	r14
    2bdc:	79 d2       	rcall	.+1266   	; 0x30d0 <snprintf>
				gfx_mono_draw_string(strbuf, 0, 8, &sysfont);
    2bde:	26 e0       	ldi	r18, 0x06	; 6
    2be0:	30 e2       	ldi	r19, 0x20	; 32
    2be2:	48 e0       	ldi	r20, 0x08	; 8
    2be4:	60 e0       	ldi	r22, 0x00	; 0
    2be6:	c7 01       	movw	r24, r14
    2be8:	90 de       	rcall	.-736    	; 0x290a <gfx_mono_draw_string>
				xSemaphoreGive(xSemaphore);
    2bea:	20 e0       	ldi	r18, 0x00	; 0
    2bec:	40 e0       	ldi	r20, 0x00	; 0
    2bee:	50 e0       	ldi	r21, 0x00	; 0
    2bf0:	60 e0       	ldi	r22, 0x00	; 0
    2bf2:	70 e0       	ldi	r23, 0x00	; 0
    2bf4:	80 91 d3 22 	lds	r24, 0x22D3	; 0x8022d3 <xSemaphore>
    2bf8:	90 91 d4 22 	lds	r25, 0x22D4	; 0x8022d4 <xSemaphore+0x1>
    2bfc:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <xQueueGenericSend>
    2c00:	cd bf       	out	0x3d, r28	; 61
    2c02:	de bf       	out	0x3e, r29	; 62
			}
		}

		vTaskDelay(10 / portTICK_PERIOD_MS);
    2c04:	85 e0       	ldi	r24, 0x05	; 5
    2c06:	90 e0       	ldi	r25, 0x00	; 0
    2c08:	99 d9       	rcall	.-3278   	; 0x1f3c <vTaskDelay>
	}
    2c0a:	c9 cf       	rjmp	.-110    	; 0x2b9e <vPushButton1+0x2c>

00002c0c <vBlinkLed0>:

	/* Start the task */
	vTaskStartScheduler();
}

static portTASK_FUNCTION(vBlinkLed0, p_) {
    2c0c:	cf 93       	push	r28
    2c0e:	df 93       	push	r29
    2c10:	cd b7       	in	r28, 0x3d	; 61
    2c12:	de b7       	in	r29, 0x3e	; 62
    2c14:	c0 58       	subi	r28, 0x80	; 128
    2c16:	d1 09       	sbc	r29, r1
    2c18:	cd bf       	out	0x3d, r28	; 61
    2c1a:	de bf       	out	0x3e, r29	; 62
	char strbuf[128];
	int flagLed0 = 1;
    2c1c:	81 e0       	ldi	r24, 0x01	; 1
    2c1e:	90 e0       	ldi	r25, 0x00	; 0
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    2c20:	0f 2e       	mov	r0, r31
    2c22:	f0 ee       	ldi	r31, 0xE0	; 224
    2c24:	af 2e       	mov	r10, r31
    2c26:	f7 e0       	ldi	r31, 0x07	; 7
    2c28:	bf 2e       	mov	r11, r31
    2c2a:	f0 2d       	mov	r31, r0

	while (1) {
		flagLed0 = !flagLed0;
		ioport_set_pin_level(LED0_GPIO, flagLed0);
		snprintf(strbuf, sizeof(strbuf), "LED 0 : %d", !flagLed0);
    2c2c:	0f 2e       	mov	r0, r31
    2c2e:	f7 e2       	ldi	r31, 0x27	; 39
    2c30:	cf 2e       	mov	r12, r31
    2c32:	f0 e2       	ldi	r31, 0x20	; 32
    2c34:	df 2e       	mov	r13, r31
    2c36:	f0 2d       	mov	r31, r0
    2c38:	68 94       	set
    2c3a:	99 24       	eor	r9, r9
    2c3c:	97 f8       	bld	r9, 7
    2c3e:	9e 01       	movw	r18, r28
    2c40:	2f 5f       	subi	r18, 0xFF	; 255
    2c42:	3f 4f       	sbci	r19, 0xFF	; 255
    2c44:	79 01       	movw	r14, r18
static portTASK_FUNCTION(vBlinkLed0, p_) {
	char strbuf[128];
	int flagLed0 = 1;

	while (1) {
		flagLed0 = !flagLed0;
    2c46:	01 e0       	ldi	r16, 0x01	; 1
    2c48:	00 97       	sbiw	r24, 0x00	; 0
    2c4a:	09 f0       	breq	.+2      	; 0x2c4e <vBlinkLed0+0x42>
    2c4c:	00 e0       	ldi	r16, 0x00	; 0
    2c4e:	10 e0       	ldi	r17, 0x00	; 0
__always_inline static void arch_ioport_set_pin_level(ioport_pin_t pin,
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
    2c50:	00 97       	sbiw	r24, 0x00	; 0
    2c52:	21 f4       	brne	.+8      	; 0x2c5c <vBlinkLed0+0x50>
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    2c54:	21 e0       	ldi	r18, 0x01	; 1
    2c56:	f5 01       	movw	r30, r10
    2c58:	25 83       	std	Z+5, r18	; 0x05
    2c5a:	03 c0       	rjmp	.+6      	; 0x2c62 <vBlinkLed0+0x56>
	} else {
		base->OUTCLR = arch_ioport_pin_to_mask(pin);
    2c5c:	21 e0       	ldi	r18, 0x01	; 1
    2c5e:	f5 01       	movw	r30, r10
    2c60:	26 83       	std	Z+6, r18	; 0x06
		ioport_set_pin_level(LED0_GPIO, flagLed0);
		snprintf(strbuf, sizeof(strbuf), "LED 0 : %d", !flagLed0);
    2c62:	21 e0       	ldi	r18, 0x01	; 1
    2c64:	30 e0       	ldi	r19, 0x00	; 0
    2c66:	89 2b       	or	r24, r25
    2c68:	09 f4       	brne	.+2      	; 0x2c6c <vBlinkLed0+0x60>
    2c6a:	20 e0       	ldi	r18, 0x00	; 0
    2c6c:	3f 93       	push	r19
    2c6e:	2f 93       	push	r18
    2c70:	df 92       	push	r13
    2c72:	cf 92       	push	r12
    2c74:	1f 92       	push	r1
    2c76:	9f 92       	push	r9
    2c78:	ff 92       	push	r15
    2c7a:	ef 92       	push	r14
    2c7c:	29 d2       	rcall	.+1106   	; 0x30d0 <snprintf>
		gfx_mono_draw_string(strbuf, 0, 16, &sysfont);
    2c7e:	26 e0       	ldi	r18, 0x06	; 6
    2c80:	30 e2       	ldi	r19, 0x20	; 32
    2c82:	40 e1       	ldi	r20, 0x10	; 16
    2c84:	60 e0       	ldi	r22, 0x00	; 0
    2c86:	c7 01       	movw	r24, r14
    2c88:	40 de       	rcall	.-896    	; 0x290a <gfx_mono_draw_string>
		vTaskDelay(100 / portTICK_PERIOD_MS);
    2c8a:	82 e3       	ldi	r24, 0x32	; 50
    2c8c:	90 e0       	ldi	r25, 0x00	; 0
    2c8e:	56 d9       	rcall	.-3412   	; 0x1f3c <vTaskDelay>
	}
    2c90:	cd bf       	out	0x3d, r28	; 61
    2c92:	de bf       	out	0x3e, r29	; 62
static portTASK_FUNCTION(vBlinkLed0, p_) {
	char strbuf[128];
	int flagLed0 = 1;

	while (1) {
		flagLed0 = !flagLed0;
    2c94:	c8 01       	movw	r24, r16
		ioport_set_pin_level(LED0_GPIO, flagLed0);
		snprintf(strbuf, sizeof(strbuf), "LED 0 : %d", !flagLed0);
		gfx_mono_draw_string(strbuf, 0, 16, &sysfont);
		vTaskDelay(100 / portTICK_PERIOD_MS);
	}
    2c96:	d7 cf       	rjmp	.-82     	; 0x2c46 <vBlinkLed0+0x3a>

00002c98 <PWM_Init>:

/* PWM configurations for servo */
void PWM_Init(void)
{
	/* Set output */
	PORTC.DIR |= PIN0_bm;	// PC0
    2c98:	e0 e4       	ldi	r30, 0x40	; 64
    2c9a:	f6 e0       	ldi	r31, 0x06	; 6
    2c9c:	80 81       	ld	r24, Z
    2c9e:	81 60       	ori	r24, 0x01	; 1
    2ca0:	80 83       	st	Z, r24
	/* Set Register */
	TCC0.CTRLA = (PIN2_bm) | (PIN1_bm);		// Berdasarkan datasheet, 0110 adalah prescaler 256
    2ca2:	e0 e0       	ldi	r30, 0x00	; 0
    2ca4:	f8 e0       	ldi	r31, 0x08	; 8
    2ca6:	86 e0       	ldi	r24, 0x06	; 6
    2ca8:	80 83       	st	Z, r24
	TCC0.CTRLB = (PIN4_bm) | (PIN2_bm) | (PIN1_bm);		// Berdasarkan datasheet, pin4 dan 110 adalah enable cca dan double-slope pwm
    2caa:	86 e1       	ldi	r24, 0x16	; 22
    2cac:	81 83       	std	Z+1, r24	; 0x01
	/* Set Period */
	TCC0.PER = 156;		// didapat dari rumus PER = clock / (prescaler x frekuensi) dmn clocknya 2MHz (default system clock), prescaler 256, dan frekuensi 50hz (dari 20ms pulse cycle servo)
    2cae:	8c e9       	ldi	r24, 0x9C	; 156
    2cb0:	90 e0       	ldi	r25, 0x00	; 0
    2cb2:	86 a3       	std	Z+38, r24	; 0x26
    2cb4:	97 a3       	std	Z+39, r25	; 0x27
	/* Set Compare Register value*/
	TCC0.CCA = 1;
    2cb6:	81 e0       	ldi	r24, 0x01	; 1
    2cb8:	90 e0       	ldi	r25, 0x00	; 0
    2cba:	80 a7       	std	Z+40, r24	; 0x28
    2cbc:	91 a7       	std	Z+41, r25	; 0x29
    2cbe:	08 95       	ret

00002cc0 <vServo>:
		gfx_mono_draw_string(strbuf, 0, 16, &sysfont);
		vTaskDelay(100 / portTICK_PERIOD_MS);
	}
}

static portTASK_FUNCTION(vServo, q_) {
    2cc0:	cf 93       	push	r28
    2cc2:	df 93       	push	r29
    2cc4:	cd b7       	in	r28, 0x3d	; 61
    2cc6:	de b7       	in	r29, 0x3e	; 62
    2cc8:	c0 58       	subi	r28, 0x80	; 128
    2cca:	d1 09       	sbc	r29, r1
    2ccc:	cd bf       	out	0x3d, r28	; 61
    2cce:	de bf       	out	0x3e, r29	; 62
	char strbuf[128];
	/* Initialize PWM for servo control */
	PWM_Init();
    2cd0:	e3 df       	rcall	.-58     	; 0x2c98 <PWM_Init>
	// variables for controlling servo
	uint16_t duty_cycle = 1;
	uint16_t direction = 1;
    2cd2:	ee 24       	eor	r14, r14
    2cd4:	e3 94       	inc	r14
    2cd6:	f1 2c       	mov	r15, r1
static portTASK_FUNCTION(vServo, q_) {
	char strbuf[128];
	/* Initialize PWM for servo control */
	PWM_Init();
	// variables for controlling servo
	uint16_t duty_cycle = 1;
    2cd8:	01 e0       	ldi	r16, 0x01	; 1
    2cda:	10 e0       	ldi	r17, 0x00	; 0
	uint16_t direction = 1;
	
	while (1) {
		if (xSemaphoreTake(xSemaphore, (TickType_t)10) == pdTRUE) {
			TCC0.CCA = duty_cycle;
    2cdc:	61 2c       	mov	r6, r1
    2cde:	68 94       	set
    2ce0:	77 24       	eor	r7, r7
    2ce2:	73 f8       	bld	r7, 3
				} else if (duty_cycle <= 1) {
				direction = 1; // Change direction to increase
			}

			// Display the duty cycle value to keep track
			snprintf(strbuf, sizeof(strbuf), "Servo Duty: %u", duty_cycle);
    2ce4:	0f 2e       	mov	r0, r31
    2ce6:	f2 e3       	ldi	r31, 0x32	; 50
    2ce8:	af 2e       	mov	r10, r31
    2cea:	f0 e2       	ldi	r31, 0x20	; 32
    2cec:	bf 2e       	mov	r11, r31
    2cee:	f0 2d       	mov	r31, r0
    2cf0:	68 94       	set
    2cf2:	99 24       	eor	r9, r9
    2cf4:	97 f8       	bld	r9, 7
    2cf6:	ce 01       	movw	r24, r28
    2cf8:	01 96       	adiw	r24, 0x01	; 1
    2cfa:	6c 01       	movw	r12, r24
			duty_cycle += direction;
			
			// Change direction if reach the ends
			// 1 for 0 Degress and 10 for 180 degrees
			if (duty_cycle >= 10) {
				direction = -1; // Change direction to decrease
    2cfc:	55 24       	eor	r5, r5
    2cfe:	5a 94       	dec	r5
    2d00:	88 24       	eor	r8, r8
    2d02:	8a 94       	dec	r8
	// variables for controlling servo
	uint16_t duty_cycle = 1;
	uint16_t direction = 1;
	
	while (1) {
		if (xSemaphoreTake(xSemaphore, (TickType_t)10) == pdTRUE) {
    2d04:	6a e0       	ldi	r22, 0x0A	; 10
    2d06:	70 e0       	ldi	r23, 0x00	; 0
    2d08:	80 91 d3 22 	lds	r24, 0x22D3	; 0x8022d3 <xSemaphore>
    2d0c:	90 91 d4 22 	lds	r25, 0x22D4	; 0x8022d4 <xSemaphore+0x1>
    2d10:	0e 94 34 0c 	call	0x1868	; 0x1868 <xQueueSemaphoreTake>
    2d14:	81 30       	cpi	r24, 0x01	; 1
    2d16:	69 f5       	brne	.+90     	; 0x2d72 <vServo+0xb2>
			TCC0.CCA = duty_cycle;
    2d18:	f3 01       	movw	r30, r6
    2d1a:	00 a7       	std	Z+40, r16	; 0x28
    2d1c:	11 a7       	std	Z+41, r17	; 0x29
			
			// Update the duty cycle
			duty_cycle += direction;
    2d1e:	0e 0d       	add	r16, r14
    2d20:	1f 1d       	adc	r17, r15
			
			// Change direction if reach the ends
			// 1 for 0 Degress and 10 for 180 degrees
			if (duty_cycle >= 10) {
    2d22:	0a 30       	cpi	r16, 0x0A	; 10
    2d24:	11 05       	cpc	r17, r1
    2d26:	38 f4       	brcc	.+14     	; 0x2d36 <vServo+0x76>
				direction = -1; // Change direction to decrease
				} else if (duty_cycle <= 1) {
    2d28:	02 30       	cpi	r16, 0x02	; 2
    2d2a:	11 05       	cpc	r17, r1
    2d2c:	30 f4       	brcc	.+12     	; 0x2d3a <vServo+0x7a>
				direction = 1; // Change direction to increase
    2d2e:	ee 24       	eor	r14, r14
    2d30:	e3 94       	inc	r14
    2d32:	f1 2c       	mov	r15, r1
    2d34:	02 c0       	rjmp	.+4      	; 0x2d3a <vServo+0x7a>
			duty_cycle += direction;
			
			// Change direction if reach the ends
			// 1 for 0 Degress and 10 for 180 degrees
			if (duty_cycle >= 10) {
				direction = -1; // Change direction to decrease
    2d36:	e5 2c       	mov	r14, r5
    2d38:	f8 2c       	mov	r15, r8
				} else if (duty_cycle <= 1) {
				direction = 1; // Change direction to increase
			}

			// Display the duty cycle value to keep track
			snprintf(strbuf, sizeof(strbuf), "Servo Duty: %u", duty_cycle);
    2d3a:	1f 93       	push	r17
    2d3c:	0f 93       	push	r16
    2d3e:	bf 92       	push	r11
    2d40:	af 92       	push	r10
    2d42:	1f 92       	push	r1
    2d44:	9f 92       	push	r9
    2d46:	df 92       	push	r13
    2d48:	cf 92       	push	r12
    2d4a:	c2 d1       	rcall	.+900    	; 0x30d0 <snprintf>
			gfx_mono_draw_string(strbuf, 0, 24, &sysfont);
    2d4c:	26 e0       	ldi	r18, 0x06	; 6
    2d4e:	30 e2       	ldi	r19, 0x20	; 32
    2d50:	48 e1       	ldi	r20, 0x18	; 24
    2d52:	60 e0       	ldi	r22, 0x00	; 0
    2d54:	c6 01       	movw	r24, r12
    2d56:	d9 dd       	rcall	.-1102   	; 0x290a <gfx_mono_draw_string>

			xSemaphoreGive(xSemaphore);
    2d58:	20 e0       	ldi	r18, 0x00	; 0
    2d5a:	40 e0       	ldi	r20, 0x00	; 0
    2d5c:	50 e0       	ldi	r21, 0x00	; 0
    2d5e:	60 e0       	ldi	r22, 0x00	; 0
    2d60:	70 e0       	ldi	r23, 0x00	; 0
    2d62:	80 91 d3 22 	lds	r24, 0x22D3	; 0x8022d3 <xSemaphore>
    2d66:	90 91 d4 22 	lds	r25, 0x22D4	; 0x8022d4 <xSemaphore+0x1>
    2d6a:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <xQueueGenericSend>
    2d6e:	cd bf       	out	0x3d, r28	; 61
		}
		vTaskDelay(20 / portTICK_PERIOD_MS); // Adjust delay for smooth movement
    2d70:	de bf       	out	0x3e, r29	; 62
    2d72:	8a e0       	ldi	r24, 0x0A	; 10
    2d74:	90 e0       	ldi	r25, 0x00	; 0
    2d76:	e2 d8       	rcall	.-3644   	; 0x1f3c <vTaskDelay>
	}
    2d78:	c5 cf       	rjmp	.-118    	; 0x2d04 <vServo+0x44>

00002d7a <main>:
	TCC0.PER = 156;		// didapat dari rumus PER = clock / (prescaler x frekuensi) dmn clocknya 2MHz (default system clock), prescaler 256, dan frekuensi 50hz (dari 20ms pulse cycle servo)
	/* Set Compare Register value*/
	TCC0.CCA = 1;
}

int main(void) {
    2d7a:	ef 92       	push	r14
    2d7c:	ff 92       	push	r15
    2d7e:	0f 93       	push	r16
	/* System clock initialization */
	sysclk_init();
    2d80:	40 dd       	rcall	.-1408   	; 0x2802 <sysclk_init>
	board_init();
    2d82:	13 de       	rcall	.-986    	; 0x29aa <board_init>
    2d84:	0e 94 0a 05 	call	0xa14	; 0xa14 <gfx_mono_st7565r_init>
	gfx_mono_init();
    2d88:	80 e1       	ldi	r24, 0x10	; 16
		bool level)
{
	PORT_t *base = arch_ioport_pin_to_base(pin);

	if (level) {
		base->OUTSET = arch_ioport_pin_to_mask(pin);
    2d8a:	80 93 85 06 	sts	0x0685, r24	; 0x800685 <__TEXT_REGION_LENGTH__+0x700685>
    2d8e:	26 e0       	ldi	r18, 0x06	; 6

	gpio_set_pin_high(LCD_BACKLIGHT_ENABLE_PIN);
	gfx_mono_draw_string("RaihanRadityaRafinal", 0, 0, &sysfont);
    2d90:	30 e2       	ldi	r19, 0x20	; 32
    2d92:	40 e0       	ldi	r20, 0x00	; 0
    2d94:	60 e0       	ldi	r22, 0x00	; 0
    2d96:	81 e4       	ldi	r24, 0x41	; 65
    2d98:	90 e2       	ldi	r25, 0x20	; 32
    2d9a:	b7 dd       	rcall	.-1170   	; 0x290a <gfx_mono_draw_string>
    2d9c:	e1 2c       	mov	r14, r1

	/* Create the task */
	xTaskCreate(vBlinkLed0, "", 1000, NULL, tskIDLE_PRIORITY + 1, NULL);
    2d9e:	f1 2c       	mov	r15, r1
    2da0:	01 e0       	ldi	r16, 0x01	; 1
    2da2:	20 e0       	ldi	r18, 0x00	; 0
    2da4:	30 e0       	ldi	r19, 0x00	; 0
    2da6:	48 ee       	ldi	r20, 0xE8	; 232
    2da8:	53 e0       	ldi	r21, 0x03	; 3
    2daa:	61 e1       	ldi	r22, 0x11	; 17
    2dac:	70 e2       	ldi	r23, 0x20	; 32
    2dae:	86 e0       	ldi	r24, 0x06	; 6
    2db0:	96 e1       	ldi	r25, 0x16	; 22
    2db2:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <xTaskCreate>
    2db6:	02 e0       	ldi	r16, 0x02	; 2
	xTaskCreate(vServo, "", 1000, NULL, tskIDLE_PRIORITY + 2, NULL);
    2db8:	20 e0       	ldi	r18, 0x00	; 0
    2dba:	30 e0       	ldi	r19, 0x00	; 0
    2dbc:	48 ee       	ldi	r20, 0xE8	; 232
    2dbe:	53 e0       	ldi	r21, 0x03	; 3
    2dc0:	61 e1       	ldi	r22, 0x11	; 17
    2dc2:	70 e2       	ldi	r23, 0x20	; 32
    2dc4:	80 e6       	ldi	r24, 0x60	; 96
    2dc6:	96 e1       	ldi	r25, 0x16	; 22
    2dc8:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <xTaskCreate>
    2dcc:	03 e0       	ldi	r16, 0x03	; 3
	xTaskCreate(vPushButton1, "", 1000, NULL, tskIDLE_PRIORITY + 3, NULL);
    2dce:	20 e0       	ldi	r18, 0x00	; 0
    2dd0:	30 e0       	ldi	r19, 0x00	; 0
    2dd2:	48 ee       	ldi	r20, 0xE8	; 232
    2dd4:	53 e0       	ldi	r21, 0x03	; 3
    2dd6:	61 e1       	ldi	r22, 0x11	; 17
    2dd8:	70 e2       	ldi	r23, 0x20	; 32
    2dda:	89 eb       	ldi	r24, 0xB9	; 185
    2ddc:	95 e1       	ldi	r25, 0x15	; 21
    2dde:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <xTaskCreate>
    2de2:	00 e0       	ldi	r16, 0x00	; 0
	xTaskCreate(vCounter, "", 1000, NULL, tskIDLE_PRIORITY, NULL);
    2de4:	20 e0       	ldi	r18, 0x00	; 0
    2de6:	30 e0       	ldi	r19, 0x00	; 0
    2de8:	48 ee       	ldi	r20, 0xE8	; 232
    2dea:	53 e0       	ldi	r21, 0x03	; 3
    2dec:	61 e1       	ldi	r22, 0x11	; 17
    2dee:	70 e2       	ldi	r23, 0x20	; 32
    2df0:	82 e7       	ldi	r24, 0x72	; 114
    2df2:	95 e1       	ldi	r25, 0x15	; 21
    2df4:	0e 94 2f 0d 	call	0x1a5e	; 0x1a5e <xTaskCreate>
    2df8:	43 e0       	ldi	r20, 0x03	; 3

	/* Semaphore */
	xSemaphore = xSemaphoreCreateBinary();
    2dfa:	60 e0       	ldi	r22, 0x00	; 0
    2dfc:	81 e0       	ldi	r24, 0x01	; 1
    2dfe:	0e 94 c8 0a 	call	0x1590	; 0x1590 <xQueueGenericCreate>
    2e02:	80 93 d3 22 	sts	0x22D3, r24	; 0x8022d3 <xSemaphore>
    2e06:	90 93 d4 22 	sts	0x22D4, r25	; 0x8022d4 <xSemaphore+0x1>
    2e0a:	20 e0       	ldi	r18, 0x00	; 0
	xSemaphoreGive(xSemaphore);
    2e0c:	40 e0       	ldi	r20, 0x00	; 0
    2e0e:	50 e0       	ldi	r21, 0x00	; 0
    2e10:	60 e0       	ldi	r22, 0x00	; 0
    2e12:	70 e0       	ldi	r23, 0x00	; 0
    2e14:	0e 94 e9 0a 	call	0x15d2	; 0x15d2 <xQueueGenericSend>
    2e18:	0e 94 2e 0e 	call	0x1c5c	; 0x1c5c <vTaskStartScheduler>

	/* Start the task */
	vTaskStartScheduler();
    2e1c:	80 e0       	ldi	r24, 0x00	; 0
}
    2e1e:	90 e0       	ldi	r25, 0x00	; 0
    2e20:	0f 91       	pop	r16
    2e22:	ff 90       	pop	r15
    2e24:	ef 90       	pop	r14
    2e26:	08 95       	ret

00002e28 <__udivmodsi4>:
    2e28:	a1 e2       	ldi	r26, 0x21	; 33
    2e2a:	1a 2e       	mov	r1, r26
    2e2c:	aa 1b       	sub	r26, r26
    2e2e:	bb 1b       	sub	r27, r27
    2e30:	fd 01       	movw	r30, r26
    2e32:	0d c0       	rjmp	.+26     	; 0x2e4e <__udivmodsi4_ep>

00002e34 <__udivmodsi4_loop>:
    2e34:	aa 1f       	adc	r26, r26
    2e36:	bb 1f       	adc	r27, r27
    2e38:	ee 1f       	adc	r30, r30
    2e3a:	ff 1f       	adc	r31, r31
    2e3c:	a2 17       	cp	r26, r18
    2e3e:	b3 07       	cpc	r27, r19
    2e40:	e4 07       	cpc	r30, r20
    2e42:	f5 07       	cpc	r31, r21
    2e44:	20 f0       	brcs	.+8      	; 0x2e4e <__udivmodsi4_ep>
    2e46:	a2 1b       	sub	r26, r18
    2e48:	b3 0b       	sbc	r27, r19
    2e4a:	e4 0b       	sbc	r30, r20
    2e4c:	f5 0b       	sbc	r31, r21

00002e4e <__udivmodsi4_ep>:
    2e4e:	66 1f       	adc	r22, r22
    2e50:	77 1f       	adc	r23, r23
    2e52:	88 1f       	adc	r24, r24
    2e54:	99 1f       	adc	r25, r25
    2e56:	1a 94       	dec	r1
    2e58:	69 f7       	brne	.-38     	; 0x2e34 <__udivmodsi4_loop>
    2e5a:	60 95       	com	r22
    2e5c:	70 95       	com	r23
    2e5e:	80 95       	com	r24
    2e60:	90 95       	com	r25
    2e62:	9b 01       	movw	r18, r22
    2e64:	ac 01       	movw	r20, r24
    2e66:	bd 01       	movw	r22, r26
    2e68:	cf 01       	movw	r24, r30
    2e6a:	08 95       	ret

00002e6c <__tablejump2__>:
    2e6c:	ee 0f       	add	r30, r30
    2e6e:	ff 1f       	adc	r31, r31
    2e70:	88 1f       	adc	r24, r24
    2e72:	8b bf       	out	0x3b, r24	; 59
    2e74:	07 90       	elpm	r0, Z+
    2e76:	f6 91       	elpm	r31, Z
    2e78:	e0 2d       	mov	r30, r0
    2e7a:	19 94       	eijmp

00002e7c <malloc>:
    2e7c:	0f 93       	push	r16
    2e7e:	1f 93       	push	r17
    2e80:	cf 93       	push	r28
    2e82:	df 93       	push	r29
    2e84:	82 30       	cpi	r24, 0x02	; 2
    2e86:	91 05       	cpc	r25, r1
    2e88:	10 f4       	brcc	.+4      	; 0x2e8e <malloc+0x12>
    2e8a:	82 e0       	ldi	r24, 0x02	; 2
    2e8c:	90 e0       	ldi	r25, 0x00	; 0
    2e8e:	e0 91 d7 22 	lds	r30, 0x22D7	; 0x8022d7 <__flp>
    2e92:	f0 91 d8 22 	lds	r31, 0x22D8	; 0x8022d8 <__flp+0x1>
    2e96:	20 e0       	ldi	r18, 0x00	; 0
    2e98:	30 e0       	ldi	r19, 0x00	; 0
    2e9a:	a0 e0       	ldi	r26, 0x00	; 0
    2e9c:	b0 e0       	ldi	r27, 0x00	; 0
    2e9e:	30 97       	sbiw	r30, 0x00	; 0
    2ea0:	19 f1       	breq	.+70     	; 0x2ee8 <malloc+0x6c>
    2ea2:	40 81       	ld	r20, Z
    2ea4:	51 81       	ldd	r21, Z+1	; 0x01
    2ea6:	02 81       	ldd	r16, Z+2	; 0x02
    2ea8:	13 81       	ldd	r17, Z+3	; 0x03
    2eaa:	48 17       	cp	r20, r24
    2eac:	59 07       	cpc	r21, r25
    2eae:	c8 f0       	brcs	.+50     	; 0x2ee2 <malloc+0x66>
    2eb0:	84 17       	cp	r24, r20
    2eb2:	95 07       	cpc	r25, r21
    2eb4:	69 f4       	brne	.+26     	; 0x2ed0 <malloc+0x54>
    2eb6:	10 97       	sbiw	r26, 0x00	; 0
    2eb8:	31 f0       	breq	.+12     	; 0x2ec6 <malloc+0x4a>
    2eba:	12 96       	adiw	r26, 0x02	; 2
    2ebc:	0c 93       	st	X, r16
    2ebe:	12 97       	sbiw	r26, 0x02	; 2
    2ec0:	13 96       	adiw	r26, 0x03	; 3
    2ec2:	1c 93       	st	X, r17
    2ec4:	27 c0       	rjmp	.+78     	; 0x2f14 <malloc+0x98>
    2ec6:	00 93 d7 22 	sts	0x22D7, r16	; 0x8022d7 <__flp>
    2eca:	10 93 d8 22 	sts	0x22D8, r17	; 0x8022d8 <__flp+0x1>
    2ece:	22 c0       	rjmp	.+68     	; 0x2f14 <malloc+0x98>
    2ed0:	21 15       	cp	r18, r1
    2ed2:	31 05       	cpc	r19, r1
    2ed4:	19 f0       	breq	.+6      	; 0x2edc <malloc+0x60>
    2ed6:	42 17       	cp	r20, r18
    2ed8:	53 07       	cpc	r21, r19
    2eda:	18 f4       	brcc	.+6      	; 0x2ee2 <malloc+0x66>
    2edc:	9a 01       	movw	r18, r20
    2ede:	bd 01       	movw	r22, r26
    2ee0:	ef 01       	movw	r28, r30
    2ee2:	df 01       	movw	r26, r30
    2ee4:	f8 01       	movw	r30, r16
    2ee6:	db cf       	rjmp	.-74     	; 0x2e9e <malloc+0x22>
    2ee8:	21 15       	cp	r18, r1
    2eea:	31 05       	cpc	r19, r1
    2eec:	f9 f0       	breq	.+62     	; 0x2f2c <malloc+0xb0>
    2eee:	28 1b       	sub	r18, r24
    2ef0:	39 0b       	sbc	r19, r25
    2ef2:	24 30       	cpi	r18, 0x04	; 4
    2ef4:	31 05       	cpc	r19, r1
    2ef6:	80 f4       	brcc	.+32     	; 0x2f18 <malloc+0x9c>
    2ef8:	8a 81       	ldd	r24, Y+2	; 0x02
    2efa:	9b 81       	ldd	r25, Y+3	; 0x03
    2efc:	61 15       	cp	r22, r1
    2efe:	71 05       	cpc	r23, r1
    2f00:	21 f0       	breq	.+8      	; 0x2f0a <malloc+0x8e>
    2f02:	fb 01       	movw	r30, r22
    2f04:	82 83       	std	Z+2, r24	; 0x02
    2f06:	93 83       	std	Z+3, r25	; 0x03
    2f08:	04 c0       	rjmp	.+8      	; 0x2f12 <malloc+0x96>
    2f0a:	80 93 d7 22 	sts	0x22D7, r24	; 0x8022d7 <__flp>
    2f0e:	90 93 d8 22 	sts	0x22D8, r25	; 0x8022d8 <__flp+0x1>
    2f12:	fe 01       	movw	r30, r28
    2f14:	32 96       	adiw	r30, 0x02	; 2
    2f16:	44 c0       	rjmp	.+136    	; 0x2fa0 <malloc+0x124>
    2f18:	fe 01       	movw	r30, r28
    2f1a:	e2 0f       	add	r30, r18
    2f1c:	f3 1f       	adc	r31, r19
    2f1e:	81 93       	st	Z+, r24
    2f20:	91 93       	st	Z+, r25
    2f22:	22 50       	subi	r18, 0x02	; 2
    2f24:	31 09       	sbc	r19, r1
    2f26:	28 83       	st	Y, r18
    2f28:	39 83       	std	Y+1, r19	; 0x01
    2f2a:	3a c0       	rjmp	.+116    	; 0x2fa0 <malloc+0x124>
    2f2c:	20 91 d5 22 	lds	r18, 0x22D5	; 0x8022d5 <__brkval>
    2f30:	30 91 d6 22 	lds	r19, 0x22D6	; 0x8022d6 <__brkval+0x1>
    2f34:	23 2b       	or	r18, r19
    2f36:	41 f4       	brne	.+16     	; 0x2f48 <malloc+0xcc>
    2f38:	20 91 02 20 	lds	r18, 0x2002	; 0x802002 <__malloc_heap_start>
    2f3c:	30 91 03 20 	lds	r19, 0x2003	; 0x802003 <__malloc_heap_start+0x1>
    2f40:	20 93 d5 22 	sts	0x22D5, r18	; 0x8022d5 <__brkval>
    2f44:	30 93 d6 22 	sts	0x22D6, r19	; 0x8022d6 <__brkval+0x1>
    2f48:	20 91 00 20 	lds	r18, 0x2000	; 0x802000 <__DATA_REGION_ORIGIN__>
    2f4c:	30 91 01 20 	lds	r19, 0x2001	; 0x802001 <__DATA_REGION_ORIGIN__+0x1>
    2f50:	21 15       	cp	r18, r1
    2f52:	31 05       	cpc	r19, r1
    2f54:	41 f4       	brne	.+16     	; 0x2f66 <malloc+0xea>
    2f56:	2d b7       	in	r18, 0x3d	; 61
    2f58:	3e b7       	in	r19, 0x3e	; 62
    2f5a:	40 91 04 20 	lds	r20, 0x2004	; 0x802004 <__malloc_margin>
    2f5e:	50 91 05 20 	lds	r21, 0x2005	; 0x802005 <__malloc_margin+0x1>
    2f62:	24 1b       	sub	r18, r20
    2f64:	35 0b       	sbc	r19, r21
    2f66:	e0 91 d5 22 	lds	r30, 0x22D5	; 0x8022d5 <__brkval>
    2f6a:	f0 91 d6 22 	lds	r31, 0x22D6	; 0x8022d6 <__brkval+0x1>
    2f6e:	e2 17       	cp	r30, r18
    2f70:	f3 07       	cpc	r31, r19
    2f72:	a0 f4       	brcc	.+40     	; 0x2f9c <malloc+0x120>
    2f74:	2e 1b       	sub	r18, r30
    2f76:	3f 0b       	sbc	r19, r31
    2f78:	28 17       	cp	r18, r24
    2f7a:	39 07       	cpc	r19, r25
    2f7c:	78 f0       	brcs	.+30     	; 0x2f9c <malloc+0x120>
    2f7e:	ac 01       	movw	r20, r24
    2f80:	4e 5f       	subi	r20, 0xFE	; 254
    2f82:	5f 4f       	sbci	r21, 0xFF	; 255
    2f84:	24 17       	cp	r18, r20
    2f86:	35 07       	cpc	r19, r21
    2f88:	48 f0       	brcs	.+18     	; 0x2f9c <malloc+0x120>
    2f8a:	4e 0f       	add	r20, r30
    2f8c:	5f 1f       	adc	r21, r31
    2f8e:	40 93 d5 22 	sts	0x22D5, r20	; 0x8022d5 <__brkval>
    2f92:	50 93 d6 22 	sts	0x22D6, r21	; 0x8022d6 <__brkval+0x1>
    2f96:	81 93       	st	Z+, r24
    2f98:	91 93       	st	Z+, r25
    2f9a:	02 c0       	rjmp	.+4      	; 0x2fa0 <malloc+0x124>
    2f9c:	e0 e0       	ldi	r30, 0x00	; 0
    2f9e:	f0 e0       	ldi	r31, 0x00	; 0
    2fa0:	cf 01       	movw	r24, r30
    2fa2:	df 91       	pop	r29
    2fa4:	cf 91       	pop	r28
    2fa6:	1f 91       	pop	r17
    2fa8:	0f 91       	pop	r16
    2faa:	08 95       	ret

00002fac <free>:
    2fac:	cf 93       	push	r28
    2fae:	df 93       	push	r29
    2fb0:	00 97       	sbiw	r24, 0x00	; 0
    2fb2:	09 f4       	brne	.+2      	; 0x2fb6 <free+0xa>
    2fb4:	81 c0       	rjmp	.+258    	; 0x30b8 <free+0x10c>
    2fb6:	fc 01       	movw	r30, r24
    2fb8:	32 97       	sbiw	r30, 0x02	; 2
    2fba:	12 82       	std	Z+2, r1	; 0x02
    2fbc:	13 82       	std	Z+3, r1	; 0x03
    2fbe:	a0 91 d7 22 	lds	r26, 0x22D7	; 0x8022d7 <__flp>
    2fc2:	b0 91 d8 22 	lds	r27, 0x22D8	; 0x8022d8 <__flp+0x1>
    2fc6:	10 97       	sbiw	r26, 0x00	; 0
    2fc8:	81 f4       	brne	.+32     	; 0x2fea <free+0x3e>
    2fca:	20 81       	ld	r18, Z
    2fcc:	31 81       	ldd	r19, Z+1	; 0x01
    2fce:	82 0f       	add	r24, r18
    2fd0:	93 1f       	adc	r25, r19
    2fd2:	20 91 d5 22 	lds	r18, 0x22D5	; 0x8022d5 <__brkval>
    2fd6:	30 91 d6 22 	lds	r19, 0x22D6	; 0x8022d6 <__brkval+0x1>
    2fda:	28 17       	cp	r18, r24
    2fdc:	39 07       	cpc	r19, r25
    2fde:	51 f5       	brne	.+84     	; 0x3034 <free+0x88>
    2fe0:	e0 93 d5 22 	sts	0x22D5, r30	; 0x8022d5 <__brkval>
    2fe4:	f0 93 d6 22 	sts	0x22D6, r31	; 0x8022d6 <__brkval+0x1>
    2fe8:	67 c0       	rjmp	.+206    	; 0x30b8 <free+0x10c>
    2fea:	ed 01       	movw	r28, r26
    2fec:	20 e0       	ldi	r18, 0x00	; 0
    2fee:	30 e0       	ldi	r19, 0x00	; 0
    2ff0:	ce 17       	cp	r28, r30
    2ff2:	df 07       	cpc	r29, r31
    2ff4:	40 f4       	brcc	.+16     	; 0x3006 <free+0x5a>
    2ff6:	4a 81       	ldd	r20, Y+2	; 0x02
    2ff8:	5b 81       	ldd	r21, Y+3	; 0x03
    2ffa:	9e 01       	movw	r18, r28
    2ffc:	41 15       	cp	r20, r1
    2ffe:	51 05       	cpc	r21, r1
    3000:	f1 f0       	breq	.+60     	; 0x303e <free+0x92>
    3002:	ea 01       	movw	r28, r20
    3004:	f5 cf       	rjmp	.-22     	; 0x2ff0 <free+0x44>
    3006:	c2 83       	std	Z+2, r28	; 0x02
    3008:	d3 83       	std	Z+3, r29	; 0x03
    300a:	40 81       	ld	r20, Z
    300c:	51 81       	ldd	r21, Z+1	; 0x01
    300e:	84 0f       	add	r24, r20
    3010:	95 1f       	adc	r25, r21
    3012:	c8 17       	cp	r28, r24
    3014:	d9 07       	cpc	r29, r25
    3016:	59 f4       	brne	.+22     	; 0x302e <free+0x82>
    3018:	88 81       	ld	r24, Y
    301a:	99 81       	ldd	r25, Y+1	; 0x01
    301c:	84 0f       	add	r24, r20
    301e:	95 1f       	adc	r25, r21
    3020:	02 96       	adiw	r24, 0x02	; 2
    3022:	80 83       	st	Z, r24
    3024:	91 83       	std	Z+1, r25	; 0x01
    3026:	8a 81       	ldd	r24, Y+2	; 0x02
    3028:	9b 81       	ldd	r25, Y+3	; 0x03
    302a:	82 83       	std	Z+2, r24	; 0x02
    302c:	93 83       	std	Z+3, r25	; 0x03
    302e:	21 15       	cp	r18, r1
    3030:	31 05       	cpc	r19, r1
    3032:	29 f4       	brne	.+10     	; 0x303e <free+0x92>
    3034:	e0 93 d7 22 	sts	0x22D7, r30	; 0x8022d7 <__flp>
    3038:	f0 93 d8 22 	sts	0x22D8, r31	; 0x8022d8 <__flp+0x1>
    303c:	3d c0       	rjmp	.+122    	; 0x30b8 <free+0x10c>
    303e:	e9 01       	movw	r28, r18
    3040:	ea 83       	std	Y+2, r30	; 0x02
    3042:	fb 83       	std	Y+3, r31	; 0x03
    3044:	49 91       	ld	r20, Y+
    3046:	59 91       	ld	r21, Y+
    3048:	c4 0f       	add	r28, r20
    304a:	d5 1f       	adc	r29, r21
    304c:	ec 17       	cp	r30, r28
    304e:	fd 07       	cpc	r31, r29
    3050:	61 f4       	brne	.+24     	; 0x306a <free+0xbe>
    3052:	80 81       	ld	r24, Z
    3054:	91 81       	ldd	r25, Z+1	; 0x01
    3056:	84 0f       	add	r24, r20
    3058:	95 1f       	adc	r25, r21
    305a:	02 96       	adiw	r24, 0x02	; 2
    305c:	e9 01       	movw	r28, r18
    305e:	88 83       	st	Y, r24
    3060:	99 83       	std	Y+1, r25	; 0x01
    3062:	82 81       	ldd	r24, Z+2	; 0x02
    3064:	93 81       	ldd	r25, Z+3	; 0x03
    3066:	8a 83       	std	Y+2, r24	; 0x02
    3068:	9b 83       	std	Y+3, r25	; 0x03
    306a:	e0 e0       	ldi	r30, 0x00	; 0
    306c:	f0 e0       	ldi	r31, 0x00	; 0
    306e:	12 96       	adiw	r26, 0x02	; 2
    3070:	8d 91       	ld	r24, X+
    3072:	9c 91       	ld	r25, X
    3074:	13 97       	sbiw	r26, 0x03	; 3
    3076:	00 97       	sbiw	r24, 0x00	; 0
    3078:	19 f0       	breq	.+6      	; 0x3080 <free+0xd4>
    307a:	fd 01       	movw	r30, r26
    307c:	dc 01       	movw	r26, r24
    307e:	f7 cf       	rjmp	.-18     	; 0x306e <free+0xc2>
    3080:	8d 91       	ld	r24, X+
    3082:	9c 91       	ld	r25, X
    3084:	11 97       	sbiw	r26, 0x01	; 1
    3086:	9d 01       	movw	r18, r26
    3088:	2e 5f       	subi	r18, 0xFE	; 254
    308a:	3f 4f       	sbci	r19, 0xFF	; 255
    308c:	82 0f       	add	r24, r18
    308e:	93 1f       	adc	r25, r19
    3090:	20 91 d5 22 	lds	r18, 0x22D5	; 0x8022d5 <__brkval>
    3094:	30 91 d6 22 	lds	r19, 0x22D6	; 0x8022d6 <__brkval+0x1>
    3098:	28 17       	cp	r18, r24
    309a:	39 07       	cpc	r19, r25
    309c:	69 f4       	brne	.+26     	; 0x30b8 <free+0x10c>
    309e:	30 97       	sbiw	r30, 0x00	; 0
    30a0:	29 f4       	brne	.+10     	; 0x30ac <free+0x100>
    30a2:	10 92 d7 22 	sts	0x22D7, r1	; 0x8022d7 <__flp>
    30a6:	10 92 d8 22 	sts	0x22D8, r1	; 0x8022d8 <__flp+0x1>
    30aa:	02 c0       	rjmp	.+4      	; 0x30b0 <free+0x104>
    30ac:	12 82       	std	Z+2, r1	; 0x02
    30ae:	13 82       	std	Z+3, r1	; 0x03
    30b0:	a0 93 d5 22 	sts	0x22D5, r26	; 0x8022d5 <__brkval>
    30b4:	b0 93 d6 22 	sts	0x22D6, r27	; 0x8022d6 <__brkval+0x1>
    30b8:	df 91       	pop	r29
    30ba:	cf 91       	pop	r28
    30bc:	08 95       	ret

000030be <memcpy>:
    30be:	fb 01       	movw	r30, r22
    30c0:	dc 01       	movw	r26, r24
    30c2:	02 c0       	rjmp	.+4      	; 0x30c8 <memcpy+0xa>
    30c4:	01 90       	ld	r0, Z+
    30c6:	0d 92       	st	X+, r0
    30c8:	41 50       	subi	r20, 0x01	; 1
    30ca:	50 40       	sbci	r21, 0x00	; 0
    30cc:	d8 f7       	brcc	.-10     	; 0x30c4 <memcpy+0x6>
    30ce:	08 95       	ret

000030d0 <snprintf>:
    30d0:	0f 93       	push	r16
    30d2:	1f 93       	push	r17
    30d4:	cf 93       	push	r28
    30d6:	df 93       	push	r29
    30d8:	cd b7       	in	r28, 0x3d	; 61
    30da:	de b7       	in	r29, 0x3e	; 62
    30dc:	2e 97       	sbiw	r28, 0x0e	; 14
    30de:	cd bf       	out	0x3d, r28	; 61
    30e0:	de bf       	out	0x3e, r29	; 62
    30e2:	0e 89       	ldd	r16, Y+22	; 0x16
    30e4:	1f 89       	ldd	r17, Y+23	; 0x17
    30e6:	88 8d       	ldd	r24, Y+24	; 0x18
    30e8:	99 8d       	ldd	r25, Y+25	; 0x19
    30ea:	26 e0       	ldi	r18, 0x06	; 6
    30ec:	2c 83       	std	Y+4, r18	; 0x04
    30ee:	09 83       	std	Y+1, r16	; 0x01
    30f0:	1a 83       	std	Y+2, r17	; 0x02
    30f2:	97 ff       	sbrs	r25, 7
    30f4:	02 c0       	rjmp	.+4      	; 0x30fa <snprintf+0x2a>
    30f6:	80 e0       	ldi	r24, 0x00	; 0
    30f8:	90 e8       	ldi	r25, 0x80	; 128
    30fa:	01 97       	sbiw	r24, 0x01	; 1
    30fc:	8d 83       	std	Y+5, r24	; 0x05
    30fe:	9e 83       	std	Y+6, r25	; 0x06
    3100:	ae 01       	movw	r20, r28
    3102:	44 5e       	subi	r20, 0xE4	; 228
    3104:	5f 4f       	sbci	r21, 0xFF	; 255
    3106:	6a 8d       	ldd	r22, Y+26	; 0x1a
    3108:	7b 8d       	ldd	r23, Y+27	; 0x1b
    310a:	ce 01       	movw	r24, r28
    310c:	01 96       	adiw	r24, 0x01	; 1
    310e:	16 d0       	rcall	.+44     	; 0x313c <vfprintf>
    3110:	4d 81       	ldd	r20, Y+5	; 0x05
    3112:	5e 81       	ldd	r21, Y+6	; 0x06
    3114:	57 fd       	sbrc	r21, 7
    3116:	0a c0       	rjmp	.+20     	; 0x312c <snprintf+0x5c>
    3118:	2f 81       	ldd	r18, Y+7	; 0x07
    311a:	38 85       	ldd	r19, Y+8	; 0x08
    311c:	42 17       	cp	r20, r18
    311e:	53 07       	cpc	r21, r19
    3120:	0c f4       	brge	.+2      	; 0x3124 <snprintf+0x54>
    3122:	9a 01       	movw	r18, r20
    3124:	f8 01       	movw	r30, r16
    3126:	e2 0f       	add	r30, r18
    3128:	f3 1f       	adc	r31, r19
    312a:	10 82       	st	Z, r1
    312c:	2e 96       	adiw	r28, 0x0e	; 14
    312e:	cd bf       	out	0x3d, r28	; 61
    3130:	de bf       	out	0x3e, r29	; 62
    3132:	df 91       	pop	r29
    3134:	cf 91       	pop	r28
    3136:	1f 91       	pop	r17
    3138:	0f 91       	pop	r16
    313a:	08 95       	ret

0000313c <vfprintf>:
    313c:	2f 92       	push	r2
    313e:	3f 92       	push	r3
    3140:	4f 92       	push	r4
    3142:	5f 92       	push	r5
    3144:	6f 92       	push	r6
    3146:	7f 92       	push	r7
    3148:	8f 92       	push	r8
    314a:	9f 92       	push	r9
    314c:	af 92       	push	r10
    314e:	bf 92       	push	r11
    3150:	cf 92       	push	r12
    3152:	df 92       	push	r13
    3154:	ef 92       	push	r14
    3156:	ff 92       	push	r15
    3158:	0f 93       	push	r16
    315a:	1f 93       	push	r17
    315c:	cf 93       	push	r28
    315e:	df 93       	push	r29
    3160:	cd b7       	in	r28, 0x3d	; 61
    3162:	de b7       	in	r29, 0x3e	; 62
    3164:	2b 97       	sbiw	r28, 0x0b	; 11
    3166:	cd bf       	out	0x3d, r28	; 61
    3168:	de bf       	out	0x3e, r29	; 62
    316a:	6c 01       	movw	r12, r24
    316c:	7b 01       	movw	r14, r22
    316e:	8a 01       	movw	r16, r20
    3170:	fc 01       	movw	r30, r24
    3172:	16 82       	std	Z+6, r1	; 0x06
    3174:	17 82       	std	Z+7, r1	; 0x07
    3176:	83 81       	ldd	r24, Z+3	; 0x03
    3178:	81 ff       	sbrs	r24, 1
    317a:	bf c1       	rjmp	.+894    	; 0x34fa <vfprintf+0x3be>
    317c:	ce 01       	movw	r24, r28
    317e:	01 96       	adiw	r24, 0x01	; 1
    3180:	3c 01       	movw	r6, r24
    3182:	f6 01       	movw	r30, r12
    3184:	93 81       	ldd	r25, Z+3	; 0x03
    3186:	f7 01       	movw	r30, r14
    3188:	93 fd       	sbrc	r25, 3
    318a:	85 91       	lpm	r24, Z+
    318c:	93 ff       	sbrs	r25, 3
    318e:	81 91       	ld	r24, Z+
    3190:	7f 01       	movw	r14, r30
    3192:	88 23       	and	r24, r24
    3194:	09 f4       	brne	.+2      	; 0x3198 <vfprintf+0x5c>
    3196:	ad c1       	rjmp	.+858    	; 0x34f2 <vfprintf+0x3b6>
    3198:	85 32       	cpi	r24, 0x25	; 37
    319a:	39 f4       	brne	.+14     	; 0x31aa <vfprintf+0x6e>
    319c:	93 fd       	sbrc	r25, 3
    319e:	85 91       	lpm	r24, Z+
    31a0:	93 ff       	sbrs	r25, 3
    31a2:	81 91       	ld	r24, Z+
    31a4:	7f 01       	movw	r14, r30
    31a6:	85 32       	cpi	r24, 0x25	; 37
    31a8:	21 f4       	brne	.+8      	; 0x31b2 <vfprintf+0x76>
    31aa:	b6 01       	movw	r22, r12
    31ac:	90 e0       	ldi	r25, 0x00	; 0
    31ae:	d3 d1       	rcall	.+934    	; 0x3556 <fputc>
    31b0:	e8 cf       	rjmp	.-48     	; 0x3182 <vfprintf+0x46>
    31b2:	91 2c       	mov	r9, r1
    31b4:	21 2c       	mov	r2, r1
    31b6:	31 2c       	mov	r3, r1
    31b8:	ff e1       	ldi	r31, 0x1F	; 31
    31ba:	f3 15       	cp	r31, r3
    31bc:	d8 f0       	brcs	.+54     	; 0x31f4 <vfprintf+0xb8>
    31be:	8b 32       	cpi	r24, 0x2B	; 43
    31c0:	79 f0       	breq	.+30     	; 0x31e0 <vfprintf+0xa4>
    31c2:	38 f4       	brcc	.+14     	; 0x31d2 <vfprintf+0x96>
    31c4:	80 32       	cpi	r24, 0x20	; 32
    31c6:	79 f0       	breq	.+30     	; 0x31e6 <vfprintf+0xaa>
    31c8:	83 32       	cpi	r24, 0x23	; 35
    31ca:	a1 f4       	brne	.+40     	; 0x31f4 <vfprintf+0xb8>
    31cc:	23 2d       	mov	r18, r3
    31ce:	20 61       	ori	r18, 0x10	; 16
    31d0:	1d c0       	rjmp	.+58     	; 0x320c <vfprintf+0xd0>
    31d2:	8d 32       	cpi	r24, 0x2D	; 45
    31d4:	61 f0       	breq	.+24     	; 0x31ee <vfprintf+0xb2>
    31d6:	80 33       	cpi	r24, 0x30	; 48
    31d8:	69 f4       	brne	.+26     	; 0x31f4 <vfprintf+0xb8>
    31da:	23 2d       	mov	r18, r3
    31dc:	21 60       	ori	r18, 0x01	; 1
    31de:	16 c0       	rjmp	.+44     	; 0x320c <vfprintf+0xd0>
    31e0:	83 2d       	mov	r24, r3
    31e2:	82 60       	ori	r24, 0x02	; 2
    31e4:	38 2e       	mov	r3, r24
    31e6:	e3 2d       	mov	r30, r3
    31e8:	e4 60       	ori	r30, 0x04	; 4
    31ea:	3e 2e       	mov	r3, r30
    31ec:	2a c0       	rjmp	.+84     	; 0x3242 <vfprintf+0x106>
    31ee:	f3 2d       	mov	r31, r3
    31f0:	f8 60       	ori	r31, 0x08	; 8
    31f2:	1d c0       	rjmp	.+58     	; 0x322e <vfprintf+0xf2>
    31f4:	37 fc       	sbrc	r3, 7
    31f6:	2d c0       	rjmp	.+90     	; 0x3252 <vfprintf+0x116>
    31f8:	20 ed       	ldi	r18, 0xD0	; 208
    31fa:	28 0f       	add	r18, r24
    31fc:	2a 30       	cpi	r18, 0x0A	; 10
    31fe:	40 f0       	brcs	.+16     	; 0x3210 <vfprintf+0xd4>
    3200:	8e 32       	cpi	r24, 0x2E	; 46
    3202:	b9 f4       	brne	.+46     	; 0x3232 <vfprintf+0xf6>
    3204:	36 fc       	sbrc	r3, 6
    3206:	75 c1       	rjmp	.+746    	; 0x34f2 <vfprintf+0x3b6>
    3208:	23 2d       	mov	r18, r3
    320a:	20 64       	ori	r18, 0x40	; 64
    320c:	32 2e       	mov	r3, r18
    320e:	19 c0       	rjmp	.+50     	; 0x3242 <vfprintf+0x106>
    3210:	36 fe       	sbrs	r3, 6
    3212:	06 c0       	rjmp	.+12     	; 0x3220 <vfprintf+0xe4>
    3214:	8a e0       	ldi	r24, 0x0A	; 10
    3216:	98 9e       	mul	r9, r24
    3218:	20 0d       	add	r18, r0
    321a:	11 24       	eor	r1, r1
    321c:	92 2e       	mov	r9, r18
    321e:	11 c0       	rjmp	.+34     	; 0x3242 <vfprintf+0x106>
    3220:	ea e0       	ldi	r30, 0x0A	; 10
    3222:	2e 9e       	mul	r2, r30
    3224:	20 0d       	add	r18, r0
    3226:	11 24       	eor	r1, r1
    3228:	22 2e       	mov	r2, r18
    322a:	f3 2d       	mov	r31, r3
    322c:	f0 62       	ori	r31, 0x20	; 32
    322e:	3f 2e       	mov	r3, r31
    3230:	08 c0       	rjmp	.+16     	; 0x3242 <vfprintf+0x106>
    3232:	8c 36       	cpi	r24, 0x6C	; 108
    3234:	21 f4       	brne	.+8      	; 0x323e <vfprintf+0x102>
    3236:	83 2d       	mov	r24, r3
    3238:	80 68       	ori	r24, 0x80	; 128
    323a:	38 2e       	mov	r3, r24
    323c:	02 c0       	rjmp	.+4      	; 0x3242 <vfprintf+0x106>
    323e:	88 36       	cpi	r24, 0x68	; 104
    3240:	41 f4       	brne	.+16     	; 0x3252 <vfprintf+0x116>
    3242:	f7 01       	movw	r30, r14
    3244:	93 fd       	sbrc	r25, 3
    3246:	85 91       	lpm	r24, Z+
    3248:	93 ff       	sbrs	r25, 3
    324a:	81 91       	ld	r24, Z+
    324c:	7f 01       	movw	r14, r30
    324e:	81 11       	cpse	r24, r1
    3250:	b3 cf       	rjmp	.-154    	; 0x31b8 <vfprintf+0x7c>
    3252:	98 2f       	mov	r25, r24
    3254:	9f 7d       	andi	r25, 0xDF	; 223
    3256:	95 54       	subi	r25, 0x45	; 69
    3258:	93 30       	cpi	r25, 0x03	; 3
    325a:	28 f4       	brcc	.+10     	; 0x3266 <vfprintf+0x12a>
    325c:	0c 5f       	subi	r16, 0xFC	; 252
    325e:	1f 4f       	sbci	r17, 0xFF	; 255
    3260:	9f e3       	ldi	r25, 0x3F	; 63
    3262:	99 83       	std	Y+1, r25	; 0x01
    3264:	0d c0       	rjmp	.+26     	; 0x3280 <vfprintf+0x144>
    3266:	83 36       	cpi	r24, 0x63	; 99
    3268:	31 f0       	breq	.+12     	; 0x3276 <vfprintf+0x13a>
    326a:	83 37       	cpi	r24, 0x73	; 115
    326c:	71 f0       	breq	.+28     	; 0x328a <vfprintf+0x14e>
    326e:	83 35       	cpi	r24, 0x53	; 83
    3270:	09 f0       	breq	.+2      	; 0x3274 <vfprintf+0x138>
    3272:	55 c0       	rjmp	.+170    	; 0x331e <vfprintf+0x1e2>
    3274:	20 c0       	rjmp	.+64     	; 0x32b6 <vfprintf+0x17a>
    3276:	f8 01       	movw	r30, r16
    3278:	80 81       	ld	r24, Z
    327a:	89 83       	std	Y+1, r24	; 0x01
    327c:	0e 5f       	subi	r16, 0xFE	; 254
    327e:	1f 4f       	sbci	r17, 0xFF	; 255
    3280:	88 24       	eor	r8, r8
    3282:	83 94       	inc	r8
    3284:	91 2c       	mov	r9, r1
    3286:	53 01       	movw	r10, r6
    3288:	12 c0       	rjmp	.+36     	; 0x32ae <vfprintf+0x172>
    328a:	28 01       	movw	r4, r16
    328c:	f2 e0       	ldi	r31, 0x02	; 2
    328e:	4f 0e       	add	r4, r31
    3290:	51 1c       	adc	r5, r1
    3292:	f8 01       	movw	r30, r16
    3294:	a0 80       	ld	r10, Z
    3296:	b1 80       	ldd	r11, Z+1	; 0x01
    3298:	36 fe       	sbrs	r3, 6
    329a:	03 c0       	rjmp	.+6      	; 0x32a2 <vfprintf+0x166>
    329c:	69 2d       	mov	r22, r9
    329e:	70 e0       	ldi	r23, 0x00	; 0
    32a0:	02 c0       	rjmp	.+4      	; 0x32a6 <vfprintf+0x16a>
    32a2:	6f ef       	ldi	r22, 0xFF	; 255
    32a4:	7f ef       	ldi	r23, 0xFF	; 255
    32a6:	c5 01       	movw	r24, r10
    32a8:	4b d1       	rcall	.+662    	; 0x3540 <strnlen>
    32aa:	4c 01       	movw	r8, r24
    32ac:	82 01       	movw	r16, r4
    32ae:	f3 2d       	mov	r31, r3
    32b0:	ff 77       	andi	r31, 0x7F	; 127
    32b2:	3f 2e       	mov	r3, r31
    32b4:	15 c0       	rjmp	.+42     	; 0x32e0 <vfprintf+0x1a4>
    32b6:	28 01       	movw	r4, r16
    32b8:	22 e0       	ldi	r18, 0x02	; 2
    32ba:	42 0e       	add	r4, r18
    32bc:	51 1c       	adc	r5, r1
    32be:	f8 01       	movw	r30, r16
    32c0:	a0 80       	ld	r10, Z
    32c2:	b1 80       	ldd	r11, Z+1	; 0x01
    32c4:	36 fe       	sbrs	r3, 6
    32c6:	03 c0       	rjmp	.+6      	; 0x32ce <vfprintf+0x192>
    32c8:	69 2d       	mov	r22, r9
    32ca:	70 e0       	ldi	r23, 0x00	; 0
    32cc:	02 c0       	rjmp	.+4      	; 0x32d2 <vfprintf+0x196>
    32ce:	6f ef       	ldi	r22, 0xFF	; 255
    32d0:	7f ef       	ldi	r23, 0xFF	; 255
    32d2:	c5 01       	movw	r24, r10
    32d4:	2a d1       	rcall	.+596    	; 0x352a <strnlen_P>
    32d6:	4c 01       	movw	r8, r24
    32d8:	f3 2d       	mov	r31, r3
    32da:	f0 68       	ori	r31, 0x80	; 128
    32dc:	3f 2e       	mov	r3, r31
    32de:	82 01       	movw	r16, r4
    32e0:	33 fc       	sbrc	r3, 3
    32e2:	19 c0       	rjmp	.+50     	; 0x3316 <vfprintf+0x1da>
    32e4:	82 2d       	mov	r24, r2
    32e6:	90 e0       	ldi	r25, 0x00	; 0
    32e8:	88 16       	cp	r8, r24
    32ea:	99 06       	cpc	r9, r25
    32ec:	a0 f4       	brcc	.+40     	; 0x3316 <vfprintf+0x1da>
    32ee:	b6 01       	movw	r22, r12
    32f0:	80 e2       	ldi	r24, 0x20	; 32
    32f2:	90 e0       	ldi	r25, 0x00	; 0
    32f4:	30 d1       	rcall	.+608    	; 0x3556 <fputc>
    32f6:	2a 94       	dec	r2
    32f8:	f5 cf       	rjmp	.-22     	; 0x32e4 <vfprintf+0x1a8>
    32fa:	f5 01       	movw	r30, r10
    32fc:	37 fc       	sbrc	r3, 7
    32fe:	85 91       	lpm	r24, Z+
    3300:	37 fe       	sbrs	r3, 7
    3302:	81 91       	ld	r24, Z+
    3304:	5f 01       	movw	r10, r30
    3306:	b6 01       	movw	r22, r12
    3308:	90 e0       	ldi	r25, 0x00	; 0
    330a:	25 d1       	rcall	.+586    	; 0x3556 <fputc>
    330c:	21 10       	cpse	r2, r1
    330e:	2a 94       	dec	r2
    3310:	21 e0       	ldi	r18, 0x01	; 1
    3312:	82 1a       	sub	r8, r18
    3314:	91 08       	sbc	r9, r1
    3316:	81 14       	cp	r8, r1
    3318:	91 04       	cpc	r9, r1
    331a:	79 f7       	brne	.-34     	; 0x32fa <vfprintf+0x1be>
    331c:	e1 c0       	rjmp	.+450    	; 0x34e0 <vfprintf+0x3a4>
    331e:	84 36       	cpi	r24, 0x64	; 100
    3320:	11 f0       	breq	.+4      	; 0x3326 <vfprintf+0x1ea>
    3322:	89 36       	cpi	r24, 0x69	; 105
    3324:	39 f5       	brne	.+78     	; 0x3374 <vfprintf+0x238>
    3326:	f8 01       	movw	r30, r16
    3328:	37 fe       	sbrs	r3, 7
    332a:	07 c0       	rjmp	.+14     	; 0x333a <vfprintf+0x1fe>
    332c:	60 81       	ld	r22, Z
    332e:	71 81       	ldd	r23, Z+1	; 0x01
    3330:	82 81       	ldd	r24, Z+2	; 0x02
    3332:	93 81       	ldd	r25, Z+3	; 0x03
    3334:	0c 5f       	subi	r16, 0xFC	; 252
    3336:	1f 4f       	sbci	r17, 0xFF	; 255
    3338:	08 c0       	rjmp	.+16     	; 0x334a <vfprintf+0x20e>
    333a:	60 81       	ld	r22, Z
    333c:	71 81       	ldd	r23, Z+1	; 0x01
    333e:	07 2e       	mov	r0, r23
    3340:	00 0c       	add	r0, r0
    3342:	88 0b       	sbc	r24, r24
    3344:	99 0b       	sbc	r25, r25
    3346:	0e 5f       	subi	r16, 0xFE	; 254
    3348:	1f 4f       	sbci	r17, 0xFF	; 255
    334a:	f3 2d       	mov	r31, r3
    334c:	ff 76       	andi	r31, 0x6F	; 111
    334e:	3f 2e       	mov	r3, r31
    3350:	97 ff       	sbrs	r25, 7
    3352:	09 c0       	rjmp	.+18     	; 0x3366 <vfprintf+0x22a>
    3354:	90 95       	com	r25
    3356:	80 95       	com	r24
    3358:	70 95       	com	r23
    335a:	61 95       	neg	r22
    335c:	7f 4f       	sbci	r23, 0xFF	; 255
    335e:	8f 4f       	sbci	r24, 0xFF	; 255
    3360:	9f 4f       	sbci	r25, 0xFF	; 255
    3362:	f0 68       	ori	r31, 0x80	; 128
    3364:	3f 2e       	mov	r3, r31
    3366:	2a e0       	ldi	r18, 0x0A	; 10
    3368:	30 e0       	ldi	r19, 0x00	; 0
    336a:	a3 01       	movw	r20, r6
    336c:	30 d1       	rcall	.+608    	; 0x35ce <__ultoa_invert>
    336e:	88 2e       	mov	r8, r24
    3370:	86 18       	sub	r8, r6
    3372:	44 c0       	rjmp	.+136    	; 0x33fc <vfprintf+0x2c0>
    3374:	85 37       	cpi	r24, 0x75	; 117
    3376:	31 f4       	brne	.+12     	; 0x3384 <vfprintf+0x248>
    3378:	23 2d       	mov	r18, r3
    337a:	2f 7e       	andi	r18, 0xEF	; 239
    337c:	b2 2e       	mov	r11, r18
    337e:	2a e0       	ldi	r18, 0x0A	; 10
    3380:	30 e0       	ldi	r19, 0x00	; 0
    3382:	25 c0       	rjmp	.+74     	; 0x33ce <vfprintf+0x292>
    3384:	93 2d       	mov	r25, r3
    3386:	99 7f       	andi	r25, 0xF9	; 249
    3388:	b9 2e       	mov	r11, r25
    338a:	8f 36       	cpi	r24, 0x6F	; 111
    338c:	c1 f0       	breq	.+48     	; 0x33be <vfprintf+0x282>
    338e:	18 f4       	brcc	.+6      	; 0x3396 <vfprintf+0x25a>
    3390:	88 35       	cpi	r24, 0x58	; 88
    3392:	79 f0       	breq	.+30     	; 0x33b2 <vfprintf+0x276>
    3394:	ae c0       	rjmp	.+348    	; 0x34f2 <vfprintf+0x3b6>
    3396:	80 37       	cpi	r24, 0x70	; 112
    3398:	19 f0       	breq	.+6      	; 0x33a0 <vfprintf+0x264>
    339a:	88 37       	cpi	r24, 0x78	; 120
    339c:	21 f0       	breq	.+8      	; 0x33a6 <vfprintf+0x26a>
    339e:	a9 c0       	rjmp	.+338    	; 0x34f2 <vfprintf+0x3b6>
    33a0:	e9 2f       	mov	r30, r25
    33a2:	e0 61       	ori	r30, 0x10	; 16
    33a4:	be 2e       	mov	r11, r30
    33a6:	b4 fe       	sbrs	r11, 4
    33a8:	0d c0       	rjmp	.+26     	; 0x33c4 <vfprintf+0x288>
    33aa:	fb 2d       	mov	r31, r11
    33ac:	f4 60       	ori	r31, 0x04	; 4
    33ae:	bf 2e       	mov	r11, r31
    33b0:	09 c0       	rjmp	.+18     	; 0x33c4 <vfprintf+0x288>
    33b2:	34 fe       	sbrs	r3, 4
    33b4:	0a c0       	rjmp	.+20     	; 0x33ca <vfprintf+0x28e>
    33b6:	29 2f       	mov	r18, r25
    33b8:	26 60       	ori	r18, 0x06	; 6
    33ba:	b2 2e       	mov	r11, r18
    33bc:	06 c0       	rjmp	.+12     	; 0x33ca <vfprintf+0x28e>
    33be:	28 e0       	ldi	r18, 0x08	; 8
    33c0:	30 e0       	ldi	r19, 0x00	; 0
    33c2:	05 c0       	rjmp	.+10     	; 0x33ce <vfprintf+0x292>
    33c4:	20 e1       	ldi	r18, 0x10	; 16
    33c6:	30 e0       	ldi	r19, 0x00	; 0
    33c8:	02 c0       	rjmp	.+4      	; 0x33ce <vfprintf+0x292>
    33ca:	20 e1       	ldi	r18, 0x10	; 16
    33cc:	32 e0       	ldi	r19, 0x02	; 2
    33ce:	f8 01       	movw	r30, r16
    33d0:	b7 fe       	sbrs	r11, 7
    33d2:	07 c0       	rjmp	.+14     	; 0x33e2 <vfprintf+0x2a6>
    33d4:	60 81       	ld	r22, Z
    33d6:	71 81       	ldd	r23, Z+1	; 0x01
    33d8:	82 81       	ldd	r24, Z+2	; 0x02
    33da:	93 81       	ldd	r25, Z+3	; 0x03
    33dc:	0c 5f       	subi	r16, 0xFC	; 252
    33de:	1f 4f       	sbci	r17, 0xFF	; 255
    33e0:	06 c0       	rjmp	.+12     	; 0x33ee <vfprintf+0x2b2>
    33e2:	60 81       	ld	r22, Z
    33e4:	71 81       	ldd	r23, Z+1	; 0x01
    33e6:	80 e0       	ldi	r24, 0x00	; 0
    33e8:	90 e0       	ldi	r25, 0x00	; 0
    33ea:	0e 5f       	subi	r16, 0xFE	; 254
    33ec:	1f 4f       	sbci	r17, 0xFF	; 255
    33ee:	a3 01       	movw	r20, r6
    33f0:	ee d0       	rcall	.+476    	; 0x35ce <__ultoa_invert>
    33f2:	88 2e       	mov	r8, r24
    33f4:	86 18       	sub	r8, r6
    33f6:	fb 2d       	mov	r31, r11
    33f8:	ff 77       	andi	r31, 0x7F	; 127
    33fa:	3f 2e       	mov	r3, r31
    33fc:	36 fe       	sbrs	r3, 6
    33fe:	0d c0       	rjmp	.+26     	; 0x341a <vfprintf+0x2de>
    3400:	23 2d       	mov	r18, r3
    3402:	2e 7f       	andi	r18, 0xFE	; 254
    3404:	a2 2e       	mov	r10, r18
    3406:	89 14       	cp	r8, r9
    3408:	58 f4       	brcc	.+22     	; 0x3420 <vfprintf+0x2e4>
    340a:	34 fe       	sbrs	r3, 4
    340c:	0b c0       	rjmp	.+22     	; 0x3424 <vfprintf+0x2e8>
    340e:	32 fc       	sbrc	r3, 2
    3410:	09 c0       	rjmp	.+18     	; 0x3424 <vfprintf+0x2e8>
    3412:	83 2d       	mov	r24, r3
    3414:	8e 7e       	andi	r24, 0xEE	; 238
    3416:	a8 2e       	mov	r10, r24
    3418:	05 c0       	rjmp	.+10     	; 0x3424 <vfprintf+0x2e8>
    341a:	b8 2c       	mov	r11, r8
    341c:	a3 2c       	mov	r10, r3
    341e:	03 c0       	rjmp	.+6      	; 0x3426 <vfprintf+0x2ea>
    3420:	b8 2c       	mov	r11, r8
    3422:	01 c0       	rjmp	.+2      	; 0x3426 <vfprintf+0x2ea>
    3424:	b9 2c       	mov	r11, r9
    3426:	a4 fe       	sbrs	r10, 4
    3428:	0f c0       	rjmp	.+30     	; 0x3448 <vfprintf+0x30c>
    342a:	fe 01       	movw	r30, r28
    342c:	e8 0d       	add	r30, r8
    342e:	f1 1d       	adc	r31, r1
    3430:	80 81       	ld	r24, Z
    3432:	80 33       	cpi	r24, 0x30	; 48
    3434:	21 f4       	brne	.+8      	; 0x343e <vfprintf+0x302>
    3436:	9a 2d       	mov	r25, r10
    3438:	99 7e       	andi	r25, 0xE9	; 233
    343a:	a9 2e       	mov	r10, r25
    343c:	09 c0       	rjmp	.+18     	; 0x3450 <vfprintf+0x314>
    343e:	a2 fe       	sbrs	r10, 2
    3440:	06 c0       	rjmp	.+12     	; 0x344e <vfprintf+0x312>
    3442:	b3 94       	inc	r11
    3444:	b3 94       	inc	r11
    3446:	04 c0       	rjmp	.+8      	; 0x3450 <vfprintf+0x314>
    3448:	8a 2d       	mov	r24, r10
    344a:	86 78       	andi	r24, 0x86	; 134
    344c:	09 f0       	breq	.+2      	; 0x3450 <vfprintf+0x314>
    344e:	b3 94       	inc	r11
    3450:	a3 fc       	sbrc	r10, 3
    3452:	10 c0       	rjmp	.+32     	; 0x3474 <vfprintf+0x338>
    3454:	a0 fe       	sbrs	r10, 0
    3456:	06 c0       	rjmp	.+12     	; 0x3464 <vfprintf+0x328>
    3458:	b2 14       	cp	r11, r2
    345a:	80 f4       	brcc	.+32     	; 0x347c <vfprintf+0x340>
    345c:	28 0c       	add	r2, r8
    345e:	92 2c       	mov	r9, r2
    3460:	9b 18       	sub	r9, r11
    3462:	0d c0       	rjmp	.+26     	; 0x347e <vfprintf+0x342>
    3464:	b2 14       	cp	r11, r2
    3466:	58 f4       	brcc	.+22     	; 0x347e <vfprintf+0x342>
    3468:	b6 01       	movw	r22, r12
    346a:	80 e2       	ldi	r24, 0x20	; 32
    346c:	90 e0       	ldi	r25, 0x00	; 0
    346e:	73 d0       	rcall	.+230    	; 0x3556 <fputc>
    3470:	b3 94       	inc	r11
    3472:	f8 cf       	rjmp	.-16     	; 0x3464 <vfprintf+0x328>
    3474:	b2 14       	cp	r11, r2
    3476:	18 f4       	brcc	.+6      	; 0x347e <vfprintf+0x342>
    3478:	2b 18       	sub	r2, r11
    347a:	02 c0       	rjmp	.+4      	; 0x3480 <vfprintf+0x344>
    347c:	98 2c       	mov	r9, r8
    347e:	21 2c       	mov	r2, r1
    3480:	a4 fe       	sbrs	r10, 4
    3482:	0f c0       	rjmp	.+30     	; 0x34a2 <vfprintf+0x366>
    3484:	b6 01       	movw	r22, r12
    3486:	80 e3       	ldi	r24, 0x30	; 48
    3488:	90 e0       	ldi	r25, 0x00	; 0
    348a:	65 d0       	rcall	.+202    	; 0x3556 <fputc>
    348c:	a2 fe       	sbrs	r10, 2
    348e:	16 c0       	rjmp	.+44     	; 0x34bc <vfprintf+0x380>
    3490:	a1 fc       	sbrc	r10, 1
    3492:	03 c0       	rjmp	.+6      	; 0x349a <vfprintf+0x35e>
    3494:	88 e7       	ldi	r24, 0x78	; 120
    3496:	90 e0       	ldi	r25, 0x00	; 0
    3498:	02 c0       	rjmp	.+4      	; 0x349e <vfprintf+0x362>
    349a:	88 e5       	ldi	r24, 0x58	; 88
    349c:	90 e0       	ldi	r25, 0x00	; 0
    349e:	b6 01       	movw	r22, r12
    34a0:	0c c0       	rjmp	.+24     	; 0x34ba <vfprintf+0x37e>
    34a2:	8a 2d       	mov	r24, r10
    34a4:	86 78       	andi	r24, 0x86	; 134
    34a6:	51 f0       	breq	.+20     	; 0x34bc <vfprintf+0x380>
    34a8:	a1 fe       	sbrs	r10, 1
    34aa:	02 c0       	rjmp	.+4      	; 0x34b0 <vfprintf+0x374>
    34ac:	8b e2       	ldi	r24, 0x2B	; 43
    34ae:	01 c0       	rjmp	.+2      	; 0x34b2 <vfprintf+0x376>
    34b0:	80 e2       	ldi	r24, 0x20	; 32
    34b2:	a7 fc       	sbrc	r10, 7
    34b4:	8d e2       	ldi	r24, 0x2D	; 45
    34b6:	b6 01       	movw	r22, r12
    34b8:	90 e0       	ldi	r25, 0x00	; 0
    34ba:	4d d0       	rcall	.+154    	; 0x3556 <fputc>
    34bc:	89 14       	cp	r8, r9
    34be:	30 f4       	brcc	.+12     	; 0x34cc <vfprintf+0x390>
    34c0:	b6 01       	movw	r22, r12
    34c2:	80 e3       	ldi	r24, 0x30	; 48
    34c4:	90 e0       	ldi	r25, 0x00	; 0
    34c6:	47 d0       	rcall	.+142    	; 0x3556 <fputc>
    34c8:	9a 94       	dec	r9
    34ca:	f8 cf       	rjmp	.-16     	; 0x34bc <vfprintf+0x380>
    34cc:	8a 94       	dec	r8
    34ce:	f3 01       	movw	r30, r6
    34d0:	e8 0d       	add	r30, r8
    34d2:	f1 1d       	adc	r31, r1
    34d4:	80 81       	ld	r24, Z
    34d6:	b6 01       	movw	r22, r12
    34d8:	90 e0       	ldi	r25, 0x00	; 0
    34da:	3d d0       	rcall	.+122    	; 0x3556 <fputc>
    34dc:	81 10       	cpse	r8, r1
    34de:	f6 cf       	rjmp	.-20     	; 0x34cc <vfprintf+0x390>
    34e0:	22 20       	and	r2, r2
    34e2:	09 f4       	brne	.+2      	; 0x34e6 <vfprintf+0x3aa>
    34e4:	4e ce       	rjmp	.-868    	; 0x3182 <vfprintf+0x46>
    34e6:	b6 01       	movw	r22, r12
    34e8:	80 e2       	ldi	r24, 0x20	; 32
    34ea:	90 e0       	ldi	r25, 0x00	; 0
    34ec:	34 d0       	rcall	.+104    	; 0x3556 <fputc>
    34ee:	2a 94       	dec	r2
    34f0:	f7 cf       	rjmp	.-18     	; 0x34e0 <vfprintf+0x3a4>
    34f2:	f6 01       	movw	r30, r12
    34f4:	86 81       	ldd	r24, Z+6	; 0x06
    34f6:	97 81       	ldd	r25, Z+7	; 0x07
    34f8:	02 c0       	rjmp	.+4      	; 0x34fe <vfprintf+0x3c2>
    34fa:	8f ef       	ldi	r24, 0xFF	; 255
    34fc:	9f ef       	ldi	r25, 0xFF	; 255
    34fe:	2b 96       	adiw	r28, 0x0b	; 11
    3500:	cd bf       	out	0x3d, r28	; 61
    3502:	de bf       	out	0x3e, r29	; 62
    3504:	df 91       	pop	r29
    3506:	cf 91       	pop	r28
    3508:	1f 91       	pop	r17
    350a:	0f 91       	pop	r16
    350c:	ff 90       	pop	r15
    350e:	ef 90       	pop	r14
    3510:	df 90       	pop	r13
    3512:	cf 90       	pop	r12
    3514:	bf 90       	pop	r11
    3516:	af 90       	pop	r10
    3518:	9f 90       	pop	r9
    351a:	8f 90       	pop	r8
    351c:	7f 90       	pop	r7
    351e:	6f 90       	pop	r6
    3520:	5f 90       	pop	r5
    3522:	4f 90       	pop	r4
    3524:	3f 90       	pop	r3
    3526:	2f 90       	pop	r2
    3528:	08 95       	ret

0000352a <strnlen_P>:
    352a:	fc 01       	movw	r30, r24
    352c:	05 90       	lpm	r0, Z+
    352e:	61 50       	subi	r22, 0x01	; 1
    3530:	70 40       	sbci	r23, 0x00	; 0
    3532:	01 10       	cpse	r0, r1
    3534:	d8 f7       	brcc	.-10     	; 0x352c <strnlen_P+0x2>
    3536:	80 95       	com	r24
    3538:	90 95       	com	r25
    353a:	8e 0f       	add	r24, r30
    353c:	9f 1f       	adc	r25, r31
    353e:	08 95       	ret

00003540 <strnlen>:
    3540:	fc 01       	movw	r30, r24
    3542:	61 50       	subi	r22, 0x01	; 1
    3544:	70 40       	sbci	r23, 0x00	; 0
    3546:	01 90       	ld	r0, Z+
    3548:	01 10       	cpse	r0, r1
    354a:	d8 f7       	brcc	.-10     	; 0x3542 <strnlen+0x2>
    354c:	80 95       	com	r24
    354e:	90 95       	com	r25
    3550:	8e 0f       	add	r24, r30
    3552:	9f 1f       	adc	r25, r31
    3554:	08 95       	ret

00003556 <fputc>:
    3556:	0f 93       	push	r16
    3558:	1f 93       	push	r17
    355a:	cf 93       	push	r28
    355c:	df 93       	push	r29
    355e:	fb 01       	movw	r30, r22
    3560:	23 81       	ldd	r18, Z+3	; 0x03
    3562:	21 fd       	sbrc	r18, 1
    3564:	03 c0       	rjmp	.+6      	; 0x356c <fputc+0x16>
    3566:	8f ef       	ldi	r24, 0xFF	; 255
    3568:	9f ef       	ldi	r25, 0xFF	; 255
    356a:	2c c0       	rjmp	.+88     	; 0x35c4 <fputc+0x6e>
    356c:	22 ff       	sbrs	r18, 2
    356e:	16 c0       	rjmp	.+44     	; 0x359c <fputc+0x46>
    3570:	46 81       	ldd	r20, Z+6	; 0x06
    3572:	57 81       	ldd	r21, Z+7	; 0x07
    3574:	24 81       	ldd	r18, Z+4	; 0x04
    3576:	35 81       	ldd	r19, Z+5	; 0x05
    3578:	42 17       	cp	r20, r18
    357a:	53 07       	cpc	r21, r19
    357c:	44 f4       	brge	.+16     	; 0x358e <fputc+0x38>
    357e:	a0 81       	ld	r26, Z
    3580:	b1 81       	ldd	r27, Z+1	; 0x01
    3582:	9d 01       	movw	r18, r26
    3584:	2f 5f       	subi	r18, 0xFF	; 255
    3586:	3f 4f       	sbci	r19, 0xFF	; 255
    3588:	20 83       	st	Z, r18
    358a:	31 83       	std	Z+1, r19	; 0x01
    358c:	8c 93       	st	X, r24
    358e:	26 81       	ldd	r18, Z+6	; 0x06
    3590:	37 81       	ldd	r19, Z+7	; 0x07
    3592:	2f 5f       	subi	r18, 0xFF	; 255
    3594:	3f 4f       	sbci	r19, 0xFF	; 255
    3596:	26 83       	std	Z+6, r18	; 0x06
    3598:	37 83       	std	Z+7, r19	; 0x07
    359a:	14 c0       	rjmp	.+40     	; 0x35c4 <fputc+0x6e>
    359c:	8b 01       	movw	r16, r22
    359e:	ec 01       	movw	r28, r24
    35a0:	fb 01       	movw	r30, r22
    35a2:	00 84       	ldd	r0, Z+8	; 0x08
    35a4:	f1 85       	ldd	r31, Z+9	; 0x09
    35a6:	e0 2d       	mov	r30, r0
    35a8:	19 95       	eicall
    35aa:	89 2b       	or	r24, r25
    35ac:	e1 f6       	brne	.-72     	; 0x3566 <fputc+0x10>
    35ae:	d8 01       	movw	r26, r16
    35b0:	16 96       	adiw	r26, 0x06	; 6
    35b2:	8d 91       	ld	r24, X+
    35b4:	9c 91       	ld	r25, X
    35b6:	17 97       	sbiw	r26, 0x07	; 7
    35b8:	01 96       	adiw	r24, 0x01	; 1
    35ba:	16 96       	adiw	r26, 0x06	; 6
    35bc:	8d 93       	st	X+, r24
    35be:	9c 93       	st	X, r25
    35c0:	17 97       	sbiw	r26, 0x07	; 7
    35c2:	ce 01       	movw	r24, r28
    35c4:	df 91       	pop	r29
    35c6:	cf 91       	pop	r28
    35c8:	1f 91       	pop	r17
    35ca:	0f 91       	pop	r16
    35cc:	08 95       	ret

000035ce <__ultoa_invert>:
    35ce:	fa 01       	movw	r30, r20
    35d0:	aa 27       	eor	r26, r26
    35d2:	28 30       	cpi	r18, 0x08	; 8
    35d4:	51 f1       	breq	.+84     	; 0x362a <__ultoa_invert+0x5c>
    35d6:	20 31       	cpi	r18, 0x10	; 16
    35d8:	81 f1       	breq	.+96     	; 0x363a <__ultoa_invert+0x6c>
    35da:	e8 94       	clt
    35dc:	6f 93       	push	r22
    35de:	6e 7f       	andi	r22, 0xFE	; 254
    35e0:	6e 5f       	subi	r22, 0xFE	; 254
    35e2:	7f 4f       	sbci	r23, 0xFF	; 255
    35e4:	8f 4f       	sbci	r24, 0xFF	; 255
    35e6:	9f 4f       	sbci	r25, 0xFF	; 255
    35e8:	af 4f       	sbci	r26, 0xFF	; 255
    35ea:	b1 e0       	ldi	r27, 0x01	; 1
    35ec:	3e d0       	rcall	.+124    	; 0x366a <__ultoa_invert+0x9c>
    35ee:	b4 e0       	ldi	r27, 0x04	; 4
    35f0:	3c d0       	rcall	.+120    	; 0x366a <__ultoa_invert+0x9c>
    35f2:	67 0f       	add	r22, r23
    35f4:	78 1f       	adc	r23, r24
    35f6:	89 1f       	adc	r24, r25
    35f8:	9a 1f       	adc	r25, r26
    35fa:	a1 1d       	adc	r26, r1
    35fc:	68 0f       	add	r22, r24
    35fe:	79 1f       	adc	r23, r25
    3600:	8a 1f       	adc	r24, r26
    3602:	91 1d       	adc	r25, r1
    3604:	a1 1d       	adc	r26, r1
    3606:	6a 0f       	add	r22, r26
    3608:	71 1d       	adc	r23, r1
    360a:	81 1d       	adc	r24, r1
    360c:	91 1d       	adc	r25, r1
    360e:	a1 1d       	adc	r26, r1
    3610:	20 d0       	rcall	.+64     	; 0x3652 <__ultoa_invert+0x84>
    3612:	09 f4       	brne	.+2      	; 0x3616 <__ultoa_invert+0x48>
    3614:	68 94       	set
    3616:	3f 91       	pop	r19
    3618:	2a e0       	ldi	r18, 0x0A	; 10
    361a:	26 9f       	mul	r18, r22
    361c:	11 24       	eor	r1, r1
    361e:	30 19       	sub	r19, r0
    3620:	30 5d       	subi	r19, 0xD0	; 208
    3622:	31 93       	st	Z+, r19
    3624:	de f6       	brtc	.-74     	; 0x35dc <__ultoa_invert+0xe>
    3626:	cf 01       	movw	r24, r30
    3628:	08 95       	ret
    362a:	46 2f       	mov	r20, r22
    362c:	47 70       	andi	r20, 0x07	; 7
    362e:	40 5d       	subi	r20, 0xD0	; 208
    3630:	41 93       	st	Z+, r20
    3632:	b3 e0       	ldi	r27, 0x03	; 3
    3634:	0f d0       	rcall	.+30     	; 0x3654 <__ultoa_invert+0x86>
    3636:	c9 f7       	brne	.-14     	; 0x362a <__ultoa_invert+0x5c>
    3638:	f6 cf       	rjmp	.-20     	; 0x3626 <__ultoa_invert+0x58>
    363a:	46 2f       	mov	r20, r22
    363c:	4f 70       	andi	r20, 0x0F	; 15
    363e:	40 5d       	subi	r20, 0xD0	; 208
    3640:	4a 33       	cpi	r20, 0x3A	; 58
    3642:	18 f0       	brcs	.+6      	; 0x364a <__ultoa_invert+0x7c>
    3644:	49 5d       	subi	r20, 0xD9	; 217
    3646:	31 fd       	sbrc	r19, 1
    3648:	40 52       	subi	r20, 0x20	; 32
    364a:	41 93       	st	Z+, r20
    364c:	02 d0       	rcall	.+4      	; 0x3652 <__ultoa_invert+0x84>
    364e:	a9 f7       	brne	.-22     	; 0x363a <__ultoa_invert+0x6c>
    3650:	ea cf       	rjmp	.-44     	; 0x3626 <__ultoa_invert+0x58>
    3652:	b4 e0       	ldi	r27, 0x04	; 4
    3654:	a6 95       	lsr	r26
    3656:	97 95       	ror	r25
    3658:	87 95       	ror	r24
    365a:	77 95       	ror	r23
    365c:	67 95       	ror	r22
    365e:	ba 95       	dec	r27
    3660:	c9 f7       	brne	.-14     	; 0x3654 <__ultoa_invert+0x86>
    3662:	00 97       	sbiw	r24, 0x00	; 0
    3664:	61 05       	cpc	r22, r1
    3666:	71 05       	cpc	r23, r1
    3668:	08 95       	ret
    366a:	9b 01       	movw	r18, r22
    366c:	ac 01       	movw	r20, r24
    366e:	0a 2e       	mov	r0, r26
    3670:	06 94       	lsr	r0
    3672:	57 95       	ror	r21
    3674:	47 95       	ror	r20
    3676:	37 95       	ror	r19
    3678:	27 95       	ror	r18
    367a:	ba 95       	dec	r27
    367c:	c9 f7       	brne	.-14     	; 0x3670 <__ultoa_invert+0xa2>
    367e:	62 0f       	add	r22, r18
    3680:	73 1f       	adc	r23, r19
    3682:	84 1f       	adc	r24, r20
    3684:	95 1f       	adc	r25, r21
    3686:	a0 1d       	adc	r26, r0
    3688:	08 95       	ret

0000368a <_exit>:
    368a:	f8 94       	cli

0000368c <__stop_program>:
    368c:	ff cf       	rjmp	.-2      	; 0x368c <__stop_program>
